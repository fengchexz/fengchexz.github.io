<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MO 论文分享：Data-free Learning of Student Networks]]></title>
    <url>%2Fposts%2F34070.html</url>
    <content type="text"><![CDATA[这一次咱们要看的论文是一篇华为的 AAAI2019 的 GAN 和蒸馏相结合的论文。知识蒸馏的基础概念大家可以看这个介绍：知识蒸馏是什么？一份入门随笔。这里，我们先简单的回顾一下知识蒸馏。 什么是知识蒸馏我们知道在深度学习的大部分网络中，有很多神经元是冗余的，但是在很多移动端，比如手机上，是跑不动这么大的网络的。所以知识蒸馏的一开始的目标是做模型压缩，它的目标就是让一个更小的网络去拟合甚至是超越教师网络的性能。在通常情况下，学生网络的在蒸馏阶段的目标可以用这样的一个函数来表示，这里的损失函数 L 根据算法对知识的定义不同也会有不同的函数表示。 比如 Hinton 在最初的知识蒸馏文章中将教师网络的知识定义为网络输出的每个类别的概率，也就是软标签。所以再这个算法中，损失函数就是教师网络和学生网络输出软标签的 KL 散度。这里 f~T~ 就是教师的输出，f~S~ 是学生的输出，下面的 T 是温度参数，我们通过让学生网络去最小化这个函数，来学习教师网络的知识，从而达到蒸馏的效果。 还有之前提到过的 Hint，通过拟合教师网络和学生网络中间层的输出来达到蒸馏的效果。这里的损失函数 L 就是教师网络和学生网络中间层输出的 L2 距离，这里的 β 是为了让输出大小相同做的一个变换。我们会发现，通过改变损失函数 L，可以得到多种多样的蒸馏方法，但是这些蒸馏方法都有个特点，就是需要教师网络和学生网络在训练的时候有着同样的输入。 Why GAN?但是在实际应用环境下，很有可能教师端训练时用的是一些隐私性的数据，比如医疗时所用的一些病人的数据，学生网络没有办法去获取这些数据，这样传统的一些蒸馏方法就不能使用了。为了解决这个问题，我们很自然的会想到，是不是可以生成一个假的数据集，然后用这个假数据集作为教师和学生公用的数据集，并在上面做蒸馏操作。在生成假数据方面，近几年最流行的就是生成式对抗网络 GAN 了。这就是为什么我们想把 GAN 和蒸馏去做一个结合。 生成式对抗网络这里简单的介绍一下生成式对抗网络，GAN 是由两个网络组成的，一个是左边的生成器网络，另一个是右边的判别器网络。生成器接收一个随机向量，并生成一个假样本。以 MNIST 数据集为例，这里的真实数据就是 MNIST 数据集中的手写数字图像，而生成器就需要去生成类似于手写数字的图片。判别器就是一个二分类器，他需要尽可能的去分辨输入的图像是真实的图片还是生成器生成的。当输入的图像是真实图片的时候，判别器需要给他一个很高的分数，当输入的图像是生成器生成的图片的时候，判别器需要给他一个很低的分数。而生成器的目标，就是让自己生成的图像尽可能的被打出一个高分。GAN 就是通过这样一种对抗的形式，来获得生成器和判别器彼此性能的提升。 训练判别器我们可以通过 GAN 的训练过程来对它做一个更加深入的理解。还是以 MNIST 数据集为例，首先我们需要更新判别器的参数。需要注意的是，在更新判别器参数的时候，生成器的参数是需要完全固定的。还是以 MNIST 数据集为例，我们看上面的绿色虚线框起来的部分，这里输入判别器的是 MNIST 数据集中的一张真实图像，经过判别器之后，会输出其属于真假两个类别的概率，我们假设输出真的概率是 0.6 假的概率是 0.4。对于输入的真实图像，我们希望判别器很确定的将其判断为真，也就是真的概率是 1，假的概率是 0。这样，我们就可以计算两者的一个交叉熵作为判别器的优化目标。这里因为判别器所作的是一个二分类任务，我们可以对交叉熵做进一步的优化，只需要其输出为真的概率，也就是上面的 0.6 尽可能的接近 1 就好了。后面的这个式子中的 D (x) 就是这里的 0.6，我们希望它越大越好。同样的，我们看到下面这里黄色虚线框起来的部分，这里输入生成器的随机向量，在这个例子中我们可以简单的理解为 100 维的服从高斯分布的向量，这个向量提供了一些跟更高维度的信息，生成器通过网络添加更多的细节，从而生成了一张假的图像。所以在这个阶段输入判别器的是生成器生成的加图像，同样的我们也会得到它属于真假两个类别的概率，判别器希望其被判定为真的概率越低越好，也就是这里的 D（G（z））越低越好。通过这里两个优化目标，我们可以对判别器计算损失并反向传播做第一次的参数更新。 训练生成器在上个阶段，判别器更新完成后，我们把判别器的参数固定，开始训练生成器。同样的，生成器生成一张假图片输入判别器，得到真假两个类别的概率。与前面不同的是，生成器希望自己生成的图片被尽可能的判定为真的，所以它需要让这里的 D (G (Z)) 越大越好。这样，整个生成式对抗网路的优化目标就很好理解了。这个阶段我们更新了生成器的参数，与前面判别器的参数更新放在一起就是 GAN 训练完整的一轮过程。不断的重复这个过程直到网络达到一个收敛的状态。 蒸馏 meets GAN在了解了生成式对抗网络之后，我们去想它怎么和蒸馏去结合起来。有、有一种很简单很直接的方法就是，直接把教师网络的数据集丢给一个随机初始化的 GAN，让他从头开始训练，然后生成假图片用来蒸馏。这种方法确实没有问题，但是从头开始训练一个 GAN, 是非常非常慢的。我们可以想一下现在所拥有的工具，除了教师端私有的数据集之外，还有一个已经训练好的性能很棒的教师网络。如果可以把这个教师网络利用起来，就可帮助生成模型更快的达到收敛状态，从而降低计算消耗。怎么去用这个教师网络呢，我们知道教师网络是在真实数据上训练出来的，比如说我们用的是 mnist 数据集，那这个预训练好的教师网络就可以很好的提取真实图像的特征，然后用这些特征去分类输入图像。这一点和 GAN 中判别器所作的任务是非常的相似的。所以我们可以把教师网络看作是一个判别器，但是这个判别器和传统的 GAN 的判别器是不一样，他的参数都是预训练好的，而不是随机初始化的，如果还是用原来的训练方法的话，那么随机初始化的生成器无论生成什么样的图片，都会被判别器以很高的置信度判定为假，这样生成器就不知道自己优化的方向了。还有一点就是，教师网络作为判别器做的也不是真假的二分类任务，如果是 mnist 数据集，那他做的就是一个 10 分类，而不是之前我们说过的输出图片属于真假类别的概率。所以对于生成器的优化目标，我们需要做一定的变化。 生成器损失 1既然生成器是用来生成图片的，我们可以想一想怎么衡量生成器生成图片的好坏呢？这其实是一个非常困难的任务，我们以生成一只猫的图片为例子，可能生成器生成了一只躺着的猫，而真实图像是一只站着的猫，所以不是说生成器生成的图像和数据集中某一张真实的猫的图像一模一样他就是好的，因此也不能的直接对两者去计算 L1L2 损失。我们可以从真实图像的某些特征上出发，因为教师网络是在真实图像上训练出来，所以一个比较好的教师网络，在输入是真实图片的时候，必定会在某一个类别的概率特别的大，在其他类别的概率特别的小。所以我们希望生成器生成的图像也具有这样的性质。这里的 yt 就是对于生成图像，教师网络得到的其属于每个类别的概率，小 t 就是取了概率最大的类别并做成 one-hot 的向量，用交叉熵来衡量他们的相似度。通过最小化这个函数来对生成图像做一个限制。 生成器损失 2同样的，我们知道卷积神经网络的卷积核就是一个特征提取器，相比于一个随机的向量，真实的输入图片会有更多与之相符合的特征，也就是它被激活的神经元会更多。所以，如果生成的图像和真实图像相似，那么他在中间层被激活的神经元也应该更多，这里用 L1 范数来衡量激活神经元的个数。 生成器损失 3最后第三项，我们从生成图片本身出发。我们的生成器是随机初始化的，一开始他生成的完全是没有意义的图像，假设生成器经过优化先生成了一张类似于手写数字 0 的图像，只是后判别器给他的分数相对是比较高，这种情况下生成器会觉的 0 这个数字是比较好的，之后无论输入是什么，他都朝着生成一个更好的数字 0 去做。这明显和我们想要的生成器是不一样的，所以对于他在每一个 batch 中生成的图像，我们需要对其做一个限制，最好的情况就是生成的图片在每一个类别上的分布都是均衡的，此时信息量也是最大的，所以我们用这样的一个函数来对它生成图片的多样性做一个限制。加上之前的两项就是生成器总的目标函数，通过这个目标函数，我们可以对生成器进行优化从而得到很多的假图像。有了假图像之后就十分简单了，只需要把之前的蒸馏方法套进来就行了，这里作者选用的是 Hinton 的软标签。 实验我们看论文的实验结果，首先看红色框框里面的三行，这里三行是说，在教师网络的数据集可以被获取到的情况下，学生网络所能达到的性能。这里教师网络是 ResNet34，学生网络是 ResNet18，数据集用的是 CIFAR10，可以看到第三行 Hinton 的知识蒸馏方法在网络参数量减少一倍的情况下，仍然保持了一个较高的分类准确率。但是到了第四行，在不能得到教师网络数据的情况下，他只能达到 14.89 的准确率。而用作者的方法，则可以达到 92.22 的准确率，这说明作者提出的算法是确实有效的。 这是作者另外作的一个剥离实验，就是去验证之前所说的生成器三项损失的有效性。我们首先看红色的框框，这个是说生成器不进行优化，随机的去生成数据，这种情况下学生网络也能达到 88 的准确率。这个和之前说的 14 的准确率不一样是因为他用的是更加简单的 MNIST 数据集。但是我们看到绿色框框中，单独的使用 one-hot 或者是激活损失，得到结果反而会比随机的要差很多。这是因为缺乏了信息熵损失函数，生成器生成的图片是非常不均衡的，这样学生就无法充分的学习到教师网络的知识。最后我们看到在综合使用三项的情况下的结果是最好的。 此外作者还做了两个额外的实验。左边这张表是说教师网络和学生网络结构一样的情况下，在不同的数据集上用作者的方法所能达到的性能。而右边这个图，是把教师网络和学生网络的卷积核进行可视化后的结果，我们可以看到，在 13456 列学生网络和教师网络卷积核的可视化结果非常的相似，这就说明学生网络确实对教师网络进行了有效的学习。]]></content>
      <categories>
        <category>机器学习</category>
        <category>蒸馏</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>蒸馏</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件推荐（一）]]></title>
    <url>%2Fposts%2F46698.html</url>
    <content type="text"><![CDATA[这是软件推荐的第一期。虽然个人博客确实没什么人看，但还是会用心的去完成它，就当是给现在的自己存个档。感谢点开这个网页的所有人，如果本期内容对你有用的话，就点个赞吧～ 先来个全家福 软件 简介 平台 Listary 全局搜索 / 快速启动 / 文件定位 Win WGestures 全局鼠标手势 Win QuickLook 快速浏览文档 / 表格 / 图片（仿 mac） Win Ditto 剪贴板增强工具 Win Clover 资源管理器增强 Win Snipaste 截图工具增强 Win Listary官方网站 很多人对我桌面的第一感觉就是：干净。确实，算不上很好看，我认为简洁方便就是最好的工作环境。桌面上没有任何的软件图标完全得益 Listary 强大的功能。双击 Ctrl，弹出这个搜索框，你就打开了新世界的大门。启动软件、搜索文件 Listary 全都不在话下 (搜索功能支持在保存文件时使用)。 类似的软件还有很多，例如火萤、utools、wox 等，Listary 是我在综合考虑内存占用和实际效率的选择，需要更高的扩展性或者是更多好玩功能的小伙伴也可以试一试这些，都很不错哟～ WGestures官方网站 (官网的 gif 演示有助于大家更快速的了解这款软件) 这是一个鼠标手势软件，有什么用呢？简单地说，就是可以用鼠标替代各种快捷键以及繁琐的操作，如果你也厌倦了每天 ctrl+c,ctrl+v 以及各种小标签页的切换，那么不妨试试这款软件。初版 17 年就停止了更新，但是前进、后退、最大化、最小化、执行代码等功能一应俱全，此外还支持不同情景下的自定义手势，可谓是高效工作必备神器。（小 tips：打游戏的时候还是把它关了吧～） QuickLook官方网站（微软的应用市场有同款～） 使用 mac 系统的小伙伴应该都知道一个很赞的功能，就是通过单机空格键可以快速的对各种类型的文件进行浏览。有些文本或者是图片，可能我们只是想看一眼，并不需要编辑，因此快速浏览的重要性就体现了出来，这款软件就是在 Windows 系统上实现了这个简单却很实用的功能。 Ditto官方网站 这是一个剪贴板增强工具，值得一提的是新版 Windows 本身就带有这个功能，大家按 win+v 就能看到历史粘贴的内容。不过这个粘贴板不能对图片或者文件的历史复制进行记录，而且在重启电脑后会丢失之前的粘贴记录。Ditto 就很好的做到了这些，通过 ctrl+` 触发还，支持剪贴板搜索哦～ Clover果核剥壳版、SOURCEFORGE 大家是不是有上图的困扰呢…… 这对一个强迫症来说，是绝对不能忍受的！Clover 可以把这 n + 的窗口全部变成浏览器式的 tab 标签，而且支持快捷键以及标签页的拖入拖出，双击空白区域返回上级标签就和原生的 windows 资源管理器甩了几条街！ Snipaste官方网站 大家都是怎么截图的？windows 自带截图或者是打开 qq 微信截图？截图这个功能或许非常简单，但要做到用户满意，却不是那么容易。我们想要一个快速、支持自定义，并且可以做一些简单的划线、标记操作，就像手机那样。这么一想，天哪，微软自带的截图怎么会如此的不人性化！除了各种图像的简单操作外（加文字、马赛克、画图、标记等），Snipaste 还有一项很实用的功能就是将图片贴在屏幕上，并保持置顶状态，这在一些阅读及数据处理情景下简直是神兵利器！ 结语这一期的软件分享就先到这里啦～这些软件都是风车自己正在使用的，在我看来他们都是提升效率的神器，之后还会继续的更新软件推荐专栏。 说点题外话，早上见着了难得的太阳，很温暖。最近听到一些挺伤感的事，希望大家都能用赤子之心待身边的人，也祝愿你们都能找到好朋友，找到真正对自己好的人。]]></content>
      <categories>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅深度学习笔记 1-Tips for Deep Learning]]></title>
    <url>%2Fposts%2F10868.html</url>
    <content type="text"><![CDATA[Good Results on Training Data?New activation functionsigmoid 会把输入的大变化压缩成较小的输出变化，因此在网络加深时会导致梯度消失现象 ReLU Q:ReLU 会导致神经网络变为线性的吗？A: 对于使用 ReLU 的网络，整体还是非线性的，当输入做较大改变的时候，激活的神经元就会发生变化 ReLU-variant MaxoutMaxout 让每一个神经元自动去学习他的激活函数 如图所示，Maxout 将固定数量 (需要自己调整) 的神经元分为一组，并取组中最大的值作为输出。通过这样的方法，Maxout 可以拟合出 ReLU 以及其他任意的分段线性凸激活函数 Q:Maxout 是否会导致未被选择的神经元不能训练？A: 对于不同的输入数据，Maxout 所选择激活的神经元在训练的过程中不断地进行变化，因此理论上每一个 weight 都会被训练到 Adapive learning rateAdaGrad AdaGrad 会使用到历史梯度的信息，对于当前当前需要更新的 w，如果其平常的 gradient 都比较大，那么当前所处位置应该比较 “陡峭”，所以选取比较小的 learning rate；反之，如果平常 gradient 都比较小，那么当前所处位置应该比较 “平坦”，所以选取比较大的 learning rate RMSProp RMSProp 与 AdaGrad 的不同之处在于，AdaGrad 使用历史所有的梯度平均来对当前的学习率进行限制，而对于某一个方向，有可能会出现一会陡峭一会平坦的情况。所以 RMSProp 通过 α 来对历史梯度的比重进行限制，将 α 设置的更小，模型就会更加注重新的梯度对当前学习率的影响。 Momentum Adam Good Results on Testing Data?Early StoppingRegularizationL1 and L2L1 和 L2 都会使得参数减小 L1 在每次更新的时候减去一个固定值 L2 在每次更新时乘上一个小于 1 的固定值 L1 会使得有很多参数都接近 0，但是会存在很大的值；L2 会使得参数的平均都是比较小 Weight DecayDropout Dropout 是指在训练时以概率 p 随机的丢弃一些神经元 在 testing 的时候不做 dropout 在 training 时，假设 Dropout 的概率为 p，则 training data 中训练出的所有 weight 需要乘上 (1-p) 才能被当作 testing 的 weight 使用 如果网络很接近于线性模型，Dropout 所得到的结果会比较好，因此采用 ReLU 和 Maxout 的网络通常会和 Dropout 配合使用]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅深度学习笔记 2-Convolutional Neural network]]></title>
    <url>%2Fposts%2F8586.html</url>
    <content type="text"><![CDATA[Why CNN for Image？相较于 DNN，CNN 使用局部连接和权值共享大大降低了参数量，为什么这种方法可行呢？ 某一张图片的 pattern 通常只是一小部分，因此对于某一个神经元来说，并不需要看整张图像 (局部连接) 对于某一个局部特征，当他出现在图像的不同位置时，完全可以只使用一个 detector (权值共享) 对一张图像进行 subsampling，例如把奇数行、偶数列的 pixel 拿掉，并不会影响人们对这张图象的理解。而这却可以大大的降低计算量 (池化) Some Notes李宏毅老师的 PPT 真的讲的很仔细，把之前自学的一些疑惑点以及搞了很久才弄懂的东西很通俗易懂的讲出来了，这里简单记录一下。 Colorful Image彩色图像有 RGB 三个通道，但是其输出层的神经元个数仍然与卷积核的个数相等，每一个卷积核都与 iamge 的三层做内积。 Convolution V.s. Fully connected 局部连接和权值共享在这个图中已经显示的很清楚了局部连接：全连接网络的后一个神经元与前一层所有神经元相连。而卷积操作中某一个神经元只连接了前一层的部分神经元，这一部分也成为感受野权值共享：对于同一个卷积核得到不同的神经元，虽然他们连接了前一层中不同的神经元，但是所用到的权值都是一样的。 Max PoolingFlattenWhat does CNN learn？what does filter do我们用 $a_{ij}^{k}$ 表示第 k 个卷积核下标 ij 分别表示第 i 行第 j 列，可以定义第 k 个卷积核的激活度可以表示为:$$a^k=\sum_{i=1}^{11}\sum_{j=1}^{11}a_{ij}^{k}$$ 在训练阶段，我们通过计算梯度来调整卷积核的参数使得损失尽量小。类似的，我们通过梯度上升来找到一张 image 使得这个卷积核的激活程度达到最大值，优化的目标表示如下：$$x^*=\arg\max_x a^k$$ 最终得到的结果如上图所示。以第三张 image 为例，上面布满了小小的斜条纹，可以认为其就是检测原图像中某个小部分的斜条纹这一特征。其他的卷积核也类似的检测输入图像的一些纹理特征。 what does neuron do与上述方法类似的，我们也可以定义出最后的 flatten 操作中每个神经元的优化目标：$$x^*=\arg\max a^j$$ 最终得到的结果如上图所示。可以看到和 filter 得到的结果有很大的区别，因为在 flatten 之后，每个神经元所关注的不再是类似于 fliter 的某个部分，而是整张图片，所以图中所示就是可以使得他激活成都最大的 image。 what about output类似的，我们以可以得到输出层神经元所最希望 “看到的” image。以手写数字识别为例，很自然的想法是如果以数字 1 所代表的输出去进行梯度上升，得到的图像应该是一个数字 1 的图形，但是最终的结果并不是这个样子的。神经网络所学到的东西跟我们一般人类的想象认知并不是完全一样的。当然，我们可以通过对网络添加一些限制来使得这个结果更加的趋近于数字。 APPlicationDeep Dream把某一层的 filter 中的正值调大，负值调小，这样相当于 “夸大 CNN 所看到的信息” Deep Style Playing GoSpeech Text]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅深度学习笔记 3-Semi-supervised Learning]]></title>
    <url>%2Fposts%2F22725.html</url>
    <content type="text"><![CDATA[IntroductionSupervised Learning：$(x^r,y^r)^R_{r=1}$ 每一组 data 都有 input $x^r$ 和 output $y^r$ 相对应 Semi-supervised Learning：$\begin{Bmatrix}(x^r,\hat{y}^r)\end{Bmatrix}^R_{r=1}+\begin{Bmatrix}x^u\end{Bmatrix}^{R+U}_{u=R}$ 部分 data 没有与 input $x^u$ 相对应的标签 实际上 data 很容易搜集，只是缺少有 label 的 data，所以 $U\ll R$ Why semi-supervised learning help没有标签的数据虽然只有 input，但是他们的分布，可以告诉模型进行分界线的调整。半监督学习的使用往往会伴随着假设，假设的合理与否，决定了最终结果的好坏。 ———————————————— Semi-supervised Generative Model在有监督学习的概率生成模型中，以二分类为例，我们很容易就能得到 $P (C_1)$ 和 $P (C_2)$，通过对已知样本计算极大似然估计就能求得每个类别的均值和方差，从而可以得到 $P (x|C_1)$ 和 $P (x|C_2)$。最后根据概率公式就能计算出新的样本属于每个类别的概率。 在半监督生成模型中，计算的公式会有相应的变化，其具体步骤如下： 随机初始化一组参数：$\theta=\begin {Bmatrix} P (C_1),P (C_2),u^1,u^2,\sum\end {Bmatrix}$ 利用 model 计算每一笔 unlabeled data $x^u$ 属于 class1 的概率 $P_\theta (C_1|x^u)$ 更新参数： 计算每个类别的概率：$P (C_1)=\frac {N_1+\sum _{x^u} P (C_1|x^u)}{N}$ 计算每个类别的均值：$u_1=\frac {1}{N_1}\displaystyle\sum_{x^r\in C_1} x^r+\frac {1}{\sum_{x^u} P (C_1|x^u)}\displaystyle \sum_{x^u} P (C_1|x^u) x^u$ 其他参数也可以用类似的方法得到 重复 2、3 步骤直至模型收敛 流程中的步骤 2 和步骤 3 即是 EM algorithm 中的 E 和 M Low-density Separation AssumptionLow-density separation 方法的基础假设是：这个世界是非黑即白的，在两个类别的交界处数据的密度是很低的，因此两类数据之间会有明显的鸿沟 Self Training 先用 labeled data 训练一个模型 $f^*$, 可以使用任意的方法 然后用训练好的 $f^*$ 给 unlabeled data 打上标签 从 unlabeled data 中拿出一些 data 放入到 labeled data 中，选取的方法需要自定义 重复 1-3 的步骤 与 Generative Model 的区别： Self Training 每一次选取的 unlabeled data 会强制给其打上标签，又称为 hard label。而 Generative Model 会在每一次得到新模型的时候更新 unlabeled data 的 label 概率值，又称为 soft label。 Entropy-based RegularizationSemi-supervised SVMSmoothness Assumptionconceptsdigits detectionfile classficationcluster and then labelGraph-based Approach]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅深度学习笔记 4-Unsupervised Learning]]></title>
    <url>%2Fposts%2F50926.html</url>
    <content type="text"><![CDATA[ClusteringK 均值聚类 (K-means)随机的选取 k 个点作为 cluster 的 center，计算其他点与各个 center 的距离，将其归类为最近的一个 cluster 层次聚类 (Hierarchical Agglomerative Clusteing、HAC) 类似于归并。首先我们需要将现有的数据构造一个树结构。这个树的构造过程如下： 数据点间两两组成一个 pair 计算距离，找到最近的一个 pair，将这个 pair 中的两个数据点取出合并成一个 cluster，并将这两个点的平均作为新的 vector 加入原来的数据集中。 重复步骤 1 直到整个数据集归并成一个 cluster 在得到了树结构之后，怎么将数据分为不同的 cluster 呢？之时候需要你决定一个分割的位置。例如切在下图中的红线位置，那么就变成了两个 cluster（3、2），如果切在蓝线的位置，那么就变成了三个 cluster（2、1、2）。 distributed representationcluster 有一个特点就是，每个 x 必将被确定的分类于一个类别。这就类似于一个 one hot 的向量，但是我们知道网络在做预测的时候，其实是会给每一个类别一个概率的。例如数字 2 可能会写的像 3 或者 7，那么网络虽然最终将其分类为 2，但是在 3 或者 7 上仍会给出一定的概率。distributed representation 做的就是这样一件事情，他用一个 vector 来表示 x。如果这个 vector 相对于 x 来说是一个更低维的空间，那么这就叫做 dimension reduction，两者做的是同一件事，知识称呼不同而已。 降维降维的可行性以 MNIST 为例，每一个数字 3 在其中表示为 28*28 的矩阵，但实际上表示这一堆数字 3 只需要一个维度。有些数字三左转了 10 度，有些右转了 20 度，我们只需要确定这个角度，就能唯一确定一个数字三。我们可以用更小的维度来确定原来复杂的数据，这就是降维。 那么怎么做降维呢？我们需要做的就是找到一个 function，这个 function 可以将输入空间中的 x 映射到一个更低维的空间。 特征选择这是降维中最简单的方法，只需要将原数据中不需要的维度拿掉。例如一个 excel 表格中每一列表示一个特征，其中有一列序号对于最终的预测并无影响，因此我们将这一列删掉。但是实际操作中，通常每个特征都是不可或缺的。 主成分分析 (Principe component abalysis、PCA)矩阵分解 PCA 所选取的 function，就是很简单的 linear function。如图中所示，我们可以将原先二维的数据点映射在红色或者黄色的线上，这条线所选取的原则就是：经过 projection 之后，得到的不同数据点的分布越大越好。这也就是说，我们不希望映射之后这些数据点聚在一起，不同的数据点在映射之后必须是仍然可以” 看 “出来的。 实例 - 词嵌入为什么需要词嵌入在自然语言处理中，词与词之间通常是会存在一定联系的。如果使用传统的 one hot 形式，例如猫为 [1,0,0]，狗为 [0,1,0]，这样两者在输入网络的时候是完全没有任何关系的，但其实他们都为动物，且在句子中的成分也十分相似，所以我们需要一种更加合适的方法来表示这两个词。怎么做呢？这就是我们在做阅读时长提到的概念：上下文。 基于计数的词嵌入如果有两个词 $w_i$ 和 $w_j$，他们经常出现在同一篇文章中，那么我们希望表示这两个词的 vector 尽可能的接近。这个方法有一个代表性的例子叫做 Glove vector 基于预测的词嵌入这种方法通过预测当前单词下一个可能的单次来得到他的词向量。假设世界上有 10W 个单词，那么我们的网络就输出一个 10W 维的 vector，每一维的值就是预测的这个单词的概率 (这里的输入是 one hot 形式)。通过将输入这个单词时，将网络隐藏层取出来构成一个新的向量，就是当前单词的 vector。 多语言嵌入多域嵌入文档嵌入]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Federated Learning for Vision-and-Language Grounding Problems]]></title>
    <url>%2Fposts%2F8974.html</url>
    <content type="text"><![CDATA[文章背景这篇文章的背景是这样的，首先我的每个客户端输入的都是图像，这些图像可以是不同类型的，作者在实验中是用了两个不同的数据集来表示这一点。其次是每个客户端的任务也可以是不同的，比如一部分做视觉问答，另一部分做图像描述。因为他们的任务不一样，所以传统的联邦学习方法就不适用了。作者的方法概括的说就是让服务端去学习一个对应于不同任务的图像表示。具体的我们看下面这张图，可以简单的分为三个阶段，首先第一个阶段客户端在自己的模型上得到一个原始图像表示，也就是一个向量。然后把这个向量发送给服务端。第二个阶段服务端通过聚合不同客户端传来的信息加工得到一个更好的图像表示，再把这个表示发送给客户端，最后第三个阶段客户端就可以用这个图像表示来做自己的任务。 阶段一我们看第一个阶段，这个阶段提取输入图像的一个表示，它用到的网络都是预先训练好的，所以不展开讲。作者提取了两种特征，一种是从 Fast R-CNN 的全连接层中提取到的视觉特征，这里 d 表示的是隐藏层神经元的个数，N 表示的是候选区域的个数。另外一种是文本特征，这里解释一下这个网络，他的功能是从原来的图像中框出 M 个候选区域，类似于下面这样，然后他从 1000 个单词中找出和这个区域最匹配的单词，每个单词都是用 d 维的词向量表示的。假设客户端输入一张图像的话，那么经过这个阶段，客户端就得到了两个向量组，一个是表示这个框中图像的 I，另一个是表示这些单词的 T，其实就是两个序列或者说两个矩阵。每一个客户端都会得到这样的两个矩阵，然后他们发送给服务端，服务端需要对些矩阵进行加工，这就是第二个阶段。 阶段二第二个阶段也可以分为三个步骤 Aligning Module首先第一个步骤 Aligning Module，这个我不知道怎么翻译，他的出发点是这样的。这个 I 中的一个向量表示了图像的某一个区域，我需要结合语义来得到一个更好的表示，同样的 T 中的单词需要对应于区域来避免歧义的产生。比如 mouse 这个单词，需要对应到图像后才知道是老鼠或者鼠标。具体的方法的话，作者是用了下面的这个公式，我们一步步的看，首先是 MHA 的计算，根据这个公式计算得到一个 Attention 矩阵，这里 I 就是图像矩阵，T 就是文本矩阵，用图像矩阵点积文本矩阵的转置，然后进行缩放，再经过 softmax 输出后与文本矩阵做点积。我说一下自己对这个公式的理解，分子中的这个点积操作得到的是两个矩阵之间的相似度，这个相似度除了点积之外还有其他的一些计算方法，作者选取点积是因为这个更快而且不占内存空间。这个相似度就是对于当前模型来说，每一个图像区域对于每一个单词的重要程度，最后点积 T 就是把这个信息融入到了文本特征中，同样的如果换成下面的 TII 的话，就是把这个信息融入到了图像特征中。最后，做多次 Attention 计算，将每一次得到的矩阵进行通道维度的拼接，就是完整的 MHA 操作。然后是最外面一层的 FFN，这个就比较简单了，他的公式是这样的，就是一个两层的前馈神经网络，中间用了 Relu 激活函数。 更加直观的理解这个过程的话我们可以看下面这张图，他要做的就是图像和文本信息的结合，比如，下面这个高亮的人用这些词表示，高亮的狗用这些词来表示。所以经过这个 Aliging Module 的步骤，我们得到的还是两个矩阵。 Integrating Module然后我们看第二步，这一步的公式就是下面这个，乍一看这个不是和之前那个一模一样吗，只不过输入变成了三个一样的矩阵，那么这个公式是什么意思呢？我们说前一步是结合了图像和文本的信息，那这一步的目标是得到区域之间或者单词之间的一个关系，这是一个自注意力机制。更直观一点的话我们可以看下面这张图，假设我输入的是两个一模一样的句子，那最后得到的就是单词之间的一些句法特征或语义特征，比如他会注意到 its 指代的对象就是下面的 Law，以及和它相互依赖的 application。这一步的输出也是两个矩阵。 Mapping Module最后第三步，看这个公式一样的也是一个两层的前馈神经网络，值得注意的是，它是一个分叉的结构，这个分叉的数量取决于客户端所作的任务的种类。也就是说，给视觉问答和图像描述的两个任务的图像表示是不一样的。 阶段三之前说的所有的这三步，都是在对客户端得到的图像表示进行一个加工，最后的输出也是矩阵的形式。光有这个矩阵是不能进行反向传播的，所以需要把这个矩阵回传的客户端，然后让他们用这个矩阵去做各自的一个下游任务，通过这个下游任务来评判得到的这个矩阵的好坏。所以他的整个流程应该是这样的，客户端通过两个预训练好的模型得到图像的两种表示，然后传给服务服务端，服务端加工后得到另外的两种图像表示并传回给客户端，客户端用这两个表示作为输入传入自己的网络做对应的任务，然后每一个客户端根据自己任务的评判指标去更新自己的网络以及服务端的网络，直到他达到一个收敛的状态。 实验总体效果作者首先模拟了联邦学习的三种情况，这里下面的表是第一种垂直情况的，就是每个客户端使用不同的数据集做相同的任务，我们可以看到对于 baseline 来说的话不管是什么数据集都是作者提出的这种要好。其他的两种情况也都是这样的，这就说明作者提出的这个方法是确实有效的，这是他的一个总体情况。 细致分析此外作者还对模型的每一部分做了分析。分别用 Aligning 和 Integrating 去做图像描述和视觉问答，以这张图为例，在做图像描述的时候，Aligning 会注意到这是个红色的杯子以及桌子的材质，而 Integrating 则是注意到了与杯子相邻的菠萝。更通用的说，Aligning 偏向于物体的颜色或者某种属性，这个是物体本身固有的，而 Integrating 更偏向于和当前物体有关的其他的一些物体。同样的，在视觉问答中，Aligning 偏向于回答在哪里或者是什么这种问题，而 Integrating 对物体的数量特别的敏感。 这和我们之前的分析是一致的，Aligning 得到的是图像和文本间的关系，也就是图中红色的框对应蛋糕，红色，而蓝色的框对应胡萝卜、蔬菜。而 Integrating 则是会从蛋糕出发，找到一些和他相关的区域，或者是一些和他相关的单词。所以 Aligning 对视觉问答的提升较大而 Integrating 对图像描述的提升会较大，另外同时使用这两个会在不同的任务上得到更好的效果。 可能存在的问题最后是我自己觉得他可能存在的问题。这里服务端虽然没有直接获取客户端输入的图像，但是却可以得到所有输入图像的两种表示，而每个客户端得到这两种表示的网络模型是完全固定的。如果这个模型被获取到，或者是通过反向计算得到输入的图像，就会造成客户端数据的泄露。]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Multi-modal Self-Supervision from Generalized Data Transformations]]></title>
    <url>%2Fposts%2F6875.html</url>
    <content type="text"><![CDATA[自监督学习首先简单的介绍一下自监督学习和对比学习。自监督学习在我看来更偏向于无监督学习，因为他处理的对象也是无标签的数据，但是不同于无监督学习，它希望用自己构造的一些标签，作为一个辅助任务来训练网络。比如我们看到下面，我可以对原图像做一个旋转让他去预测旋转的角度，或者对原图像挖掉一块让他去预测挖掉的这块图像，这个挖掉的图像就是人为创造的标签。 自监督学习的目标是通过辅助任务，来得到一个比输入更加低维的向量。这个低维向量应用于下游任务的时候，能够得到比直接输入 x 更好的效果。举个例子的话就是自然语言处理中的 word2vec，这个算法大家应该都听过，就是用前 N 个单词来预测下一个可能的单词，这里的下一个单词，就是人为构造出来的一个辅助任务。我们可以用着个辅助任务去训练网络，然后提取出中间层的输出，就是我们常说的词向量。这个词向量比 one-hot 形式的向量更加适用于自然语言处理的各种任务。这就是一个自监督学习的例子。 对比学习第二个概念是对比学习，我们首先看一个例子。我们知道现实中的狗长什么样子，但是我们不能画出一只一模一样的；同样的，虽然我们画不出来，但是我们很容易辨认出左边这个也是一条狗。所以说，我的网络不需要关注于图像的每一个细节，只需要将狗这个类别和其他的类别，比如猫、大象等尽可能的区分开来就行。这就是对比学习的核心目标，让相似的样本尽可能接近，让不相似的样本尽可能的远离。因此我们需要一个函数 s 来计算两个样本之间的距离，简单一点的话，s 可以取向量的内积。这里分母的两项就是正样本之间以及正样本和负样本的距离，我们希望前一项尽可能大，后一项尽可能小，这样小括号里面就趋近于 1，也就是整体趋近于 0。很容易想到正负样本的数量以及距离函数的选择，这两者是会直接影响对比学习网络的性能的。 MOCO这一篇何凯明的论文就是从样本数量上出发来进行优化。我们看到最左边的图 a，这是最原始的对比学习方法，我的正样本和负样本通过同一个编码网络得到各自的一个向量表示（这里左右两个 encoder 是同一个网络），然后通过之前的公式计算他们的对比损失，最后反向传播更新参数。这个方法存在的问题就是，我每一次所选取的正负样本数量，会受到 batchsize 的限制，这样的话我们得到的这个正负样本间的距离，实际上是不准确的。所以就有了图 b 中的方法，这个方法把所有的负样本的向量都计算出来，然后在随机的选取一部分和正样本做一个损失，但是这个方法的缺点也很明显，就是对所有样本进行计算会带来很大的内存消耗。所以作者提出可以维持一个负样本的队列，这个队列比 bathsize 要大，然后每一次把新的负样本放进去，把旧的拿出来。这个方法在实验的时候得到的效果很差，作者认为可能是编码网络一直在更新，导致了队列中前后两次得到的负样本表示是不一样的，这就存在一致性的问题。所以作者把正负样本的编码网络分开来，正样本的编码网络还是像原来一样通过对比损失反向传播来更新，而负样本的编码网络通过下面的公式来更新。这里的 θ~k~ 是负样本也就是右边这部分网络的参数，θ~q~ 是正样本网络的参数，m 是一个动量值。这个公式也很容易理解，前面的这一项来保持了原来网络的一个参数，让他的参数更新达到一个更加平缓的效果。 SimCLR第二篇论文的是 Hinton 的 SimCLR，在我看来的话他就也是从损失函数的角度去对对比学习做一个优化。我们直接看他的框架图。这里对输入图像做一个数据增强，比如说这里对猫做一个翻转，或者是旋转、割一块等等，我希望对于同一个输入变换来的两张图象，他得到的两个向量应该是尽可能的相近的，而对于不同的输入，比如我再输入一只大象，他也得到两张数据增强后的图像，然后也会得到两个向量，这两个向量和猫的两个向量应该尽可能的远。假设当前的 batch 里面只有一张猫的图像和一张大象的图像，他们经过数据增强后会得到四张图象，我们看这个矩阵。输入第一只猫的时候，这一块表示的是两个猫的距离，就是损失函数中的分子，整个三块就是损失函数中的分母，然后四张图像每一张都这么算，最后做一个平均，就是这个 batch 的损失。这个方法的话他只是改了损失函数，所以和之前的那种方法是可以一起用的，整个算法流程也是一样的，就是对比损失的计算不一样而已。 多模态自监督最后就是这篇多模态自监督学习的论文，他用的其实就是我们之前说的两种算法结合起来的形式，只不过他扩展到了多模态的领域。图上这个例子输入的是视频，对输入的视频首先做几个切点，每个点是 1s，然后提取出图像和音频，我希望同一个样本的不同模态间应该是尽可能的近的，不同样本之间应该尽可能的远。我们直接看他的损失函数，这里 f (TD) 可以理解为第一条线得到的向量，T‘D 可以理解为第二条线，后面这部分其实就是我们之前说过的内积的形式，只不过多了个 w。这个 w 是指，当我的 T 和 T’‘是同一个模态的时候，他是 0，不同模态就是 1，因为作者认为不同模态间计算可以使得模型具有更好的鲁棒性。而前面这个 c 其实就是在控制正负的样本。比如说我只想研究两个视频之间的，而不去管我的切点选在那里，那我就可以把上面这部分任意两条线之间的 C 全部设置为 0，这样模型就会只关注上面这部分和下面这部分之间的距离，就是说我不会去管蓝色的圈和绿色圈的远近。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>论文</tag>
        <tag>对比学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fitnets：Cross Modal Distillation for Supervision Transfer]]></title>
    <url>%2Fposts%2F30669.html</url>
    <content type="text"><![CDATA[看完这篇文章我的内心是崩溃的…… 因为是第一次接触多模态深度学习，所以去搜索了解了一些基本的概念，然后在千辛万苦弄懂理解了他的方法之后，发现和之前的蒸馏文章 Fitnets：Hints for Thin Deep Nets 提出的方法是完全一样的，就是换了种表达而已…… 看了下两篇文章的投稿分别是 2015 年的 ICLR 和 CVPR，行吧…… 多模态深度学习要理解这个概念，首先要知道什么是 “模态”。模态是指某种类型的信息，或者是该信息的表示，例如文字、语言、声音、图形等。图像的模态也可以有很多种，例如 RGB 图像、深度图像、航拍图像、红外图像等。为了让机器更好的理解这个世界，他必须要能学习和处理这些模态的信息。多模态机器学习就是指建立模型使机器从多模态中学习各个模态的信息，并且实现各个模态的信息的交流和转换。 Supervision Transfer这里首先介绍一下深度图像，我们从图中可以看到，它是由一块一块的颜色组成的，这些不同的颜色代表了这个位置的东西距离我看过去这个视点的远近。不同于 ImageNet，这一类的图像通常是缺乏标签的，因此无法直接在这些图像上做有监督的训练。这篇文章所提出的方法就是说，我可以从 RGB 图像上训练好一个模型，然后我去学习他对输入图像的一个 rich representation （蒸馏中的知识） 文章里用了很多的假设和数学记号，但其实整个过程下来和之前的蒸馏 Hint 那篇文章的方法是完全一致的，我们看一下他的具体算法流程： 在 RGB 图像上进行充分的训练直至达到收敛状态得到模型 L 取 L 中间层的输出并与模型 U 中间层的输出计算损失 这里因为中间层的输出可能不一致，需要使用一个卷积层将 U 的中间层输出 resize 成和 L 中间层输出一致 损失函数的选择在进行了不同的尝试后作者选取了 L2 损失 对于中间层的选取，作者使用 AlexNet 的第二个池化层 根据步骤 2 得到的损失反向传播训练 U 的前半段网络 在 depth 图像上进行训练直至模型 U 达到收敛状态 实验 这里对其对比的方法 [15] 做一个简单的说明（其实我也没仔细看），这篇文章是用其提出的某种方法提取了 RGB 和 depth 图像的特征，并将两部分一起传入 SVM 中做目标检测。此外 [15] 的作者还提出一种泛化的 Fast R-CNN 做法，具体是先用 Fast R-CNN 在 RGB 图像上训练，然后作者用某种方法对 depth 图像进行处理变成 HHA 图像（可以理解为与 RGB 更近似），并将之前训练好的模型在 HHA 图像上进行微调。 可以看到仅对于其参考的方法的话，作者的方法有了很大程度提升]]></content>
      <categories>
        <category>机器学习</category>
        <category>蒸馏</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>蒸馏</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用网站汇总（长期更新）]]></title>
    <url>%2Fposts%2F48156.html</url>
    <content type="text"><![CDATA[做一个各种良心网站的汇总，另外有时间会做实用软件的分享，大家有什么的好的网站或者软件也可以告诉我～ 学习谷歌镜像点我跳转呀～ 没有梯子也能用谷歌哦～ iData点我跳转呀～白嫖知网论文～ SCI-HUB点我跳转呀～ 如果你也像我一样进不了学校图书馆的数据库，又想白嫖各种论文，试试这个吧。当然，也是因为这个原因，SCI-HUB 的网址经常更换，这里会实时更新 SCI-HUB 的地址。 科塔学术导航点我跳转呀～ 致力于成为国内领先的科研与学术资源导航平台，为科研人员提供科研网站导航、网址库、学术资讯聚合等服务，让科研工作更简单、更有效率。 电子书搜索这个其实挺多的，这里简单贴几个吧。 熊猫搜书 书栈网 鸠摩搜书 码农之家 书格 云海图书馆 wikiHow点我跳转呀～ 这个网站有点意思，各种学习、生活、工作的技巧网站，涵盖了方方面面。不懂咱就问～ 彩云小译点我跳转呀～ 虽然不推荐全文翻译，但是如果你需要一个简单的参考，又找不到免费的全文翻译软件的话，试试彩云小译吧，还有浏览器插件哦～ 影视温馨提示：以下网站请配合浏览器广告屏蔽插件 AdBlock 食用 剧汇 TV 推荐，资源挺全的，速度也比较快，提供磁力链接下载 茶杯狐 推荐，界面简洁资源丰富，可以单独下载字幕 片库 主要是电视剧，这个也很赞，推荐 1080 影视、低端影视 主要是电影，清晰度很棒，更新没有那么快 天天美剧 和片库差不多，界面难看一点 MVCAT 这个网站超级漂亮！主要是做电影推荐，兼具聚合搜索功能 音乐 墨灵音乐 铜钟 疯狂音乐搜索 音乐搜索 Listen1 网抑云 1 网抑云 2 MyFreeMP3 还有个音乐下载器 (落雪音乐)：https://wws.lanzous.com/b01nkbi3c 密码：3npp 效率工具文档格式转换点我跳转呀～ 只有你想不到，没有他做不到的文档格式转换！还记的当年的格式工厂吗，各种版本安装的时候总会带上些杂七杂八的东西，现在 office 文档、图片、pdf 等等的格式转换全部可以在线做！ 视频音频剪辑点我跳转呀～ 最大支持 500M 的视频文件，适合一些不是专业做视频剪辑，却有一些小需求的用户。 pdf 工具箱点我跳转呀～ pdf 的在线工具箱其实有很多，大部分为了恰口饭在拥有一定用户量后改成了收费或者单日限制模式。这一款一直是免费的，像这么良心的越来越少了，哎～ 简版 PS点我跳转呀～ 和上面的剪辑视频一样，适合非专业又有一定图片编辑需求的用户。功能其实对于我们来说已经足够了 万能命令https://wanneng.run/cn/ 在你浏览的任意网站前加上 wn.run/，回车后你会看到各种可以用于此网站的工具！！！比如，在 b 站首页加上命令打开 https://wn.run/bilibili.com 就是下面这个效果👇 虫部落资源搜索点我跳转呀～ 这是一个聚合搜索引擎，虽然我不是很常用，但是会在很多地方看到推荐虫部落的，这个社区也蛮有意思的，感兴趣的可以多研究研究。 虫部落电子书搜索 虫部落快搜 虫部落学术搜索 虫部落网盘搜索 AI 抠图点我跳转呀～ 图片放大点我跳转呀～ 适合一些动漫、插画的图片放大。普通照片也可以，但是放大后的效果可定没有那么好，无损放大什么的，不要太天真啦～ 今日热榜点我跳转呀～ 快速的了解热点事件。聚合了微博、知乎、微信、今日头条…… 反正都一样卡，手机 APP 现在在国内下不到了，可以上 Google Play 的直接搜索名字就行，真的超级好用！ 临时邮箱点我跳转呀～ 临时短信接收点我跳转呀～ 拒绝暴露个人信息！骚扰电话都走开！ 在线流程图制作点我跳转～ 网盘搜索这些网盘搜索实际上都大同小异，虫部落已经做了聚合，其他的并不怎么推荐。实在有网盘资源找不到的时候可以试一试 西林街 虫部落 云搜 小不点搜索 百度云搜 微盘 盘搜搜 盘搜 呆河马 好玩的网站知妖点我跳转呀～ 中怪古代各种妖怪的介绍，还带可视化的有木有…… 全历史点我跳转呀～ 历史也可以很好看～ 一些生成器狗屁不通文章生成器 藏头诗生成器 微博翻牌生成器 装逼生成器 表情包生成器 工具 123点我跳转呀～ 各种好玩的小工具～ 小鸡词典点我跳转呀～ 跟你们这些年轻人聊天，还得备个网络流行词词典，太难了……]]></content>
      <categories>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FedMD：Heterogenous Federated Learning via Model Distillation]]></title>
    <url>%2Fposts%2F43465.html</url>
    <content type="text"><![CDATA[在做工作总结的时候，老师问我们看了这么多联邦学习和蒸馏的论文，有没有什么自己的想法呢？具体的比如怎么将蒸馏应用到联邦学习中呢？确实，在之前的工作中大部分都是带任务性的 “被动” 的阅读，以致没有注意到这样基础的问题，这一点以后需要多加注意。这一篇文章就是将蒸馏与联邦学习相结合的一种方法，思路也非常的简单。让我们一起来看一下。 FedAvg首先回顾一下 FedAvg 算法的流程： 在每一轮更新开始之前，随机的选取部分客户端，比例为 C (C≤1) 服务端将当前的全局算法状态（模型参数）发送给这些客户 每个客户端以步骤 2 的参数做初始化，在本地数据集上执行若干个 E (epoch) 的更新 客户端将更新后的参数上传给服务端，服务端计算参数的加权平均并更新 重复步骤 1-4 我们注意到在 FedAvg 算法中，服务端和客户端之间传递是整个模型的参数，这样，当我的模型很大的时候，需要传递的参数也非常多，需要很大的通信成本。同时这种简单的取参数平均的方法，必须要求服务端以及各个客户端的模型是完全一样的。这在实际的操作中是非常困难的。 使用蒸馏 &amp; 迁移学习在学习了蒸馏相关的知识之后，我们很自然的会想到：对于客户端所学习到的东西，我们可不可以不在局限于模型的参数，而是之前所学习过的软标签、中间层输出 Hint 或者是层与层之间的关系 FSP 矩阵呢？这里我们以软标签为例，对应到联邦学习的话就是，服务端得到了各个客户端的软标签，然后计算了一个加权平均值，并把这个值告诉客户端让他们自己去更新。这个过程的其实存在有一个很大的问题，我们知道在蒸馏当中，为了去拟合学生的输出，有一个必要的前提就是，我的教师和学生所用的数据集必须是一样的。而在联邦学习中，每个客户端的数据集通常是 non-IID 的，也就是说我如果想用软标签来更新，就必须有一个公共的数据集，这个数据集是各个客户端数据集的集合，这样的话，就和联邦学习的初衷相违背了，那么怎么解决这个问题呢？既然我需要一个公共的数据集，这个数据集又不能和本地的数据集一样，那我是不是可以使用一些公开的数据集，比如，ImageNet。这个数据集和我客户端需要处理的图像是完全不一样的。所以，要使用这个数据集，就必须用到迁移学习的方法。知道了这些，我们就可以理解他的整个算法了。 &lt;img src=”http://ww1.sinaimg.cn/large/005Sr5tQly1ggvhesftysj30zt0jyq5d.jpg";"&gt; FedMD下面我们看一下他的整个算法流程。这里客户端我画了不同的形状表示他们可以使用不同的模型。首先需要对客户端做一个初始化，每一个客户端都需要在公共数据集上进行充分的训练到达收敛的状态，然后用迁移学习的方法在自己的私有数据集上进行训练。初始化之后就可以开始联邦学习了，每个客户端需要给出公共数据集属于各个类别的概率，就是软标签，这里为了减少通信量可以选取部分公共数据集。然后服务端对这些软标签做一个平均传回客户端，将这个平均值作为客户端需要学习的知识。客户端需要在公共数据集上去拟合这个平均。然后继续在自己的私有数据集上训练几个 epoch。这样一个过程作为一轮，重复这个过程直到各个客户端的模型达到收敛状态。 &lt;img src=”http://ww1.sinaimg.cn/large/005Sr5tQly1ggvhi0iat3j30z70jw0xs.jpg";"&gt; 实验结果最后是实验部分，作者在两种数据集上做了实验，结果差不多，这里以其中一种为例。公共数据集是手写数字 MNIST，客户端私有的数据集是 FEMNIST，这个和手写数字差不多，是手写的字母。每个客户端采用的是 2-4 层的 CNN，他们使用不同的通道数以及 dropout。图中的折线表示的就是用了 FedMD 之后每个客户端达到的测试准确率。左下方的虚线是指不使用联邦学习，客户端只在自己的私有数据以及公有数据集上训练的结果，这也是 baseline。右上角的虚线表示其他的客户端将数据发送给当前客户端，也就是每个客户端拥有全部的数据所能达到的实验结果，这也是我们需要取接近或者超越的目标。可以看到 FedMD 算法达到了比 baseline 更好的性能但是和拥有全部数据集的情况还是有差距。 &lt;img src=”http://ww1.sinaimg.cn/large/005Sr5tQly1ggvhj69rx1j30yu0jntck.jpg";"&gt;]]></content>
      <categories>
        <category>机器学习</category>
        <category>联邦学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>论文</tag>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAYING MORE ATTENTION TO ATTENTION：IMPROVING THE PERFORMANCE OF CONVOLUTIONAL NEURAL NETWORKS VIA ATTENTION TRANSFER]]></title>
    <url>%2Fposts%2F19568.html</url>
    <content type="text"><![CDATA[这是蒸馏论文的第四篇，将注意力机制引入知识蒸馏中，总体来说还算比较好懂。作者提出了基于 Activation 和基于 Gradient 两种注意力迁移的方法。 ACTIVATION-BASED ATTENTION TRANSFER 正如图中所示，作者将 HxWxC 的特征图通过计算后得到 attention map，这中计算有一个潜在假设，就是隐藏层神经元的绝对值可以用作表示这个神经元的重要性。这样，我们就可以计算通道维度的统计量，对此作者提出了三种计算方法：绝对值求和、绝对值指数求和以及绝对值指数求最大值 通过计算得出 attention map 后，我们很容易就能理解以下 Student 网络的损失函数 这里前面的 $L (W_s,x)$ 表示标准的交叉熵，即 hard target。后面的 $Q_S^j$ 和 $Q_T^j$ 分别表示 Student 和 Teacher 的 attention map，将他们做归一化并取 p 范数就是 soft target (我的表述不够准确，这一部分就是 Student 在拟合 Teacher 所学到的知识) 从上面的公式我们知道，Student 和 Teacher 的 attention map 必须是等大的，作者给出了 Resnet 网络下 Attention loss 所在的位置 GRADIENT-BASED ATTENTION TRANSFER这一部分看的还是有些迷迷糊糊，以下讲一下我自己的理解，大家可以做个参考 作者认为网络输出对于输入的梯度，代表了网络对于每一个像素的敏感度。首先定义出两者对于输入的梯度： 那么 Student 学习的目标就是让自己的 $J_S$ 与 $J_T$ 尽可能的相似，所以定义 Student 的损失函数如下： 这个公式中 $W_T$ 和 $x$ 都是固定的，我们计算其对 $W_S$ 的梯度： 实际上在训练过程中，Teacher 网络的 $J_T$ 是可以事先计算好的，而对于 Student 网络，我们需要先对其进行前向传播，根据交叉熵损失进行反向传播计算出 $J_S$，然后根据 $L_{AT}$ 的计算公式进行计算并再次进行反向传播得到梯度，这个梯度就是 Student 本轮需要优化的方向。 此外，为了强制梯度 Attention 的水平翻转不变性，作者把原图和水平翻转的图像都进行传播，最后的损失函数如下（这个没太懂是翻转后的图像再一次计算，还和合并了两次操作）： 完结撒花～]]></content>
      <categories>
        <category>机器学习</category>
        <category>蒸馏</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>蒸馏</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Squeeze-and-Excitation Networks]]></title>
    <url>%2Fposts%2F64344.html</url>
    <content type="text"><![CDATA[读这篇论文主要是为了学习注意力机制 (Attention)，论文没有做精度，想对文章做快速了解的可以观看 b 站视频：https://www.bilibili.com/video/BV1SA41147uA?from=search&amp;seid=5000503775793461277 注意力机制我们在观察人或物时，通常会集中注意力于某一部分，从而在短时间达到对目标的快速认识。这是我们天然所习得的合理利用有限的视觉信息处理资源的能力。对应于神经网络，注意力机制通常是指能够选择性的输入某些部分，或者给输入的不同部分分配以不同的权重。 以卷积神经网络为例，我们可以在空间维度引入 Attention 机制 (如图 Inception 网络中不同颜色表示不同的权重)，也可以在通道维度增加 attention 机制。 通道维度的 attention 文中中所用的方法如图所示。这里我们可以先对其做一个简单的理解。假设原先的特征图大小为 HxWxC，我们通过某种方式使其变成了 1x1xC 的大小，在这个维度下，每个通道的值就对应着这个通道的权重。之后直接将原先特征图的每个通道乘上变换后对应通道的值，就完成了通道维度的 attention。每个通道的权重值，需要在神经网络训练的过程中去逐渐的学习。 通道权重的计算步骤那么 HxWxC 的特征图是怎么变为 1x1xC 的通道权重的呢？我们将其分为 squeeze、excitation、scale 三个步骤 Squeeze我们通过一个全局池化 (Global pooling) 来计算每个通道的值并对初始的特征图进行压缩，计算公式如下： &lt;img src=”http://ww1.sinaimg.cn/large/005Sr5tQly1gglukdj096j30f5030jre.jpg";"&gt; 这个公式还是比较容易理解的，就是将平均池化扩大至了全局的范围，也是因为如此，计算出的实数 $z_c$ 拥有全局的感受野。在 Squeeze 操作后的大小为 1x1xC Excitation这一阶段我们需要将上一步骤得到的 1x1xC 的特征图对应于于每一个通道生成权重。在文中，作者使用全连接的方式先将通道数变小然后再进行回复，最后通过 Sigmoid 函数来将输出限制在 0~1 中。 &lt;img src=”http://ww1.sinaimg.cn/large/005Sr5tQly1ggluw5ppi6j30ib0hcgm9.jpg" style=”zoom:80%”;”&gt; Scale将上一步得到的归一化权重直接逐通道进行相乘，这就完成通道维度的 attention 机制。 论文相对比较简单。如果文章存在问题或者大家对博客有什么建议，欢迎在留言指出 (留下邮箱哦)~]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>论文</tag>
        <tag>Attention</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Gift from Knowledge Distillation：Fast Optimization，Network Minimization and Transfer Learning]]></title>
    <url>%2Fposts%2F46070.html</url>
    <content type="text"><![CDATA[不同于大多数的蒸馏模型中用小模型去拟合大模型的输出，这篇文章将知识定义为神经网络中层与层之间的关系（特征图的内积）文中提到这样做有三个优点： student 网络可以学习的更快 student 网络可以比 teacher 网络的性能更优 适用于迁移学习（teacher 和 student 属于不同的任务 知识的定义将神经网络的输入和输出看作是问题和答案，之前介绍的 Romero 等人的文章指出让学生模型去拟合教师模型中间层的输出。但是我们知道解决问题的方法可能不止一种，比如图中的最短路径可能有多个解，因此这篇作者就指出让学生模型去学习这种解决问题的方法。这种方法在网络中表现为层与层之间的关系。 数学表示$${G_{i,j}(x;W)=\displaystyle \sum_{s=1}^{h} \sum_{t=1}^{w}\frac{F_{s,t,i}^1(x;W)\times F_{s,t,j}^2(x;W)}{h\times w}}$$ 假设两层特征图的大小分别为 $h\times w \times m$ 和 $h\times w\times n$，那么最后得到的 FSP (flow of the solution process) 矩阵就是两个特征图中的各个通道彼此做点积。我们看这个公式，公式隐含的要求了两个特征图单个通道的大小必须是一样的，而这个性质和残差结构非常的像。事实上，作者用到的网络结构也正是带残差块的。此外这个例子中 FSP 矩阵的大小为 m*n，也就是说 FSP 矩阵的大小仅于通道数有关，而与每个通道的大小无关，这就解决了 Student 网络得到的 FSP 矩阵和 Teacher 的不一致的问题。 损失函数 Student 模型就是在对每对 FSP 矩阵做 L2 损失的基础上进行加权和：$$L_{FSP}(W_t,W_s)=\frac {1}{N}\displaystyle \sum_{x}\sum_{i=1}^{n}\lambda_i\times |G_i^T(x;W_t)-G_i^S(x,W_s)|_2$$ 训练流程与 Romero 等人一致，作者也使用了两阶段的训练方式，完整的算法流程如下： 首先我们用上面所提到的 FSP 损失来训练 Student 网络使其学习 Teacher 模型层与层之间的关系，之后将这个阶段所 Student 学得的参数作为下一阶段的初始化参数。下一个阶段则和普通训练一致，以分类问题为例，损失函数可以选择 Softmax。 第二个阶段模型所做的任务可以和 Teacher 模型不同，这就可以用于迁移学习。此外，在这个初始化参数下，作者用实验证明了模型可以快速的进行优化且达到比教师网络更好的性能。]]></content>
      <categories>
        <category>机器学习</category>
        <category>蒸馏</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>蒸馏</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fitnets：Hints for Thin Deep Nets]]></title>
    <url>%2Fposts%2F18035.html</url>
    <content type="text"><![CDATA[这是知识蒸馏的第二篇文章，文章认为 Hinton 提出的 knowledge distillation 方法 (KD) 简单的拟合 Teacher 模型的输出并不能使 Student 达到和 Teacher 一样的泛化性能。对此，作者提出了 hint（隐藏层的输出）的概念。此外，作者认为在 thin 的条件下使得网络更 deep 可以在降低参数量的同时提升 Student 网络的性能。 Student 的损失函数 因为 Student 是更为轻量的网络，所以中间层的特征图大小与 Teacher 并不完全一致，因此需要 $W_r$ 矩阵来调整为同样的大小。为了减少参数量以及内存的消耗，作者将这一天调整的全连接改为卷积的形式。最终 Student 损失函数的完整形式如下：$$L_{HT}(W_{Guided},W_r)=\frac{1}{2}|u_h(x;W_{Hint})-r(v_g(x;W_{Guided});W_r)|^2$$这里 $u_h$ 表示 teacher 从输入到第 h 层的映射函数，$v_g$ 表示 student 从输入到第 g 层的映射函数，r 表示卷积层调整器，$W_r$ 为 r 对应的参数。 训练流程 阶段一： 选择 Teacher 中提取第 N 层输出作为 hint，提取 Student 中第 M 层输出作为 guided 使用卷积层调整器对 guided 的维度进行调整 优化 Student 最小化前文所述的 $L_{HT}$ 损失函数 阶段二： 使用第一阶段 Student 的参数作为初始参数 用 Hinton 提出的 KD 算法对 student 模型进行蒸馏]]></content>
      <categories>
        <category>机器学习</category>
        <category>蒸馏</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>蒸馏</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Distilling the Knowledge in a Neural Network]]></title>
    <url>%2Fposts%2F45831.html</url>
    <content type="text"><![CDATA[蒸馏的定义将预先训练好的复杂模型的 “知识” 转移到较为轻量的模型上的操作称为蒸馏。（这里的 “知识” 在以前被定义为网络的参数，而在文中作者将其定义为从输入到输出的映射。 Hard targets&amp;Soft targetsHard targets 是指在分类问题中预测的最终目标通常是一个 one-hot 形式的向量，而 Soft targets 是指保留预测结果中属于每一类别的概率（集成模型中可以是几何或者算数平均） 为什么 Soft targets 有效？模型给出的当前输入属于其他错误类别的概率，即使很小，也隐藏了一定的信息。以 MNIST 分类为例，数字 “2” 的写法不同会导致其像数字 3（后面多出一点）或者数字 7（少画了一点），一个训练好的模型，即使最终的预测结果是 2，其在 3 或者 7 的类别中也会有一定的概率，这个概率表示模型认为这两者有一定的相似性。直接使用 one-hot 形式会丢失掉这部分的信息。 带温度的 Softmax​ —————————– 在新的公式中，参数 T 就是温度值，当 T 设置为 1 时，公式与 Softmax 一致。T 值升高会避免原先的 sofrmax 对最大值的凸显，这样就避免了 teacher model 在正确类别上给出的置信度过高。 Student 的损失函数$$\huge L =\lambdaL_{soft}+(1-\lambda)L_{hard}$$ 这里如果 $\lambda$ 设置为 1，可以理解为这就是传统的模型压缩，用一个小模型去学习了大模型的预测结果。而后面的一项则是 Student 在此基础上做进一步的自我学习，这样 Student 的能力是完全有可能超过 Teacher 的。 为什么蒸馏会有效虽然 Teacher 模型更加的复杂，但是其网络中有很多参数是冗余的，也就是说其学得的映射关系并不是看上去这么复杂，因此我们可以用更小的 Student 模型来更加精炼的学习这种映射关系。 算法流程 在训练集上训练好一个大模型 Teacher model 使用 Teacher model 生成训练集的 soft target 利用 Teacher model 的 soft target 以及 ground truth 的 hard target 训练 student model 保留 student model 用作线上预测 实验Preliminary experiments on MNIST net layers hidden units activiation regularization error num(test) net1 2 1600 relu dropout 67 net2 2 800 relu no 146 以 net1 为 teacher，net2 为 Student，测试记过如下： net teacher student error num(test) distilled net net1 net2 74 Experiments on speech recognition system Test Frame Accuracy Word Error Rate on dev set baseline 58.9% 10.9% 10XEnsemble 61.1% 10.7% Distilled model 60.8% 10.7% 其中 basline 的配置为 8 层，每层 2560 个 relu 单元 softmax 层的单元数为 14000 训练样本大小约为 700M，2000 个小时的语音文本数据 蒸馏模型的配置为 使用的候选温度为 {1, 2, 5, 10}, 其中 T 为 2 时表现最好 hard target 的目标函数给予 0.5 的相对权重]]></content>
      <categories>
        <category>机器学习</category>
        <category>蒸馏</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>蒸馏</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成式对抗网络综述]]></title>
    <url>%2Fposts%2F32841.html</url>
    <content type="text"><![CDATA[GANGAN 简介生成式对抗网络 (Generative adversarial networks,GANs) 的核心思想源自于零和博弈，包括生成器和判别器两个部分。生成器接收随机变量并生成 “假” 样本，判别器则用于判断输入的样本是真实的还是合成的。两者通过相互对抗来获得彼此性能的提升。判别器所作的其实就是一个二分类任务，我们可以计算他的损失并进行反向传播求出梯度，从而进行参数更新。 GAN 的优化目标可以写作：$$\large {\min_G\max_DV(D,G)= \mathbb{E}{x\sim p{data}}[\log D(x)]+\mathbb{E}_{z\sim p_z(z)}[log(1-D(G(z)))]}$$其中 $\log D (x)$ 代表了判别器鉴别真实样本的能力，而 $D (G (z))$ 则代表了生成器欺骗判别器的能力。在实际的训练中，生成器和判别器采取交替训练，即先训练 D，然后训练 G，不断往复。 WGAN在上一部分我们给出了 GAN 的优化目标，这个目标的本质是在最小化生成样本与真实样本之间的 JS 距离。但是在实验中发现，GAN 的训练非常的不稳定，经常会陷入坍缩模式。这是因为，在高维空间中，并不是每个点都可以表示一个样本，而是存在着大量不代表真实信息的无用空间。当两个分布没有重叠时，JS 距离不能准确的提供两个分布之间的差异。这样的生成器，很难 “捕捉” 到低维空间中的真实数据分布。因此，WGAN (Wasserstein GAN) 的作者提出了 Wasserstein 距离 (推土机距离) 的概念，其公式可以进行如下表示：$$W(\mathbb P_r,\mathbb P_g)=\inf_{\gamma\sim\prod{\mathbb P_r,\mathbb P_g}}\mathbb E_{(x,y)~\gamma}[|x-y|]$$这里 $\prod {\mathbb P_r,\mathbb P_g}$ 指的是真实分布 $\mathbb P_r$ 和生成分布 $\mathbb P_g$ 的联合分布所构成的集合，$(x,y)$ 是从 $\gamma$ 中取得的一个样本。枚举两者之间所有可能的联合分布，计算其中样本间的距离 $|x-y|$，并取其期望。而 Wasserstein 距离就是两个分布样本距离期望的下界值。这个简单的改进，使得生成样本在任意位置下都能给生成器带来合适的梯度，从而对参数进行优化。 DCGAN卷积神经网络近年来取得了耀眼的成绩，展现了其在图像处理领域独特的优势。很自然的会想到，如果将卷积神经网络引入 GAN 中，是否可以带来效果上的提升呢？DCGAN (Deep Convolutional GANs) 在 GAN 的基础上优化了网络结构，用完全的卷积替代了全连接层，去掉池化层，并采用批标准化 (Batch Normalization,BN) 等技术，使得网络更容易训练。 用 DCGAN 生成图像为了更方便准确的说明 DCGAN 的关键环节，这里用一个简化版的模型实例来说明。代码基于 pytorch 深度学习框架，数据集采用 MNIST 12345678910111213141516171819202122232425import torchimport torch.nn as nnimport torchvisionfrom torchvision import transformsfrom torchvision.utils import save_imageimport os #定义一些超参数nc = 1 #输入图像的通道数nz = 100 #输入噪声的维度num_epochs = 200 #迭代次数batch_size = 64 #批量大小sample_dir = 'gan_samples'# 结果的保存目录if not os.path.exists(sample_dir): os.makedirs(sample_dir)# 加载MNIST数据集trans = transforms.Compose([ transforms.ToTensor(),transforms.Normalize([0.5], [0.5])])mnist = torchvision.datasets.MNIST(root=r'G:\VsCode\ml\mnist', train=True, transform=trans, download=False)data_loader = torch.utils.data.DataLoader(dataset=mnist, batch_size=batch_size, shuffle=True) 判别器 &amp; 生成器判别器使用 LeakyReLU 作为激活函数，最后经过 Sigmoid 输出，用于真假二分类生成器使用 ReLU 作为激活函数，最后经过 tanh 将输出映射在 $[-1,1]$ 之间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 构建判别器class Discriminator(nn.Module): def __init__(self, in_channel=1, num_classes=1): super(Discriminator, self).__init__() self.conv = nn.Sequential( # 28 -&gt; 14 nn.Conv2d(nc, 512, 3, stride=2, padding=1, bias=False), nn.BatchNorm2d(512), nn.LeakyReLU(0.2), # 14 -&gt; 7 nn.Conv2d(512, 256, 3, stride=2, padding=1, bias=False), nn.BatchNorm2d(256), nn.LeakyReLU(0.2), # 7 -&gt; 4 nn.Conv2d(256, 128, 3, stride=2, padding=1, bias=False), nn.BatchNorm2d(128), nn.LeakyReLU(0.2), nn.AvgPool2d(4), ) self.fc = nn.Sequential( # reshape input, 128 -&gt; 1 nn.Linear(128, 1), nn.Sigmoid(), ) def forward(self, x, label=None): y_ = self.conv(x) y_ = y_.view(y_.size(0), -1) y_ = self.fc(y_) return y_# 构建生成器class Generator(nn.Module): def __init__(self): super(Generator, self).__init__() self.fc = nn.Sequential( nn.Linear(nz, 4*4*512), nn.ReLU(), ) self.conv = nn.Sequential( # input: 4 by 4, output: 7 by 7 nn.ConvTranspose2d(512, 256, 3, stride=2, padding=1, bias=False), nn.BatchNorm2d(256), nn.ReLU(), # input: 7 by 7, output: 14 by 14 nn.ConvTranspose2d(256, 128, 4, stride=2, padding=1, bias=False), nn.BatchNorm2d(128), nn.ReLU(), # input: 14 by 14, output: 28 by 28 nn.ConvTranspose2d(128, 1, 4, stride=2, padding=1, bias=False), nn.Tanh(), ) def forward(self, x, label=None): x = x.view(x.size(0), -1) y_ = self.fc(x) y_ = y_.view(y_.size(0), 512, 4, 4) y_ = self.conv(y_) return y_ 训练模型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 使用GPUdevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')D = Discriminator().to(device)G = Generator().to(device)# 损失函数及优化器criterion = nn.BCELoss()D_opt = torch.optim.Adam(D.parameters(), lr=0.001, betas=(0.5, 0.999))G_opt = torch.optim.Adam(G.parameters(), lr=0.001, betas=(0.5, 0.999))def denorm(x): out = (x + 1) / 2 return out.clamp(0, 1)def reset_grad(): d_optimizer.zero_grad() g_optimizer.zero_grad()for epoch in range(num_epochs): for i, (images, labels) in enumerate(data_loader): images = images.to(device) real_labels = torch.ones(batch_size, 1).to(device) fake_labels = torch.zeros(batch_size, 1).to(device) #————————————————————训练判别器—————————————————————— #鉴别真实样本 outputs = D(images) d_loss_real = criterion(outputs, real_labels) real_score = outputs #鉴别生成样本 z = torch.randn(batch_size, nz).to(device) fake_images = G(z) outputs = D(fake_images) d_loss_fake = criterion(outputs, fake_labels) fake_score = outputs #计算梯度及更新 d_loss = d_loss_real + d_loss_fake reset_grad() d_loss.backward() d_optimizer.step() #————————————————————训练生成器—————————————————————— z = torch.randn(batch_size, nz).to(device) fake_images = G(z) outputs = D(fake_images) g_loss = criterion(outputs, real_labels) #计算梯度及更新 reset_grad() g_loss.backward() g_optimizer.step() if (i+1) % 200 == 0: print('Epoch [{}/{}], Step [{}/{}], d_loss: {:.4f}, g_loss: {:.4f}, D(x): {:.2f}, D(G(z)): {:.2f}' .format(epoch, num_epochs, i+1, total_step, d_loss.item(), g_loss.item(), real_score.mean().item(), fake_score.mean().item())) # 保存生成图片 fake_images = fake_images.reshape(fake_images.size(0), 1, 28, 28) save_image(denorm(fake_images), os.path.join(sample_dir, 'fake_images-{}.png'.format(epoch+1)))# 保存模型torch.save(G.state_dict(), 'G.ckpt')torch.save(D.state_dict(), 'D.ckpt') 可视化结果12345reconsPath = './gan_samples/fake_images-200.png'Image = mpimg.imread(reconsPath)plt.imshow(Image)plt.axis('off')plt.show() &lt;img src=”http://ww1.sinaimg.cn/large/006AP6c1ly1ggdsfb1ia5j304u07074m.jpg" ;”/&gt; cGAN在之前介绍的几种模型中，我们注意到生成器的输入都是一个随机的噪声。可以认为这个高维噪声向量提供了一些关键信息，而生成器根据自己的理解将这些信息进行补充，最终生成需要的图像。生成器生成图片的过程是完全随机的。例如上述的 MNIST 数据集，我们不能控制它生成的是哪一个数字。那么，有没有方法可以对其做一定的限制约束，来让生成器生成我们想要的结果呢？cGAN (Conditional Generative Adversarial Nets) 通过增一个额外的向量 y 对生成器进行约束。以 MNIST 分类为例，限制信息 y 可以取 10 维的向量，对于类别进行 one-hot 编码，并与噪声进行拼接一起输入生成器。同样的，判别器也将原来的输入和 y 进行拼接。作者通过各种实验证明了这个简单的改进确实可以起到对生成器的约束作用。 判别器 &amp; 生成器只需要在前向传播的过程中加入限制变量 y，我们很容易就能得到 cGAN 的生成器和判别器模型 12345678910111213141516class Discriminator(nn.Module): ... def forward(self, x, label): label = label.unsqueeze(2).unsqueeze(3) label = label.repeat(1, 1, x.size(2), x.size(3)) x = torch.cat(tensors=(x, label), dim=1) y_ = self.conv(x) ...class Generator(nn.Module): ... def forward(self, x, label): x = x.unsqueeze(2).unsqueeze(3) label = label.unsqueeze(2).unsqueeze(3) x = torch.cat(tensors=(x, label), dim=1) y_ = self.fc(x) ... Pix2Pix在上面的 cGAN 例子中，我们的控制信息取的是想要图像的标签，如果这个控制信息更加的丰富，例如输入一整张图像，那么它能否完成一些更加高级的任务？Pix2Pix (Image-to-Image Translation with Conditional Adversarial Networks) 将这一类问题归纳为图像到图像的翻译，其使用改进后的 U-net 作为生成器，并设计了新颖的 Patch-D 判别器结构来输出高清的图像。Patch-D 是指，不管网络所使用的输入图像有多大，都将其切割成若干个固定大小的 Patch，判别器只需对这些 Patch 的真假进行判断。因为 L1 损失已经可以衡量生成图像和真实图像的全局差异，所以作者认为判别器只需要用 Patch-D 这样更关注于局部差异的结构即可。同时 Patch-D 的结构使得网络的输入变小，减少了计算量并且增大了框架的扩展性。 CycleGANPix2Pix 虽然可以生成高清的图像，但其存在一个致命的缺点：需要相互配对的图片 x 与 y。在现实生活中，这样成对的图片很难或者根本不可能搜集到，这就大大的限制了 Pix2Pix 的应用。对此，CycleGAN (Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks) 提出了不需要配对的图像翻译方法。 CycleGAN 其实就是一个 X-&gt;Y 的单向 GAN 上再加一个 Y-&gt;X 的单向 GAN，构成一个 “循环”。网络的结构和单次训练过程如下（图片来自于量子位）： 除了经典的基础 GAN 损失之外，CycleGAN 还引入了 Consistency loss 的概念。循环一致损失使得 X-&gt;Y 转变的过程中必须保留有 X 的部分特性。循环损失的公式如下：$$L_{cyc}(G,F)=\mathbb E_{x\sim p_{data}(x)}[|F(G(x))-x|1]+\mathbb E{y\sim p_{data}(y)}[|G(F(x))-y| 1]$$两个判别器的损失表示如下：$$\textit{L}{GAN}(G,D_Y,X,Y)=\mathbb E_{y\sim p_{data}(y)}[logD_Y(y)]+\mathbb E_{x\sim p_{data}(x)}[log(1-D_Y(G(x)))]$$ $$\textit{L}_{GAN}(F,D_X,Y,X)=\mathbb E_{x\sim p_{data}(x)}[logD_X(x)]+\mathbb E_{y\sim p_{data}(y)}[log(1-D_X(F(y)))]$$ 最后网络的优化目标可以表示为$$\min _{G_{X\rightarrow Y},G_{Y\rightarrow X}}\max_{D_X,D_Y} L(G,F,D_x,D_y)=L_{GAN}(G,D_Y,X,Y)+L_{GAN}(F,D_X,Y,X)+\lambda L_{cyc}(G,F)$$ Pix2Pix 以及 CycleGAN 的官方复现入口：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix StarGANPix2Pix 解决了有配对图像的翻译问题，CycleGAN 解决了无配对图像的翻译问题，然而他们所作的图像到图像翻译，都是一对一。假设现在需要将人脸转换为喜怒哀乐四个表情，那么他们就需要进行 4 次不同的训练，这无疑会耗费巨大的计算资源。针对于这个问题，StarGAN (StarGAN: Unified Generative Adversarial Networks for Multi-Domain Image-to-Image Translation) 借助 cGAN 的思想，在网络输入中加入一个域的控制信息。对于判别器，其不仅需要鉴别样本是否真实，还需要判断输入的图像来自哪个域。StarGAN 的训练过程如下： 将原始图片 $c$ 和目标生成域 $c$ 进行拼接后丢入生成器得到生成图像 $G (x,c)$ 将生成图像 $G (x,c)$ 和真实图像 $y$ 分别丢入判别器 D，判别器除了需要判断输入图像的真伪之外，还需要判断它来自哪个域 将生成图像 $G (x,c)$ 和原始生成域 $c’$ 丢入生成器生成重构图片 (为了对生成器生成的图像做进一步的限制，与 CycleGAN 的重构损失类似) 了解了 StarGAN 的训练过程，我们很容易得到其损失函数各项的表达形式首先是 GAN 的一般损失，这里作者采用了前文所述的 WGAN 的损失形式：$$L_{adv}=\mathbb E_x[D_{src}(x)]-\mathbb E_{x,c}[D_{src}(G(x,c)))]-\lambda_{gp}\mathbb E_{\hat x}[(|\nabla \hat xD{src}(\hat x)| 2-1)^2]$$对于判别器，我们需要鼓励其将输入图像正确的分类到目标域 c‘（原始生成域）：$$L{src}^r=\mathbb E_{x,c’}[-logD_{cls}(c’|x)]$$对于生成器，我们需要鼓励其成功欺骗判别器将图片分类到目标域 c（目标生成域），此外，生成器还需要在以生成图像和原始生成域 c’的输入下成功将图像还原回去，这两部分的损失表示如下：$$L_{src}^f=\mathbb R_{x,c}[-logD_{cls}(c|G(x,c))]$$ $$L_{rec}=\mathbb E_{x,c,c’}[|x-G(G(x,c),c’)|_1]$$ 各部分损失乘上自己的权重加总后就构成了判别器和生成器的总损失：$$L_D=-L_{adv}+\lambda_{cls}L_{cls}^{r}$$ $$L_G=L_{adv}+\lambda_{cls}L_{clas}^f+\lambda_{rec}L_{rec}$$ 此外，为了更具备通用性，作者还加入了 mask vector 来适应不同的数据集之间的训练。 总结 名称 创新点 DCGAN 首次将卷积神经网络引入 GAN 中 cGAN 通过拼接标签信息来控制生成器的输出 Pix2Pix 提出了一种图像到图像翻译的通用方法 CycleGAN 解决了 Pix2Pix 需要图像配对的问题 StarGAN 提出了一种一对多的图像到图像的翻译方法 InfoGAN 基于 cGAN 改进，提出一种无监督的生成方法，适用于不知道图像标签的情况 LSGAN 用最小二乘损失函数代替原始 GAN 的损失函数，缓解了训练不稳定、生成图像缺乏多样性的问题 ProGAN 在训练期间逐步添加新的高分辨率层，可以生成高分辨率的图像 SAGAN 将注意力机制引入 GAN 当中，简约高效利用了全局信息 本文列举了生成式对抗网络在发展过程中一些具有代表性的网络结构。GANs 如今已广泛应用于图像生成、图像去噪、超分辨、文本到图像的翻译等各个领域，且在近几年的研究中涌现了很多优秀的论文。感兴趣的同学可以从下面的链接中 pick 自己想要了解的 GAN~ THE-GAN-ZOO：汇总了各种 GAN 的论文及代码地址。 GAN Timeline：按照时间线对不同的 GAN 进行了排序。 Browse state-of-the-art：将 ArXiv 上的最新论文与 GitHub 代码相关联，并做了比较排序，涉及了深度学习的各个方面。 参考文献 Goodfellow I, Pouget-Abadie J, Mirza M, et al. Generative adversarial nets[C]//Advances in neural information processing systems. 2014: 2672-2680. Arjovsky M, Chintala S, Bottou L. Wasserstein gan[J]. arXiv preprint arXiv:1701.07875, 2017. Radford A, Metz L, Chintala S. Unsupervised representation learning with deep convolutional generative adversarial networks[J]. arXiv preprint arXiv:1511.06434, 2015. Mirza M, Osindero S. Conditional generative adversarial nets[J]. arXiv preprint arXiv:1411.1784, 2014. Isola P, Zhu J Y, Zhou T, et al. Image-to-image translation with conditional adversarial networks[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 1125-1134. Zhu J Y, Park T, Isola P, et al. Unpaired image-to-image translation using cycle-consistent adversarial networks[C]//Proceedings of the IEEE international conference on computer vision. 2017: 2223-2232. Choi Y, Choi M, Kim M, et al. Stargan: Unified generative adversarial networks for multi-domain image-to-image translation[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2018: 8789-8797. Mao X, Li Q, Xie H, et al. Least squares generative adversarial networks[C]//Proceedings of the IEEE international conference on computer vision. 2017: 2794-2802. Karras T, Aila T, Laine S, et al. Progressive growing of gans for improved quality, stability, and variation[J]. arXiv preprint arXiv:1710.10196, 2017. Chen X, Duan Y, Houthooft R, et al. Infogan: Interpretable representation learning by information maximizing generative adversarial nets[C]//Advances in neural information processing systems. 2016: 2172-2180. Zhang H, Goodfellow I, Metaxas D, et al. Self-attention generative adversarial networks[C]//International Conference on Machine Learning. 2019: 7354-7363.]]></content>
      <categories>
        <category>机器学习</category>
        <category>GAN</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1061 Dating]]></title>
    <url>%2Fposts%2F21107.html</url>
    <content type="text"><![CDATA[Sherlock Holmes received a note with some strange strings: Let's date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm. It took him only a minute to figure out that those strange strings are actually referring to the coded time Thursday 14:04 – since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter D, representing the 4th day in a week; the second common character is the 5th capital letter E, representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from A to N, respectively); and the English letter shared by the last two strings is s at the 4th position, representing the 4th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time. Input Specification:Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines. Output Specification:For each test case, print the decoded time in one line, in the format DAY HH:MM, where DAY is a 3-character abbreviation for the days in a week – that is, MON for Monday, TUE for Tuesday, WED for Wednesday, THU for Thursday, FRI for Friday, SAT for Saturday, and SUN for Sunday. It is guaranteed that the result is unique for each case. Sample Input:12343485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm Sample Output:1THU 14:04 浅析看懂了就是送分题…… 代码来自于柳神 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std;int main() { string a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; char t[2]; int pos, i = 0, j = 0; while(i &lt; a.length() &amp;&amp; i &lt; b.length()) { if (a[i] == b[i] &amp;&amp; (a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'G')) { t[0] = a[i]; break; } i++; } i = i + 1; while (i &lt; a.length() &amp;&amp; i &lt; b.length()) { if (a[i] == b[i] &amp;&amp; ((a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'N') || isdigit(a[i]))) { t[1] = a[i]; break; } i++; } while (j &lt; c.length() &amp;&amp; j &lt; d.length()) { if (c[j] == d[j] &amp;&amp; isalpha(c[j])) { pos = j; break; } j++; } string week[7] = {"MON ", "TUE ", "WED ", "THU ", "FRI ", "SAT ", "SUN "}; int m = isdigit(t[1]) ? t[1] - '0' : t[1] - 'A' + 10; cout &lt;&lt; week[t[0]-'A']; printf("%02d:%02d", m, pos); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1027 Colors in Mars]]></title>
    <url>%2Fposts%2F31924.html</url>
    <content type="text"><![CDATA[People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red, the middle 2 digits for Green, and the last 2 digits for Blue. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values. Input Specification:Each input file contains one test case which occupies a line containing the three decimal color values. Output Specification:For each test case you should output the Mars RGB value in the following format: first output #, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a 0 to its left. Sample Input 1:115 43 71 Sample Output 1:1#123456 浅析真・送分题。代码来自于柳神。 Code123456789101112#include &lt;cstdio&gt;using namespace std;int main() { char c[14] = {"0123456789ABC"}; printf("#"); for(int i = 0; i &lt; 3; i++) { int num; scanf("%d", &amp;num); printf("%c%c", c[num/13], c[num%13]); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1019 General Palindromic Number]]></title>
    <url>%2Fposts%2F12312.html</url>
    <content type="text"><![CDATA[A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N&gt;0 in base b≥2, where it is written in standard notation with k+1 digits a~i~ as ∑~i=0~^k^(a~i~b^i^). Here, as usual, 0≤a~i~&lt;b for all i and a~k~ is non-zero. Then N is palindromic if and only if a~i~=a~k−i~for all i*. Zero is written 0 in any base and is also palindromic by definition. Given any positive decimal integer N and a base b, you are supposed to tell if N is a palindromic number in base b. Input Specification:Each input file contains one test case. Each case consists of two positive numbers N and b, where 0&lt;N≤10^9^ is the decimal number and 2≤b≤10^9^ is the base. The numbers are separated by a space. Output Specification:For each test case, first print in one line Yes if N is a palindromic number in base b, or No if not. Then in the next line, print N as the number in base b in the form “a~k~ a~k−1~ … a~0~”. Notice that there must be no extra space at the end of output. Sample Input 1:127 2 Sample Output 1:12Yes1 1 0 1 1 Sample Input 2:1121 5 Sample Output 2:12No4 4 1 浅析进制转换 + 回文数，送分题。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ int n, p; cin&gt;&gt;n&gt;&gt;p; vector&lt;int&gt; v; do{ v.push_back(n%p); n /= p; } while (n != 0); bool flag = 1; for (int i = 0;i&lt;v.size()/2;i++) if(v[i]!=v[v.size()-1-i]){ flag = 0; break; } printf(flag ? "Yes\n" : "No\n"); for (int i = v.size() - 1; i &gt;= 0;i--){ printf("%d", v[i]); if(i!=0) printf(" "); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1031 Hello World for U]]></title>
    <url>%2Fposts%2F39931.html</url>
    <content type="text"><![CDATA[Given any string of N (≥5) characters, you are asked to form the characters into the shape of U. For example, helloworld can be printed as: 1234h de ll rlowo That is, the characters must be printed in the original order, starting top-down from the left vertical line with n1 characters, then left to right along the bottom line with n2 characters, and finally bottom-up along the vertical line with n3 characters. And more, we would like U to be as squared as possible – that is, it must be satisfied that n1=n3=max { k | k≤n2 for all 3≤n2≤N } with n1+n2+n3−2=N. Input Specification:Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space. Output Specification:For each test case, print the input string in the shape of U as specified in the description. Sample Input:1helloworld! Sample Output:1234h !e dl llowor 浅析送分题。代码来自于柳神，柳神🐂🍺！ Code12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int main() { char c[81], u[30][30]; memset(u, ' ', sizeof(u)); scanf("%s", c); int n = strlen(c) + 2; int n1 = n / 3, n2 = n / 3 + n % 3, index = 0; for(int i = 0; i &lt; n1; i++) u[i][0] = c[index++]; for(int i = 1; i &lt;= n2 - 2; i++) u[n1-1][i] = c[index++]; for(int i = n1 - 1; i &gt;= 0; i--) u[i][n2-1] = c[index++]; for(int i = 0; i &lt; n1; i++) { for(int j = 0; j &lt; n2; j++) printf("%c", u[i][j]); printf("\n"); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1036 Boys vs Girls]]></title>
    <url>%2Fposts%2F34220.html</url>
    <content type="text"><![CDATA[This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students. Input Specification:Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct. Output Specification:For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference grade**F−grade**M. If one such kind of student is missing, output Absent in the corresponding line, and output NA in the third line instead. Sample Input 1:12343Joe M Math990112 89Mike M CS991301 100Mary F EE990830 95 Sample Output 1:123Mary EE990830Joe Math9901126 Sample Input 2:121Jean M AA980920 60 Sample Output 2:123AbsentJean AA980920NA 浅析送分题。代码来自于柳神 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int main() { int n; scanf("%d", &amp;n); string female, male; int femalescore = -1, malescore = 101; for(int i = 0; i &lt; n; i++) { string name, sex, num; int score; cin &gt;&gt; name &gt;&gt; sex &gt;&gt; num; scanf("%d", &amp;score); if(sex == "F") { if(femalescore &lt; score) { femalescore = score; female = name + " " + num; } } else if(malescore &gt; score) { malescore = score; male = name + " " + num; } } if(femalescore != -1) cout &lt;&lt; female &lt;&lt; endl; else printf("Absent\n"); if(malescore != 101) cout &lt;&lt; male &lt;&lt; endl; else printf("Absent\n"); if(femalescore != -1 &amp;&amp; malescore != 101) printf("%d", femalescore - malescore); else printf("NA"); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1046 Shortest Distance]]></title>
    <url>%2Fposts%2F64131.html</url>
    <content type="text"><![CDATA[The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification:Each input file contains one test case. For each case, the first line contains an integer N (in [3,10^5^]), followed by N integer distances D~1~ D~2~ ⋯ D~N~, where D~i~ is the distance between the i-th and the (i+1)-st exits, and D~N~ is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤10^4^), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 10^7^. Output Specification:For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input:123455 1 2 4 14 931 32 54 1 Sample Output:1233107 浅析注意 dis 数组的使用，其表示从结点 1 顺时针到结点 n 的距离，如果只考虑了 sum，是会超时滴～ Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main(){ int n, sum = 0; cin &gt;&gt; n; vector&lt;int&gt; v(n+1); vector&lt;int&gt; dis(n + 1, 0); for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; v[i]; sum += v[i]; dis[i] = sum; } int k; cin &gt;&gt; k; while(k--){ int a1, a2; cin &gt;&gt; a1 &gt;&gt; a2; if(a1&gt;a2) swap(a1, a2); int temp = dis[a2-1] - dis[a1-1]; temp = min(temp,sum - temp); printf("%d\n", temp); }}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1042 Shuffling Machine]]></title>
    <url>%2Fposts%2F8248.html</url>
    <content type="text"><![CDATA[Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine. The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order: 12345S1, S2, ..., S13, H1, H2, ..., H13, C1, C2, ..., C13, D1, D2, ..., D13, J1, J2 where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification:For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input:12236 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output:1S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5 浅析注意可以直接根据编号来确定结点的标签 Code123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;char mp[5] = {'S', 'H', 'C', 'D', 'J'};vector&lt;int&gt; start(55),temp(55),result(55); //0位置留空int main(){ int k; cin &gt;&gt; k; for (int i = 1; i &lt; 55;i++){ start[i] = i; cin &gt;&gt; temp[i]; } for (int i = 0; i &lt; k; i++){ for (int j = 1; j &lt; 55;j++) result[temp[j]] = start[j]; start = result; } for (int i = 1; i &lt; 55;i++){ result[i]--; printf("%c%d", mp[result[i] / 13], result[i] % 13+1); if(i!=54) printf(" "); }}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1142 Maximal Clique]]></title>
    <url>%2Fposts%2F22100.html</url>
    <content type="text"><![CDATA[A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. A maximal clique is a clique that cannot be extended by including one more adjacent vertex. (Quoted from https://en.wikipedia.org/wiki/Clique_(graph_theory)) Now it is your job to judge if a given subset of vertices can form a maximal clique. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers Nv (≤ 200), the number of vertices in the graph, and Ne, the number of undirected edges. Then Ne lines follow, each gives a pair of vertices of an edge. The vertices are numbered from 1 to Nv. After the graph, there is another positive integer M (≤ 100). Then M lines of query follow, each first gives a positive number K (≤ Nv), then followed by a sequence of K distinct vertices. All the numbers in a line are separated by a space. Output Specification:For each of the M queries, print in a line Yes if the given subset of vertices can form a maximal clique; or if it is a clique but not a maximal clique, print Not Maximal; or if it is not a clique at all, print Not a Clique. Sample Input:1234567891011121314151617188 105 67 86 43 64 52 38 22 75 33 464 5 4 3 63 2 8 72 2 31 13 4 3 63 3 2 1 Sample Output:123456YesYesYesYesNot MaximalNot a Clique 浅析判断是否是 clique：给定顶点集合是否顶点两两之间都有边判断是否是 maximal clique：剩下的定点是否与给定的顶点集合中所有顶点相连 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool G[209][209] = {false};int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; while(m--){ int a1, a2; cin &gt;&gt; a1 &gt;&gt; a2; G[a1][a2] = G[a2][a1] = true; } int k; cin &gt;&gt; k; while(k--){ int ns; cin &gt;&gt; ns; vector&lt;int&gt; v(ns); bool in[209] = {false}; for (int i = 0; i &lt; ns;i++){ cin &gt;&gt; v[i]; in[v[i]]=true; } bool flag_c = false, flag_m = false; for (int i = 0; i &lt; ns;i++) for (int j = i + 1; j &lt; ns;j++) if(G[v[i]][v[j]]==false) flag_c = true; if(flag_c){ printf("Not a Clique\n"); continue; } for (int i = 1; i &lt; n+1;i++) if(in[i]==false){ int count = 0; for (int j = 0; j &lt; ns;j++) if(G[i][v[j]]) count++; if(count == ns){ flag_m = true; break; } } if(!flag_m) printf("Yes\n"); else printf("Not Maximal\n"); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1144 The Missing Number]]></title>
    <url>%2Fposts%2F2806.html</url>
    <content type="text"><![CDATA[Given N integers, you are supposed to find the smallest positive integer that is NOT in the given list. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10^5^). Then N integers are given in the next line, separated by spaces. All the numbers are in the range of int. Output Specification:Print in a line the smallest positive integer that is missing from the input list. Sample Input:12105 -25 9 6 1 3 4 2 5 17 Sample Output:17 浅析送分题 Code12345678910111213141516#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() { int n, a, num = 0; cin &gt;&gt; n; map&lt;int, int&gt; m; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a; m[a]++; } while(++num) if (m[num] == 0) break; cout &lt;&lt; num; return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1146 Topological Order]]></title>
    <url>%2Fposts%2F63733.html</url>
    <content type="text"><![CDATA[This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 1,000), the number of vertices in the graph, and M (≤ 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K (≤ 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space. Output Specification:Print in a line all the indices of queries which correspond to “NOT a topological order”. The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer. Sample Input:1234567891011121314156 81 21 35 25 42 32 63 46 451 5 2 3 6 45 1 2 6 3 45 1 2 3 6 45 2 1 6 3 41 2 3 4 5 6 Sample Output:13 4 浅析简单的拓扑排序判断 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; G[n+1]; vector&lt;int&gt; degree(n+1, 0); for (int i = 0;i&lt;m;i++){ int a1, a2; cin &gt;&gt; a1 &gt;&gt; a2; G[a1].push_back(a2); degree[a2]++; } int k; cin&gt;&gt;k; vector &lt;int&gt; result; for(int i=0;i&lt;k;i++){ vector&lt;int&gt; degree_c = degree; int flag = true; for (int j = 0; j &lt; n; j++){ int temp; cin &gt;&gt; temp; if(degree_c[temp]!=0) flag = false; for (int z = 0; z &lt; G[temp].size();z++) degree_c[G[temp][z]]--; } if(!flag) result.push_back(i); } for (int i = 0; i &lt; result.size();i++){ printf("%d",result[i]); if(i!=result.size()-1) printf(" "); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1147 Heaps]]></title>
    <url>%2Fposts%2F54912.html</url>
    <content type="text"><![CDATA[In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure)) Your job is to tell if a given complete binary tree is a heap. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 100), the number of trees to be tested; and N (1 &lt; N ≤ 1,000), the number of keys in each tree, respectively. Then M lines follow, each contains N distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree. Output Specification:For each given tree, print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all. Then in the next line print the tree’s postorder traversal sequence. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. Sample Input:12343 898 72 86 60 65 12 23 508 38 25 58 52 82 70 6010 28 15 12 34 9 8 56 Sample Output:123456Max Heap50 60 65 72 12 23 86 98Min Heap60 58 52 38 82 70 25 8Not Heap56 12 34 28 9 8 15 10 浅析送分题 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;int n, a[1009];void PostOrder(int index){ if(index&gt;n) return; PostOrder(index * 2); PostOrder(index * 2 + 1); printf("%d", a[index]); if(index!=1) printf(" "); else printf("\n");}int main(){ int k; cin &gt;&gt; k &gt;&gt; n; while(k--){ for (int i = 1; i &lt;= n;i++) cin &gt;&gt; a[i]; int f_min = 1, f_max = 1; for (int i = 2; i &lt;= n;i++){ if(a[i]&gt;a[i/2]) f_max = 0; if(a[i]&lt;a[i/2]) f_min = 0; } if(f_max) printf("Max Heap\n"); else if(f_min) printf("Min Heap\n"); else printf("Not Heap\n"); PostOrder(1); }}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1037 Magic Coupon]]></title>
    <url>%2Fposts%2F57351.html</url>
    <content type="text"><![CDATA[The magic shop in Mars is offering some magic coupons. Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product… but hey, magically, they have some coupons with negative N‘s! For example, given a set of coupons { 1 2 4 −1 }, and a set of product values { 7 6 −2 −3 } (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop. Each coupon and each product may be selected at most once. Your task is to get as much money back as possible. Input Specification:Each input file contains one test case. For each case, the first line contains the number of coupons N~C~, followed by a line with N~C~ coupon integers. Then the next line contains the number of products N~P~, followed by a line with N~P~ product values. Here 1≤N~C~,N~P~≤10^5^, and it is guaranteed that all the numbers will not exceed 2^30^. Output Specification:For each test case, simply print in a line the maximum amount of money you can get back. Sample Input:123441 2 4 -147 6 -2 -3 Sample Output:143 浅析送分题 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { int m, n, ans = 0, p = 0, q = 0; scanf("%d", &amp;m); int a1[m]; for(int i = 0; i &lt; m; i++) scanf("%d", &amp;a1[i]); scanf("%d", &amp;n); int a2[n]; for(int i = 0; i &lt; n; i++) scanf("%d", &amp;a2[i]); sort(a1,a1+m); sort(a2,a2+n); while(p &lt; m &amp;&amp; q &lt; n &amp;&amp; a1[p] &lt; 0 &amp;&amp; a2[q] &lt; 0) { ans += a1[p] * a2[q]; p++; q++; } p = m - 1, q = n - 1; while(p &gt;= 0 &amp;&amp; q &gt;= 0 &amp;&amp; a1[p] &gt; 0 &amp;&amp; a2[q] &gt; 0) { ans += a1[p] * a2[q]; p--; q--; } printf("%d", ans); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1041 Be Unique]]></title>
    <url>%2Fposts%2F40635.html</url>
    <content type="text"><![CDATA[Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1,10^4^]. The first one who bets on a unique number wins. For example, if there are 7 people betting on { 5 31 5 88 67 88 17 }, then the second one who bets on 31 wins. Input Specification:Each input file contains one test case. Each case contains a line which begins with a positive integer N (≤10^5^) and then followed by N bets. The numbers are separated by a space. Output Specification:For each test case, print the winning number in a line. If there is no winner, print None instead. Sample Input 1:17 5 31 5 88 67 88 17 Sample Output 1:131 Sample Input 2:15 888 666 666 888 888 Sample Output 2:1None 浅析送分题 Code12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int a[100001], m[100000];int main() { int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) { scanf("%d", &amp;a[i]); m[a[i]]++; } for(int i = 0; i &lt; n; i++) { if(m[a[i]] == 1) { printf("%d", a[i]); return 0; } } printf("None"); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1015 Reversible Primes]]></title>
    <url>%2Fposts%2F56964.html</url>
    <content type="text"><![CDATA[A reversible prime in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime. Now given any two positive integers N (&lt;10^5^) and D (1&lt;D≤10), you are supposed to tell if N is a reversible prime with radix D. Input Specification:The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N. Output Specification:For each test case, print in one line Yes if N is a reversible prime with radix D, or No if not. Sample Input:123473 1023 223 10-2 Sample Output:123YesYesNo 浅析送分题 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isprime(int n) { if(n &lt;= 1) return false; int sqr = int(sqrt(n * 1.0)); for(int i = 2; i &lt;= sqr; i++) { if(n % i == 0) return false; } return true;}bool isprime_reverse(int n,int d){ int len = 0, arr[100]; do{ arr[len++] = n % d; n = n / d; }while(n != 0); for(int i = 0; i &lt; len; i++) n = n * d + arr[i]; return isprime(n);}int main() { int n, d; while(scanf("%d", &amp;n) != EOF) { if(n &lt; 0) break; scanf("%d", &amp;d); if(isprime(n) == false) { printf("No\n"); continue; } if(isprime_reverse(n,d)) printf("Yes\n"); else printf("No\n"); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1013 Battle Over Cities]]></title>
    <url>%2Fposts%2F1980.html</url>
    <content type="text"><![CDATA[It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly. For example, if we have 3 cities and 2 highways connecting city1-city2 and city1-city3. Then if city1 is occupied by the enemy, we must have 1 highway repaired, that is the highway city2-city3. Input Specification:Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern. Output Specification:For each of the K cities, output in a line the number of highways need to be repaired if that city is lost. Sample Input:12343 2 31 21 31 2 3 Sample Output:123100 浅析送分题 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int G[1009][1009];bool vis[1009];int n;void dfs(int s) { vis[s] = true; for(int i = 1; i &lt;= n; i++) { if(vis[i] == false &amp;&amp; G[s][i] == 1) dfs(i); }}int main() { int m, k, a, b; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for(int i = 0; i &lt; m; i++) { scanf("%d%d", &amp;a, &amp;b); G[a][b] = G[b][a] = 1; } for(int i = 0; i &lt; k; i++) { fill(vis, vis + 1010, false); scanf("%d", &amp;a); int count = 0; vis[a] = true; for(int j = 1; j &lt;= n; j++) { if(vis[j] == false) { dfs(j); count++; } } printf("%d\n", count - 1); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1012 The Best Rank]]></title>
    <url>%2Fposts%2F18502.html</url>
    <content type="text"><![CDATA[To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algrbra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student. For example, The grades of C, M, E and A - Average of 4 students are given as the following: 12345StudentID C M E A310101 98 85 88 90310102 70 95 88 84310103 82 87 94 88310104 91 91 91 91 Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average. Input Specification:Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID. Output Specification:For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space. The priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority. If a student is not on the grading list, simply output N/A. Sample Input:1234567891011125 6310101 98 85 88310102 70 95 88310103 82 87 94310104 91 91 91310105 85 90 90310101310102310103310104310105999999 Sample Output:1234561 C1 M1 E1 A3 AN/A 浅析送分题 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{ int id; int score[4], rank[4];};int flag;bool cmp(node a,node b){ return a.score[flag] &gt; b.score[flag];}int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; node stu[2009]; bool ma[1000000]={false}; for (int i = 0; i &lt; n;i++){ cin &gt;&gt; stu[i].id &gt;&gt; stu[i].score[1] &gt;&gt; stu[i].score[2] &gt;&gt; stu[i].score[3]; ma[stu[i].id] = true; stu[i].score[0] = (stu[i].score[1] + stu[i].score[2] + stu[i].score[3]) / 3.0 + 0.5; } for (flag = 0; flag &lt; 4;flag++){ sort(stu, stu + n, cmp); stu[0].rank[flag] = 1; for (int j = 1; j &lt; n;j++){ if(stu[j].score[flag]==stu[j-1].score[flag]) stu[j].rank[flag] = stu[j-1].rank[flag]; else stu[j].rank[flag] = j+1; } } char c[5] = {"ACME"}; for (int i = 0; i &lt; m;i++){ int id,pos,r; cin &gt;&gt; id; if(ma[id]==false) printf("N/A\n"); else{ for (int j = 0; j &lt; n;j++) if(stu[j].id==id){ r = stu[j].rank[0]; pos = 0; for (int k = 1;k&lt;4;k++) if(stu[j].rank[k]&lt;r){ r = stu[j].rank[k]; pos = k; } printf("%d %c\n", r, c[pos]); } } } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1011 World Cup Betting]]></title>
    <url>%2Fposts%2F59894.html</url>
    <content type="text"><![CDATA[With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets. Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%. For example, 3 games’ odds are given as the following: 1234 W T L1.1 2.5 1.71.2 3.1 1.64.1 1.2 1.1 To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places). Input Specification:Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L. Output Specification:For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space. Sample Input:1231.1 2.5 1.71.2 3.1 1.64.1 1.2 1.1 Sample Output:1T T W 39.31 浅析送分题 Code12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main(){ char c[4] = {"WTL"}; double sum = 1; for (int i = 0; i &lt; 3;i++){ int max_i; double a, max_num = 0; for (int j = 0; j &lt; 3;j++){ cin &gt;&gt; a; if(a&gt;max_num){ max_i = j; max_num = a; } } printf("%c ", c[max_i]); sum *= max_num; } printf("%.2lf", (sum * 0.65 - 1) * 2); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1149 Dangerous Goods Packaging]]></title>
    <url>%2Fposts%2F26660.html</url>
    <content type="text"><![CDATA[When shipping goods with containers, we have to be careful not to pack some incompatible goods into the same container, or we might get ourselves in serious trouble. For example, oxidizing agent （氧化剂） must not be packed with flammable liquid （易燃液体）, or it can cause explosion. Now you are given a long list of incompatible goods, and several lists of goods to be shipped. You are supposed to tell if all the goods in a list can be packed into the same container. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: N (≤10^4^), the number of pairs of incompatible goods, and M (≤100), the number of lists of goods to be shipped. Then two blocks follow. The first block contains N pairs of incompatible goods, each pair occupies a line; and the second one contains M lists of goods to be shipped, each list occupies a line in the following format: 1K G[1] G[2] ... G[K] where K (≤1,000) is the number of goods and G[i]‘s are the IDs of the goods. To make it simple, each good is represented by a 5-digit ID number. All the numbers in a line are separated by spaces. Output Specification:For each shipping list, print in a line Yes if there are no incompatible goods in the list, or No if not. Sample Input:123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 Sample Output:123NoYesYes 浅析送分题 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;int main(){ map&lt;int, vector&lt;int&gt; &gt; m; int n1,n2; cin &gt;&gt; n1 &gt;&gt; n2; for (int i = 0; i &lt; n1;i++){ int a, b; cin &gt;&gt; a &gt;&gt; b; m[a].push_back(b); } for (int i = 0; i &lt; n2;i++){ int k; cin &gt;&gt; k; bool T[100000] = {false}; vector&lt;int&gt; v; for (int j = 0; j &lt; k;j++){ int pos; cin &gt;&gt; pos; T[pos] = true; v.push_back(pos); } bool flag=true; for (int j = 0; j &lt; v.size();j++) for (int z = 0; z &lt; m[v[j]].size();z++) if(T[m[v[j]][z]]==true) flag = false; if(flag) printf("Yes\n"); else printf("No\n"); }}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1150 Travelling Salesman Problem]]></title>
    <url>%2Fposts%2F20719.html</url>
    <content type="text"><![CDATA[The “travelling salesman problem” asks the following question: “Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?” It is an NP-hard problem in combinatorial optimization, important in operations research and theoretical computer science. (Quoted from “https://en.wikipedia.org/wiki/Travelling_salesman_problem".) In this problem, you are supposed to find, from a given list of cycles, the one that is the closest to the solution of a travelling salesman problem. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers N (2&lt;N≤200), the number of cities, and M, the number of edges in an undirected graph. Then M lines follow, each describes an edge in the format City1 City2 Dist, where the cities are numbered from 1 to N and the distance Dist is positive and is no more than 100. The next line gives a positive integer K which is the number of paths, followed by K lines of paths, each in the format: n C~1~ C~2~ … C~n~ where n is the number of cities in the list, and C~i~’s are the cities on a path. Output Specification:For each path, print in a line Path X: TotalDist (Description) where X is the index (starting from 1) of that path, TotalDist its total distance (if this distance does not exist, output NA instead), and Description is one of the following: TS simple cycle if it is a simple cycle that visits every city; TS cycle if it is a cycle that visits every city, but not a simple cycle; Not a TS cycle if it is NOT a cycle that visits every city. Finally print in a line Shortest Dist(X) = TotalDist where X is the index of the cycle that is the closest to the solution of a travelling salesman problem, and TotalDist is its total distance. It is guaranteed that such a solution is unique. Sample Input:123456789101112131415161718196 106 2 13 4 11 5 12 5 13 1 84 1 61 6 16 3 11 2 14 5 177 5 1 4 3 6 2 57 6 1 3 4 5 2 66 5 1 4 3 6 29 6 2 1 6 3 4 5 2 64 1 2 5 17 6 1 2 5 4 3 17 6 3 2 5 4 1 6 Sample Output:12345678Path 1: 11 (TS simple cycle)Path 2: 13 (TS simple cycle)Path 3: 10 (Not a TS cycle)Path 4: 8 (TS cycle)Path 5: 3 (Not a TS cycle)Path 6: 13 (Not a TS cycle)Path 7: NA (Not a TS cycle)Shortest Dist(4) = 8 浅析题目是真的简单，人是真的 zz…… 做这种题目一定要仔细仔细再仔细！ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;climits&gt;using namespace std;int G[209][209];int n, min_i, min_sum=INT_MAX;void judge(int num){ int k,sum=0; cin &gt;&gt; k; vector&lt;int&gt; v(k); set&lt;int&gt; s; for (int i = 0; i &lt; k;i++){ cin &gt;&gt; v[i]; s.insert(v[i]); } bool flag = true; for (int i = 0;i&lt;k-1;i++){ if(G[v[i]][v[i+1]]==0) flag = false; sum += G[v[i]][v[i + 1]]; } if(!flag){ printf("Path %d: NA (Not a TS cycle)\n", num); }else if (v[0]!=v[k-1]||s.size()!=n){ printf("Path %d: %d (Not a TS cycle)\n", num, sum); }else{ if(sum&lt;min_sum){ min_sum = sum; min_i = num; } if(k!=n+1) printf("Path %d: %d (TS cycle)\n", num, sum); else printf("Path %d: %d (TS simple cycle)\n", num, sum); }}int main(){ int m; cin&gt;&gt;n&gt;&gt;m; for (int i = 0; i &lt; m;i++){ int a1, a2, d; cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; d; G[a1][a2] = G[a2][a1] = d; } int k; cin &gt;&gt; k; for (int i = 1; i &lt;= k;i++) judge(i); printf("Shortest Dist(%d) = %d\n", min_i, min_sum); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1152 Google Recruitment]]></title>
    <url>%2Fposts%2F61603.html</url>
    <content type="text"><![CDATA[In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constant e. The person who could find this prime number could go to the next step in Google’s hiring process by visiting this website.The natural constant e is a well known transcendental number（超越数）. The first several digits are: e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… where the 10 digits in bold are the answer to Google’s question. Now you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number. Input Specification:Each input file contains one test case. Each case first gives in a line two positive integers: L (≤ 1,000) and K (&lt; 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line. Output Specification:For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output 404 instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number. Sample Input 1:1220 523654987725541023819 Sample Output 1:149877 Sample Input 2:1210 32468024680 Sample Output 2:1404 浅析送分题 Code123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isPrime(int n) { if (n == 0 || n == 1) //特判 return false; for (int i = 2; i * i &lt;= n; i++) if (n % i == 0) return false; return true;}int main() { int l, k; string s; cin &gt;&gt; l &gt;&gt; k &gt;&gt; s; for (int i = 0; i &lt;= l - k; i++) { string t = s.substr(i, k); int num = stoi(t); if (isPrime(num)) { printf("%s", t.c_str()); return 0; } } printf("404\n"); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1153 Decode Registration Card of PAT]]></title>
    <url>%2Fposts%2F16314.html</url>
    <content type="text"><![CDATA[A registration card number of PAT consists of 4 parts: the 1st letter represents the test level, namely, T for the top level, A for advance and B for basic;the 2nd - 4th digits are the test site number, ranged from 101 to 999;the 5th - 10th digits give the test date, in the form of yymmdd;finally the 11th - 13th digits are the testee’s number, ranged from 000 to 999.Now given a set of registration card numbers and the scores of the card owners, you are supposed to output the various statistics according to the given queries. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤104) and M (≤100), the numbers of cards and the queries, respectively. Then N lines follow, each gives a card number and the owner’s score (integer in [0,100]), separated by a space. After the info of testees, there are M lines, each gives a query in the format Type Term, where Type being 1 means to output all the testees on a given level, in non-increasing order of their scores. The corresponding Term will be the letter which specifies the level; Type being 2 means to output the total number of testees together with their total scores in a given site. The corresponding Term will then be the site number; Type being 3 means to output the total number of testees of every site for a given test date. The corresponding Term will then be the date, given in the same format as in the registration card. Output Specification:For each query, first print in a line Case #: input, where # is the index of the query case, starting from 1; and input is a copy of the corresponding input query. Then output as requested: for a type 1 query, the output format is the same as in input, that is, CardNumber Score. If there is a tie of the scores, output in increasing alphabetical order of their card numbers (uniqueness of the card numbers is guaranteed); for a type 2 query, output in the format Nt Ns where Nt is the total number of testees and Ns is their total score; for a type 3 query, output in the format Site Nt where Site is the site number and Nt is the total number of testees at Site. The output must be in non-increasing order of Nt‘s, or in increasing order of site numbers if there is a tie of Nt. If the result of a query is empty, simply print NA. Sample Input:123456789101112138 4B123180908127 99B102180908003 86A112180318002 98T107150310127 62A107180908108 100T123180908010 78B112160918035 88A107180908021 981 A2 1073 1809082 999 Sample Output:123456789101112Case 1: 1 AA107180908108 100A107180908021 98A112180318002 98Case 2: 2 1073 260Case 3: 3 180908107 2123 2102 1Case 4: 2 999NA 浅析重点关注第三类 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;struct student{ string id; int score;};bool cmp(student a,student b){ if(a.score!=b.score) return a.score&gt;b.score; else return a.id &lt; b.id;}int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;student&gt; v(n); for (int i = 0; i &lt; n;i++){ cin &gt;&gt; v[i].id &gt;&gt; v[i].score; } for (int i = 1; i &lt;= m;i++){ int num,cnt=0,sum=0; string s; cin &gt;&gt; num &gt;&gt; s; printf("Case %d: %d %s\n", i, num, s.c_str()); vector&lt;student&gt; temp; if(num==1){ for (int j = 0; j &lt; n;j++) if(v[j].id[0]==s[0]) temp.push_back(v[j]); }else if(num==2){ for(int j=0; j &lt; n;j++) if(s==v[j].id.substr(1,3)){ cnt++; sum+=v[j].score; } if(cnt!=0){ printf("%d %d\n", cnt, sum); continue; } }else if(num==3){ //重点看这里，柳神🐂🍺！！！ unordered_map&lt;string, int&gt; m; for (int j = 0; j &lt; n; j++) if (v[j].id.substr(4, 6) == s) m[v[j].id.substr(1, 3)]++; for (auto it : m) temp.push_back({it.first, it.second}); } sort(temp.begin(), temp.end(), cmp); if (((num == 1 || num == 3) &amp;&amp; temp.size() == 0) || (num == 2 &amp;&amp; cnt == 0)){ printf("NA\n"); continue; } for(int j = 0; j &lt; temp.size(); j++){ printf("%s %d\n", temp[j].id.c_str(), temp[j].score); } } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1065 A+B and C (64bit)]]></title>
    <url>%2Fposts%2F61020.html</url>
    <content type="text"><![CDATA[Given three integers A, B and C in [−2^63^,2^63^], you are supposed to tell whether A+B&gt;C. Input Specification:The first line of the input gives the positive number of test cases, T (≤10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces. Output Specification:For each test case, output in one line Case #X: true if A+B&gt;C, or Case #X: false otherwise, where X is the case number (starting from 1). Sample Input:123431 2 32 3 49223372036854775807 -9223372036854775808 0 Sample Output:123Case #1: falseCase #2: trueCase #3: false 浅析送分题 Code123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main() { int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) { long long a, b, c; scanf("%lld %lld %lld", &amp;a, &amp;b, &amp;c); long long sum = a + b; if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; sum &lt; 0) { printf("Case #%d: true\n", i + 1); } else if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum &gt;= 0){ printf("Case #%d: false\n", i + 1); } else if(sum &gt; c) { printf("Case #%d: true\n", i + 1); } else { printf("Case #%d: false\n", i + 1); } } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1006 Sign In and Sign Out]]></title>
    <url>%2Fposts%2F12253.html</url>
    <content type="text"><![CDATA[At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification:Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format: 1ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS, and ID_number is a string with no more than 15 characters. Output Specification:For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input:12343CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 Sample Output:1SC3021234 CS301133 浅析送分题 Code123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;climits&gt;using namespace std;int main(){ int n,min=INT_MAX,max=INT_MIN; string in, out; scanf("%d", &amp;n); for (int i = 0; i &lt; n;i++){ string a; int h1, m1, s1, h2, m2, s2; cin &gt;&gt; a; scanf("%d:%d:%d %d:%d:%d",&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2); int sum1 = h1 * 3600 + m1 * 60 + s1; int sum2 = h2 * 3600 + m2 * 60 + s2; if(sum1&lt;min){ min = sum1; in = a; } if(sum2&gt;max){ max = sum2; out = a; } } printf("%s %s",in.c_str(),out.c_str()); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1004 Counting Leaves]]></title>
    <url>%2Fposts%2F40441.html</url>
    <content type="text"><![CDATA[A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child. Input Specification:Each input file contains one test case. Each case starts with a line containing 0&lt;N&lt;100, the number of nodes in a tree, and M (&lt;N), the number of non-leaf nodes. Then M lines follow, each in the format: 1ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID‘s of its children. For the sake of simplicity, let us fix the root ID to be 01. The input ends with N being 0. That case must NOT be processed. Output Specification:For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output 0 1 in a line. Sample Input:122 101 1 02 Sample Output:10 1 浅析Q：问一棵树每一层有多少个叶子节点 此题与 A1094 极为类似，同样给出 DFS 和 BFS 两种方法。A1094 要求计算每一层结点数并寻找最大值，而本题要求输出每一层的叶子节点数，因此只需在 DFS 增加结点数处做改动。同时，因为要输出每一层的非叶子节点数，之前初始化节点数数组为 0 的方法不再适用，要维持一个最大深度变量。 CodeDFS1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 109;int num[maxn] = {0};vector&lt;int&gt; G[maxn];int max_depth = -1;void dfs(int s,int depth){ if(G[s].size()==0){ num[depth]++; max_depth = max(depth, max_depth); } for (int i = 0; i &lt; G[s].size();i++){ int v = G[s][i]; dfs(v, depth + 1); //这是一棵树，所以不需要vis数组 }}int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; for (int i = 0; i &lt; m;i++){ int u, k; cin &gt;&gt; u &gt;&gt; k; for (int j = 0; j &lt; k;j++){ int v; cin &gt;&gt; v; G[u].push_back(v); } } dfs(1, 0); for (int i = 0; i &lt;=max_depth; i++){ printf("%d", num[i]); if (i &lt; max_depth) printf(" "); } return 0;} BFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn=109;int level[maxn], num[maxn] = {0};int depth = 0;vector&lt;int&gt; G[maxn];queue&lt;int&gt; q;void bfs(){ q.push(1); level[1] = 0; while(!q.empty()){ int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size();i++){ int v = G[u][i]; level[v] = level[u] + 1; depth = max(level[v], depth); if(G[v].size()==0) num[level[v]]++; q.push(v); } }}int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; for (int i = 0; i &lt; m;i++){ int u, k; cin &gt;&gt; u &gt;&gt; k; for (int j = 0; j &lt; k;j++){ int v; cin &gt;&gt; v; G[u].push_back(v); } } if(G[1].size()==0) num[0] = 1; else num[0] = 0; bfs(); for (int i = 0; i &lt;=depth; i++){ printf("%d", num[i]); if (i &lt; depth) printf(" "); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1094 The Largest Generation]]></title>
    <url>%2Fposts%2F18029.html</url>
    <content type="text"><![CDATA[A family hierarchy is usually presented by a pedigree tree where all the nodes on the same level belong to the same generation. Your task is to find the generation with the largest population. Input Specification:Each input file contains one test case. Each case starts with two positive integers N (&lt;100) which is the total number of family members in the tree (and hence assume that all the members are numbered from 01 to N), and M (&lt;N) which is the number of family members who have children. Then M lines follow, each contains the information of a family member in the following format: 1ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a family member, K (&gt;0) is the number of his/her children, followed by a sequence of two-digit ID‘s of his/her children. For the sake of simplicity, let us fix the root ID to be 01. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the largest population number and the level of the corresponding generation. It is assumed that such a generation is unique, and the root level is defined to be 1. Sample Input:123456789101112131423 1321 1 2301 4 03 02 04 0503 3 06 07 0806 2 12 1313 1 2108 2 15 1602 2 09 1011 2 19 2017 1 2205 1 1107 1 1409 1 1710 1 18 Sample Output:19 4 浅析Q：找树中最宽的那一层 CodeDFS学习将层数放入递归函数参数这样的方法 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxn=109;int num[maxn] = {0}; //记录每一层的节点数vector&lt;int&gt; v[maxn];void dfs(int s,int level){ num[level]++; for (int i = 0; i &lt; v[s].size(); i++){ dfs(v[s][i], level + 1); }}int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i=0; i &lt; m;i++){ int a1, a2; cin &gt;&gt; a1 &gt;&gt; a2; for (int j = 0; j &lt; a2;j++){ int b1; cin &gt;&gt; b1; v[a1].push_back(b1); } } dfs(1, 1); int max_n=0, max_l=0; for (int i = 1;i &lt;=n; i++){ if(num[i]&gt;max_n){ max_n = num[i]; max_l = i; } } printf("%d %d\n",max_n,max_l); return 0;} BFS之前说 BFS 不知道入队的节点是哪一层，下面的方法完美打脸，感谢柳神！ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 109;int level[maxn]; //每个节点的层数int num[maxn]{0}; //每层的结点数vector&lt;int&gt; v[maxn];int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i=0; i &lt; m;i++){ int a1, a2; cin &gt;&gt; a1 &gt;&gt; a2; for (int j = 0; j &lt; a2;j++){ int b1; cin &gt;&gt; b1; v[a1].push_back(b1); } } queue&lt;int&gt; q; q.push(1); level[1] = 1; while(!q.empty()){ int s = q.front(); q.pop(); num[level[s]]++; for (int i = 0;i&lt;v[s].size();i++){ q.push(v[s][i]); level[v[s][i]] = level[s] + 1; } } int max_n=0, max_l=0; for (int i = 1;i &lt;=n; i++){ if(num[i]&gt;max_n){ max_n = num[i]; max_l = i; } } printf("%d %d\n",max_n,max_l); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1154 Vertex Coloring]]></title>
    <url>%2Fposts%2F62900.html</url>
    <content type="text"><![CDATA[A proper vertex coloring is a labeling of the graph’s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most k colors is called a (proper) k-coloring. Now you are supposed to tell if a given coloring is a proper k-coloring. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N and M (both no more than 10^4^), being the total numbers of vertices and edges, respectively. Then M lines follow, each describes an edge by giving the indices (from 0 to N−1) of the two ends of the edge. After the graph, a positive integer K (≤ 100) is given, which is the number of colorings you are supposed to check. Then K lines follow, each contains N colors which are represented by non-negative integers in the range of int. The i-th color is the color of the i-th vertex. Output Specification:For each coloring, print in a line k-coloring if it is a proper k-coloring for some positive k, or No if not. Sample Input:123456789101112131415161710 118 76 84 58 48 11 21 49 89 11 02 440 1 0 1 4 1 0 1 3 00 1 0 1 4 1 0 1 0 08 1 0 1 4 1 0 5 3 01 2 3 4 5 6 7 8 8 9 Sample Output:12344-coloringNo6-coloringNo 浅析Q：问图中是否每条边的两个顶点颜色不同 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;struct Node{ int u, v; Node(int _u,int _v):u(_u),v(_v){}};vector&lt;Node&gt; v;int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m;i++){ int u, ve; cin &gt;&gt; u &gt;&gt; ve; v.push_back(Node(u, ve)); } int k; cin&gt;&gt;k; for (int i = 0; i &lt; k;i++){ int a[10009]={0}; set&lt;int&gt; s; for (int j = 0; j &lt; n;j++){ cin &gt;&gt; a[j]; s.insert(a[j]); } bool flag = true; for (int j = 0; j &lt; m;j++) if(a[v[j].u]==a[v[j].v]){ flag = false; break; } if(flag) printf("%d-coloring\n", s.size()); else printf("No\n"); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1155 Heap Paths]]></title>
    <url>%2Fposts%2F31807.html</url>
    <content type="text"><![CDATA[In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure)) One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order. Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (1&lt;N≤1,000), the number of keys in the tree. Then the next line contains N distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree. Output Specification:For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree. Finally print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all. Sample Input 1:12898 72 86 60 65 12 23 50 Sample Output 1:1234598 86 2398 86 1298 72 6598 72 60 50Max Heap Sample Input 2:1288 38 25 58 52 82 70 60 Sample Output 2:123458 25 708 25 828 38 528 38 58 60Min Heap Sample Input 3:12810 28 15 12 34 9 8 56 Sample Output 1:1234510 15 810 15 910 28 3410 28 12 56Not Heap 浅析Q：打印从根节点到叶节点的路径 掌握在递归前后适用 Push 和 Pop 来维护路径的方法 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int num,A[1010];vector&lt;int&gt; v;void traverse(int a){ if(2*a&gt;num&amp;&amp;2*a+1&gt;num){ if(a&lt;=num){ //只有左节点递归过来的情况 for (int i = 0; i &lt; v.size();i++){ printf("%d", v[i]); if(i&lt;v.size()-1) printf(" "); else printf("\n"); } } } else{ v.push_back(A[2 * a + 1]); traverse(2 * a + 1); v.pop_back(); v.push_back(A[2 * a]); traverse(2 * a); v.pop_back(); }}int main(){ scanf("%d", &amp;num); for (int i = 0; i &lt; num;i++) scanf("%d", &amp;A[i + 1]); v.push_back(A[1]); traverse(1); int min = 1,max = 1; for (int i = 2; i &lt;= num;i++){ if(A[i/2]&gt;A[i]) min = 0; if(A[i/2]&lt;A[i]) max = 0; } if(min==1) printf("Min Heap"); else if(max==1) printf("Max Heap"); else printf("Not Heap"); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1057 Stack]]></title>
    <url>%2Fposts%2F36384.html</url>
    <content type="text"><![CDATA[Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian – return the median value of all the elements in the stack. With N elements, the median value is defined to be the (N/2)-th smallest element if N is even, or ((N+1)/2)-th if N is odd. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤10^5^). Then N lines follow, each contains a command in one of the following 3 formats: 123Push keyPopPeekMedian where key is a positive integer no more than 10^5^. Output Specification:For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead. Sample Input:12345678910111213141516171817PopPeekMedianPush 3PeekMedianPush 2PeekMedianPush 1PeekMedianPopPopPush 5Push 4PeekMedianPopPopPopPop Sample Output:123456789101112InvalidInvalid322124453Invalid 浅析Q：在普通栈的基础上加上查询中位数的功能。 普通栈用 stack 头文件可快速实现。考虑到数字比较多，中位数用哈希表实现，重写 Push 和 Pop 来实现出入栈的同时哈希表的维护。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;const int maxn = 100010;const int sqrN = 316;int table[maxn] = {0}; //哈希表int block[sqrN] = {0}; //哈希表每块元素的个数stack&lt;int&gt; st;void Push(int a){ st.push(a); table[a]++; block[a/sqrN]++;}void Pop(){ int a = st.top(); st.pop(); table[a]--; block[a/sqrN]--; printf("%d\n", a);}void PeekMedian(){ int k = st.size(); if(k%2 == 1) k = (k + 1) / 2; else k = k / 2; int sum = 0; int idx = 0; //找到中位数所在块号 while(sum+block[idx]&lt;k) sum += block[idx++]; int num = idx * sqrN; while(sum+table[num]&lt;k) sum += table[num++]; printf("%d\n", num);}int main(){ int x,query; scanf("%d", &amp;query); char cmd[15]; for (int i = 0; i &lt; query;i++){ scanf("%s", cmd); if(strcmp(cmd,"Push")==0){ scanf("%d", &amp;x); Push(x); } else{ if(st.empty()) printf("Invalid\n"); else{ if(strcmp(cmd,"Pop")==0) Pop(); else PeekMedian(); } } } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1030 Travel Plan]]></title>
    <url>%2Fposts%2F27719.html</url>
    <content type="text"><![CDATA[A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. Input Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: 1City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space. Output Specification:For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. Sample Input:1234564 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20 Sample Output:10 2 3 3 40 浅析与 A1003 Emergency 大同小异，不再赘述 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 510;const int INF = (1 &lt;&lt; 30) - 1;int n, G[maxn][maxn], cost[maxn][maxn];int pre[maxn],d[maxn],c[maxn];bool vis[maxn];void Dijkstra(int s,int t){ fill(vis, vis + maxn, false); fill(d, d + maxn, INF); fill(c, c + maxn, INF); for (int i = 0; i &lt; n;i++){ pre[i] = i; } c[s] = d[s] = 0; for (int i = 0; i &lt; n;i++){ int u = -1,min = INF; for (int j = 0; j &lt; n;j++) if(vis[j]==false&amp;&amp;d[j]&lt;min){ u = j; min = d[j]; } if(u==-1) return; vis[u] = true; if(vis[t]==true) return; for (int v = 0; v &lt; n;v++) if(vis[v]==false&amp;&amp;G[u][v]!=INF){ if(d[u]+G[u][v]&lt;d[v]){ d[v] = d[u]+G[u][v]; c[v] = c[u] + cost[u][v]; pre[v] = u; } else if(d[u]+G[u][v]==d[v]) if(c[u]+cost[u][v]&lt;c[v]){ c[v] = c[u]+cost[u][v]; pre[v] = u; } } }}void DFS(int v){ if(pre[v]==v){ printf("%d ", v); return; } DFS(pre[v]); printf("%d ", v); return;}int main(){ int m, s, t; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); fill(G[0], G[0] + maxn * maxn, INF); fill(cost[0], cost[0] + maxn * maxn, INF); for (int i = 0; i &lt; m;i++){ int a1, a2,b1,b2; scanf("%d%d%d%d", &amp;a1, &amp;a2, &amp;b1, &amp;b2); G[a1][a2] = G[a2][a1] = b1; cost[a1][a2] = cost[a2][a1] = b2; } Dijkstra(s, t); DFS(t); printf("%d %d\n", d[t], c[t]); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1003 Emergency]]></title>
    <url>%2Fposts%2F21141.html</url>
    <content type="text"><![CDATA[As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification:Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C~1~ and C~2~ - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c~1~, c~2~ and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C~1~ to C~2~. Output Specification:For each test case, print in one line two numbers: the number of different shortest paths between C~1~ and C~2~, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input:123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output:12 4 浅析Q：求最短路径，若有多条，输出点权最大者 感谢《算法笔记》，对 Dijkstra 这类问题的变形总结的很到位对于最短路径不止一条的各种情况，只需额外增加数组记录即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int INF = (1 &lt;&lt; 30) - 1;const int maxn = 510; //顶点数较少，可以使用邻接矩阵bool vis[maxn]; //是否已经找到最短路径int weight[maxn],d[maxn],w[maxn],num[maxn]; //顶点的点权，最短路径，路径最大权，最短路径条数int G[maxn][maxn];int n; //顶点数void Dijkstra(int s,int t){ fill(vis, vis + maxn, false); fill(d, d + maxn, INF); fill(w, w + maxn, 0); fill(num, num + maxn, 0); //注意初始化为0，非1，不要想当然 d[s] = 0; num[s] = 1; w[s] = weight[s]; for (int i = 0; i &lt; n;i++){ int u = -1, min = INF; for (int j = 0; j &lt; n;j++) if(vis[j]==false&amp;&amp;d[j]&lt;min){ u = j; min = d[j]; } if(u==-1) return; //不连通的情况 vis[u] = true; if (vis[t] == true) return; //已经找到顶点t的最短路径 for (int v = 0; v &lt; n;v++) if(vis[v]==false&amp;&amp;G[u][v]!=INF){ if(d[u]+G[u][v]&lt;d[v]){ d[v] = d[u] + G[u][v]; w[v] = w[u] + weight[v]; num[v] = num[u]; } else if(d[v]==d[u]+G[u][v]){ if(w[v]&lt;w[u]+weight[v]) w[v] = w[u] + weight[v]; num[v] += num[u]; } } }}int main(){ int m, s, t; //边数，源点，目标点 scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for (int i = 0; i &lt; n;i++) scanf("%d",&amp;weight[i]); fill(G[0], G[0] + maxn * maxn, INF); //这个初始化别忘了！！！ for (int i = 0; i &lt; m;i++){ int a1, a2, aw; scanf("%d%d%d",&amp;a1,&amp;a2,&amp;aw); G[a1][a2] = G[a2][a1] = aw; } Dijkstra(s, t); printf("%d %d", num[t], w[t]); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1076 Forwards on Weibo]]></title>
    <url>%2Fposts%2F1399.html</url>
    <content type="text"><![CDATA[Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤1000), the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format: 1M[i] user_list[i] where M[i] (≤100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space. Then finally a positive K is given, followed by K UserID‘s for query. Output Specification:For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted. Sample Input:1234567897 33 2 3 402 5 62 3 12 3 41 41 52 2 6 Sample Output:1245 浅析Q：在给定深度下，一个节点所能到达的其他节点数 一开始想用层数做为全局变量，但是 BFS 不知道何时到上一层的尾结点因此行不通。后改层数为每个节点各自的属性，源节点为 0，在遍历其邻接点时实现递增 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1010;int L;struct Node{ int id; int level; Node(int _id,int _level):id(_id),level(_level){}};vector&lt;Node&gt; G[maxn];int BFS(int s){ bool inq[maxn] = {false}; int num_share = 0; queue&lt;Node&gt; q; Node start = Node(s, 0); q.push(start); inq[start.id] = true; while(!q.empty()){ Node temp = q.front(); q.pop(); for (int i = 0; i &lt; G[temp.id].size();i++){ Node next = G[temp.id][i]; next.level = temp.level + 1; if(inq[next.id]==false&amp;&amp;next.level&lt;=L){ q.push(next); inq[next.id] = true; num_share++; } } } return num_share;}int main(){ int n; scanf("%d%d", &amp;n, &amp;L); for (int i = 0; i &lt; n;i++){ int m; scanf("%d", &amp;m); for (int j = 0; j &lt; m;j++){ int u; scanf("%d", &amp;u); G[u-1].push_back(Node(i, 0)); //巨坑！！题目的编号是从1开始的，因此要用u-1 } } int n_out; scanf("%d", &amp;n_out); for (int i = 0; i &lt; n_out;i++){ int s; scanf("%d", &amp;s); printf("%d\n", BFS(s-1)); //s-1同上 } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1034 Head of a Gang]]></title>
    <url>%2Fposts%2F22034.html</url>
    <content type="text"><![CDATA[题外话本题不推荐我的写法，一开始的时候没有做很好的构思，在实际操作过程中修修补补导致代码的可读性非常低。希望二刷的时候可以做进一步的改进。同学推荐晴神《算法笔记》的解题思路，有需要可自行查阅。 One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads. Input Specification:Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format: 1Name1 Name2 Time where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes. Output Specification:For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads. 浅析Q：找出联通子图，其结点数大于 2，边的总权值大于 k Sample Input 1:1234567898 59AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 1:1232AAA 3GGG 3 Sample Input 2:1234567898 70AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 2:10 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=2010;int G[maxn][maxn]={0}; //邻接矩阵表示图struct node{ int id; int weight = 0;}P[maxn]; //记录每个顶点的点权int num_person=0,num_group=0,weight; //num_person表示当前人数，num_group表示极大子图数，weight表示指定的权重bool vis[maxn]={false}; //用于深搜bool is_prime[maxn]={false}; //是否是符合要求的犯罪团体 vector &lt;node&gt; group[maxn]; //用于保存每个极大子图所包含的结点信息 map &lt;int,string&gt; i_to_s;map &lt;string,int&gt; s_to_i;int change(string s){ if(s_to_i.find(s)!=s_to_i.end()) return s_to_i[s]; else{ s_to_i[s] = num_person; i_to_s[num_person] = s; return num_person++; }}bool cmp(node a,node b){ return a.weight&gt;b.weight;}void DFS(int s){ vis[s] = true; group[num_group].push_back(P[s]); for(int i=0;i&lt;num_person;i++){ if(!vis[i]&amp;&amp;(G[s][i]||G[i][s])){ DFS(i); } }}//下面这堆玩意儿是最后补的，为的是按照名字字典序输出struct out{ string str; int num; out(string _str,int _num):str(_str),num(_num){}};vector &lt;out&gt; o;bool cmp_o(out a,out b){ return a.str&lt;b.str;}int main(){ int n; scanf("%d%d",&amp;n,&amp;weight); for(int i=0;i&lt;n;i++){ string s1,s2; int w,a,b; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;w; a = change(s1); b = change(s2); P[a].id = a; P[b].id = b; P[a].weight += w; P[b].weight += w; G[a][b] = w; } int num=0; for(int i=0;i&lt;num_person;i++){ if(vis[i]==false){ DFS(i); if(group[num_group].size()&gt;2){ int total_weight=0; for(int j=0;j&lt;group[num_group].size();j++) total_weight+=group[num_group][j].weight; if(total_weight&gt;2*weight){ num++; is_prime[num_group] = true; } } num_group++; } } printf("%d\n",num); for(int j=0;j&lt;num_person;j++) if(is_prime[j]){ sort(group[j].begin(),group[j].end(),cmp); int id = group[j][0].id; o.push_back(out(i_to_s[id],group[j].size()));// cout&lt;&lt;i_to_s[id]&lt;&lt;" "&lt;&lt;group[j].size()&lt;&lt;endl; } sort(o.begin(),o.end(),cmp_o); for(int j=0;j&lt;o.size();j++){ printf("%s %d\n",o[j].str.c_str(),o[j].num); }}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1043 Is It a Binary Search Tree]]></title>
    <url>%2Fposts%2F56200.html</url>
    <content type="text"><![CDATA[A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST. Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:1278 6 5 7 10 8 11 Sample Output 1:12YES5 7 6 8 11 10 8 Sample Input 2:1278 10 11 8 6 7 5 Sample Output 2:12YES11 8 10 7 5 6 8 Sample Input 3:1278 6 8 5 10 9 11 Sample Output 3:1NO 浅析Q：用给定序列构建二叉搜索树，判断其是否是二叉搜索树或者其镜像树前序遍历的结果。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;struct TNode{ int data; TNode *lchild, *rchild;};TNode* InsertNode(TNode* T,int data){ if(T == NULL){ TNode *p = new TNode; p-&gt;data = data; p-&gt;lchild = p-&gt;rchild = NULL; return p; } if(data &lt; T-&gt;data) T-&gt;lchild = InsertNode(T-&gt;lchild, data); else T-&gt;rchild = InsertNode(T-&gt;rchild, data); return T;}vector&lt;int&gt; origin, pre, prem, post, postm;void preorder(TNode *T){ if(T){ pre.push_back(T-&gt;data); preorder(T-&gt;lchild); preorder(T-&gt;rchild); }}void preorder_mirror(TNode *T){ if(T){ prem.push_back(T-&gt;data); preorder_mirror(T-&gt;rchild); preorder_mirror(T-&gt;lchild); } }void postorder(TNode *T){ if(T){ postorder(T-&gt;lchild); postorder(T-&gt;rchild); post.push_back(T-&gt;data); }}void postorder_mirror(TNode *T){ if(T){ postorder_mirror(T-&gt;rchild); postorder_mirror(T-&gt;lchild); postm.push_back(T-&gt;data); }}int main(){ int n,data; TNode *T=NULL; scanf("%d", &amp;n); for (int i = 0; i &lt; n;i++){ scanf("%d", &amp;data); origin.push_back(data); T=InsertNode(T, data); } preorder(T); preorder_mirror(T); if(origin==pre){ printf("YES\n"); postorder(T); for (int j = 0;j&lt;post.size();j++){ printf("%d", post[j]); if(j&lt;post.size()-1){ printf(" "); } } } else if(origin==prem){ printf("YES\n"); postorder_mirror(T); for (int j = 0;j&lt;postm.size();j++){ printf("%d", postm[j]); if(j&lt;postm.size()-1){ printf(" "); } } } else printf("NO\n"); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1053 Path of Equal Weight]]></title>
    <url>%2Fposts%2F56693.html</url>
    <content type="text"><![CDATA[Given a non-empty tree with root R, and with weight W~i~ assigned to each tree node T~i~. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L. Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure. Input Specification:Each input file contains one test case. Each case starts with a line containing 0&lt;N≤100, the number of nodes in a tree, M (&lt;N), the number of non-leaf nodes, and 0&lt;S&lt;2^30^, the given weight number. The next line contains N positive numbers where W~i~ (&lt;1000) corresponds to the tree node T~i~. Then M lines follow, each in the format: 1ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID‘s of its children. For the sake of simplicity, let us fix the root ID to be 00. Output Specification:For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line. Note: sequence {A~1~,A~2~,⋯,A~n~} is said to be greater than sequence {B~1~,B~2~,⋯,B~m~} if there exists 1≤k&lt;min{n,m} such that A~i~=B~i~ for i=1,⋯,k, and A~k+1~&gt;B~k+1~. Sample Input:123456789101120 9 2410 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 200 4 01 02 03 0402 1 0504 2 06 0703 3 11 12 1306 1 0907 2 08 1016 1 1513 3 14 16 1717 2 18 19 Sample Output:123410 5 2 710 4 1010 3 3 6 210 3 3 6 2 浅析Q：找出从根节点到叶子结点权值和等于给定值的所有路径，并从大到小输出。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node{ int weight; vector&lt;int&gt; child;} TNode[maxn];bool cmp(int a,int b){ return TNode[a].weight &gt; TNode[b].weight;}int n, m, weight; //起始输入的结点树，非叶子节点数，目标值int path[maxn];/*尝试用vector来构建path，但是个人能力局限，不能很好的进行push_back操作，有想法的可以自己改着试试*/void DFS(int index,int num_node,int sum){ if(sum&gt;weight) return; if(sum == weight){ if(TNode[index].child.size()!=0) return; for (int i = 0; i &lt; num_node; i++) { printf("%d",TNode[path[i]].weight); if(i&lt;num_node-1) printf(" "); else printf("\n"); } return; } for (int i = 0; i &lt; TNode[index].child.size();i++){ int child = TNode[index].child[i]; path[num_node] = child; DFS(child, num_node+1,sum + TNode[child].weight); }}int main(){ scanf("%d %d %d", &amp;n, &amp;m, &amp;weight); for (int i = 0; i &lt; n;i++) scanf("%d", &amp;TNode[i].weight); int father,k, child; for (int i = 0; i &lt; m;i++){ scanf("%d %d",&amp;father,&amp;k); for (int j = 0; j &lt; k;j++){ scanf("%d", &amp;child); TNode[father].child.push_back(child); } sort(TNode[father].child.begin(), TNode[father].child.end(), cmp); } path[0] = 0; DFS(0, 1, TNode[0].weight); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1020 Tree Traversals]]></title>
    <url>%2Fposts%2F45536.html</url>
    <content type="text"><![CDATA[Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input:12372 3 1 5 7 6 41 2 3 4 5 6 7 Sample Output:14 1 6 3 5 7 2 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int n;struct TNode{ int data; TNode *lchild; TNode *rchild;};TNode* create(int post[],int in[],int postL,int postR,int inL,int inR){ if(postL&gt;postR) return NULL; TNode *p = new TNode; p-&gt;data = post[postR]; int pos; for(pos=inL;in[pos]!=post[postR]&amp;&amp;pos&lt;=inR;pos++); int num = pos-inL; p -&gt; lchild = create(post,in,postL,postL+num-1,inL,pos-1); p -&gt; rchild = create(post,in,postL+num,postR-1,pos+1,inR); return p;}void level_order(TNode *T){ queue &lt;TNode*&gt; q; TNode *p; q.push(T); int num=0; while(!q.empty()){ p = q.front(); printf("%d",p-&gt;data); num++; if(num&lt;n) printf(" "); q.pop(); if(p-&gt;lchild != NULL) q.push(p-&gt;lchild); if(p-&gt;rchild != NULL) q.push(p-&gt;rchild); }}int main(){ TNode* T; scanf("%d", &amp;n); int post[n],in[n]; for(int i=0;i&lt;n;i++) scanf("%d", &amp;post[i]); for(int i=0;i&lt;n;i++) scanf("%d", &amp;in[i]); T = create(post,in,0,n-1,0,n-1); level_order(T); return 0; }]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1052 Linked List Sorting]]></title>
    <url>%2Fposts%2F2220.html</url>
    <content type="text"><![CDATA[A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification:Each input file contains one test case. For each case, the first line contains a positive N (&lt;10^5^) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1. Then N lines follow, each describes a node in the format: 1Address Key Next where Address is the address of the node in memory, Key is an integer in [−10^5^,10^5^], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification:For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input:1234565 0000111111 100 -100001 0 2222233333 100000 1111112345 -1 3333322222 1000 12345 Sample Output:1234565 1234512345 -1 0000100001 0 1111111111 100 2222222222 1000 3333333333 100000 -1 浅析静态链表的排序。把无效结点全部放后面去，然后有效节点根据数据大小排序。即 cmp 先比较一级 flag, 再比较二级 key。注意在结点排序过程中会改变结点在数组中的位置，因此不能用数组下标，每个节点需要保存自己的地址。注意链表的实际长度！！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN=100010;struct node{ int key, address, next; bool flag;} linknode[MAXN];bool cmp(node a,node b){ if(a.flag == false || b.flag == false) return a.flag &gt; b.flag; else return a.key &lt; b.key;}int main(){ int n, head; scanf("%d%d",&amp;n,&amp;head); //注意此处直接判断n是错的，坑！ //再实际输入的过程中，可能中间结点的next会等于-1 //即输入的链表其实是断的，所以链表的实际长度要另外统计 // if(!n){ // printf("0 -1\n"); // return 0; // } for (int i = 0; i &lt; MAXN;i++) linknode[i].flag = false; int address, next, key; for (int i = 0; i &lt; n;i++){ scanf("%d %d %d",&amp;address,&amp;key,&amp;next); linknode[address].address = address; linknode[address].key = key; linknode[address].next = next; // linknode[address].flag = true; } int count = 0, p; for (p = head; p != -1;p=linknode[p].next) { count++; linknode[p].flag = true; } if(count == 0){ printf("0 -1\n"); return 0; } sort(linknode, linknode + MAXN, cmp); for (int i = 0; i &lt; n-1;i++) linknode[i].next = linknode[i+1].address; linknode[n - 1].next = -1; printf("%d %05d\n", count, linknode[0].address); for (int i = 0;i&lt;count-1;i++) printf("%05d %d %05d\n", linknode[i].address, linknode[i].key, linknode[i].next); printf("%05d %d -1\n", linknode[count-1].address, linknode[count-1].key); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1032 Sharing]]></title>
    <url>%2Fposts%2F49549.html</url>
    <content type="text"><![CDATA[To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, loading and being are stored as showed in Figure 1.You are supposed to find the starting position of the common suffix (e.g. the position of i in Figure 1). Input Specification:Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N (≤10^5^), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format:Address Data Next whereAddress is the position of the node, Data is the letter contained by this node which is an English letter chosen from { a-z, A-Z }, and Next is the position of the next node. Output Specification:For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output -1 instead. Sample Input:1234567891011111 22222 967890 i 0000200010 a 1234500003 g -112345 D 6789000002 n 0000322222 B 2345611111 L 0000123456 e 6789000001 o 00010 Sample Output:167890 Sample Input 2:1234500001 00002 400001 a 1000110001 s -100002 a 1000210002 t -1 Sample Output 2:1-1 浅析观察题目所给的数据格式，不同于传统的找字串，实际上题目考察的是静态链表。又由于字串的特性，只需要找到第一个相同的地址即可。可以设置 flag 位，另链表 1 的 flag 全为 true, 若在链表 2 中能找到 flag 为 1 的结点，就是两者的子串。 Code123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;const int MAXN = 100010;struct Node{ //无需打印公共子串，因此不保存数据 int next; bool flag;} linknode[MAXN];int main(){ for (int i = 0; i &lt; MAXN;i++) linknode[i].flag = false; int s1, s2, n; scanf("%d%d%d",&amp;s1,&amp;s2,&amp;n); int address, next; for (int i = 0; i &lt; n;i++){ scanf("%d %*c %d", &amp;address, &amp;next); linknode[address].next = next; } int p; for (p = s1; p != -1;p=linknode[p].next) linknode[p].flag = true; for (p = s2; p != -1; p = linknode[p].next) if(linknode[p].flag == true) break; if(p!=-1) printf("%05d\n", p); else printf("-1\n"); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1060 Are They Equal]]></title>
    <url>%2Fposts%2F22570.html</url>
    <content type="text"><![CDATA[If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123×105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification:Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10^100^, and that its total digit number is less than 100. Output Specification:For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]...d[N]*10^k (d[1]&gt;0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding Sample Input:13 12300 12358.9 Sample Output:1YES 0.123*10^5 Sample Input 2:13 120 128 Sample Output 2:1NO 0.120*10^3 0.128*10^3 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n;string deal(string s,int&amp; e){ int i = 0; while(s.length()&gt;0&amp;&amp;s[0]=='0') s.erase(s.begin()); if(s[0]=='.'){ s.erase(s.begin()); while(s.length()&gt;0&amp;&amp;s[0]=='0'){ s.erase(s.begin()); e--; } }else{ while(i&lt;s.length()&amp;&amp;s[i]!='.'){ e++; i++; } if(s[i]=='.') s.erase(s.begin() + i); } if(s.length()==0) e=0; string res; for (int j = 0; j &lt; n;j++){ if(j&lt;s.length()) res += s[j]; else res += '0'; } return res;}int main(){ string s1, s2, s3, s4; int e1 = 0, e2 = 0; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; s3 = deal(s1, e1); s4 = deal(s2, e2); if(s3==s4&amp;&amp;e1==e2) cout &lt;&lt; "YES 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1&lt;&lt;endl; else cout &lt;&lt; "NO 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1 &lt;&lt; " 0." &lt;&lt; s4 &lt;&lt; "*10^" &lt;&lt; e2&lt;&lt;endl; return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A1069 The Black Hole of Numbers]]></title>
    <url>%2Fposts%2F63543.html</url>
    <content type="text"><![CDATA[For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number 6174 – the black hole of 4-digit numbers. This number is named Kaprekar Constant.For example, start from 6767, we’ll get: 1234567766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174... ... Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole. Input Specification:Each input file contains one test case which gives a positive integer N in the range (0,10^4^). Output Specification:If all the 4 digits of N are the same, print in one line the equation N - N = 0000. Else print each step of calculation in a line until 6174 comes out as the difference. All the numbers must be printed as 4-digit numbers. Sample Input:16767 Sample Output:12347766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174 Sample Input 2:12222 Sample Output 2:12222 - 2222 = 0000 Code123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 100010;const int MOD = 1000000007;int main(){ int i, j; char str[MAXN]; int left_P[MAXN] = {0}; int right_T[MAXN] = {0}; gets(str); int len = strlen(str); for (i=0,j=len-1;i&lt;len;i++,j--){ if(i&gt;0) left_P[i] = left_P[i - 1]; if(j&lt;len) right_T[j] = right_T[j + 1]; if(str[i]=='P') left_P[i]++; if(str[j]=='T') right_T[j]++; } int count = 0; for (i=0;i&lt;len;i++){ if(str[i]=='A') count = (count+left_P[i]*right_T[i])%MOD; } printf("%d\n", count); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A1093 Count PAT's]]></title>
    <url>%2Fposts%2F52785.html</url>
    <content type="text"><![CDATA[The string APPAPT contains two PAT’s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.Now given any string, you are supposed to tell the number of PAT’s contained in the string. Input Specification:Each input file contains one test case. For each case, there is only one line giving a string of no more than 10^5^ characters containing only P, A, or T Output Specification:For each test case, print in one line the number of PAT‘s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007. Sample Input:1APPAPT Sample Output:12 Code123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 100010;const int MOD = 1000000007;int main(){ int i, j; char str[MAXN]; int left_P[MAXN] = {0}; int right_T[MAXN] = {0}; gets(str); int len = strlen(str); for (i=0,j=len-1;i&lt;len;i++,j--){ if(i&gt;0) left_P[i] = left_P[i - 1]; if(j&lt;len) right_T[j] = right_T[j + 1]; if(str[i]=='P') left_P[i]++; if(str[j]=='T') right_T[j]++; } int count = 0; for (i=0;i&lt;len;i++){ if(str[i]=='A') count = (count+left_P[i]*right_T[i])%MOD; } printf("%d\n", count); return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A1025 Ranking]]></title>
    <url>%2Fposts%2F28997.html</url>
    <content type="text"><![CDATA[Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank. Input Specification:Each input file contains one test case. For each case, the first line contains a positive number N (≤100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (≤300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. Output Specification:For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:registration_number final_rank location_number local_rankThe locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. Sample Input:123456789101112251234567890001 951234567890005 1001234567890003 951234567890002 771234567890004 8541234567890013 651234567890011 251234567890014 1001234567890012 85 Sample Output:1234567891091234567890005 1 1 11234567890014 1 2 11234567890001 3 1 21234567890003 3 1 21234567890004 5 1 41234567890012 5 2 21234567890002 7 1 51234567890013 8 2 31234567890011 9 2 4 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct Student{ char id[15]; //学生id int score; //分数 int local_num; //考场号 int local_rank; //排名} stu[30010];bool cmp(Student a,Student b){ if(a.score != b.score) return a.score &gt; b.score; return strcmp(a.id, b.id) &lt; 0;}int main(){ int n,num=0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n;i++){ int k; scanf("%d", &amp;k); for (int j = 0; j &lt; k;j++){ scanf("%s %d", stu[num].id, &amp;stu[num].score); stu[num].local_num = i; num++; } sort(stu + num - k, stu + num, cmp); stu[num - k].local_rank = 1; for (int j = num-k+1; j &lt; num;j++){ if(stu[j].score != stu[j-1].score) stu[j].local_rank = j+1-(num-k); else stu[j].local_rank = stu[j - 1].local_rank; } } printf("%d\n", num); sort(stu, stu + num, cmp); int r = 1; for (int i = 0; i &lt; num;i++){ if(i&gt;0&amp;&amp;stu[i].score!=stu[i-1].score) r = i + 1; printf("%s ", stu[i].id); printf("%d %d %d\n", r, stu[i].local_num, stu[i].local_rank); } return 0;}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2Fposts%2F35589.html</url>
    <content type="text"><![CDATA[P 进制数 x 转换为 10 进制数 y123456789int P_to_y(int x,int p){ int y=0,product=1; while(x){ y += (x%10)*product; x = x/10; //去除个位数 product *= p; } return y;} 10 进制数 y 转换为 Q 进制数 z1234567void y_to_Q(int y,int Q,int z[]){ int z[40],int num=0; do{ z[num++] = y%Q; y = y/Q; }while(y);}]]></content>
      <categories>
        <category>algorithm</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考研政治总结]]></title>
    <url>%2Fposts%2F42426.html</url>
    <content type="text"><![CDATA[会议 &amp;&amp; 文献会议 中共一大：建党 中共二大：反帝反封建、群众路线 中共三大：与国名党党内合作 国名党一大：国共合作正式形成、新三民主义 中共四大：领导权、工农联盟 八七会议：右倾错误、土地革命 (转折)、没有起义！ 古田会议：思想建党、政治建军 三湾改编：党对军队的绝对领导 遵义会议：组织、军事 (转折) 瓦窑堡会议：统一战线 洛川会议：全民族抗战、抗日救国十大纲领 六届六中全会：马中化、确立革命道路 中共七大：确立毛泽东思想为党的指导思想、政治路线（作风：理论实际、自我批评、人民联系） 七届二中全会：工作重心乡村 -&gt; 城市、两个务必 (谦虚谨慎不骄不躁、作风：艰苦奋斗) 七届三中：不要四面出击、中心任务是争取国家财政经济状况基本好转 中共八大：社改基本完成后中国社会的主要矛盾和任务 ​ 根本任务：保护和发展生产力 ​ 陈云 “三个主体、三个补充” ​ 在综合平衡中稳步前进 八届九中全会：“调整、巩固、充实、提高” 十一届三中全会：改革开放 (转折） 十一届六中全会：《历史决议》评价毛泽东、活的灵魂：实、群、独、主要矛盾、社初 中共十二大：建设中国特色社会主义社会、邓小平理论的主题形成 中共十三大：社初党的基本路线、三步走、社会主义初级阶段理论、中国特色社会主义理论 中共十四大：社市经是经济体制改革的目标 中共十五大：基本经济制度：以公为主，多同发、邓小平理论、基本纲领 中共十六大：三个代表、全面建设小康社会 中共十七大：科学发展观、中国特色社会主义理论体系，和谐 中共十八大：全面小康决定新阶段、中国特色社会主义新时代 中共十九大：习近平新时代中特社思 文献大革命时期 《国名革命与农名运动》：农名问题是国民革命的中心问题 《中国社会各阶级的分析》：首要问题是分清敌友 《中国的红色政权为什么能够存在》《井冈山的斗争》：工农武装割据 《星星之火，可以燎原》：城市 -&gt; 农村、土地革命、游击战争 《反对本本主义》：没有调查就没有发言权 农村包围城市、武装夺取政权是毛泽东思想初步形成的标志 抗日战争时期 《论反对日本帝国主义的策略》：系统阐述抗日民族统一战线新政策、系统解决政治问题 《中国革命战争的战略问题》：总结土地革命时期的争论 《中国革命和中国共产党》：第一次提出新民主主义革命的科学概念和总路线的内容 《实践论》、《矛盾论》：主观主义尤其是教条主义、科学阐明了马克思主义思想路线 《论新阶段》：马克思主义中国化 《论持久战》：抗日分三个阶段、“兵民是胜利之本” 《战争和战略问题》：先占农村后占取城市作为革命道路确立 《共产党人发刊词》：三大法宝：武装斗争、统一战线、党的建设（伟大工程）、第一次马列和中结合 《新民主主义理论》：政治、经济、文化 《论联合政府》：把新民主主义政治经济文化同党联系起来 《改造我们的学习》、《整顿党的作风》、《反对党的八股》 新民主主义理论的系统阐述是毛泽东思想成熟的标志 解放战争时期 《在晋绥干部会议上的讲话》：新民主主义革命总路线的内容 《论人民民主专政》：共产党领导的以工农联盟为基础的… 《论十大关系》：开始探索社会主义的标志、“长共互监”、“百花百鸟” 《关于正确处理人民内部的矛盾》：两类不同性质的矛盾、” 统筹兼顾、适当安排 “、” 团结 - 批评 - 团结 “ 土地政策 《天朝田亩制度》：耕者有其田 孙中山民生主义：“平均地权”-&gt;+ 节制资本 《井冈山土地法》：首次肯定了农名以革命手段获得土地权利 《兴国土地法》：没收一切土地 -&gt; 没收一切公共土地和地主土地、限制富农、乡为单位，按人口平均分配 抗日战争时期：减租减息 解放战争时期：《五四指示》、《中国土地法大纲》、 不变动富农土地 新民主主义时期：《中华人名共和国土地改革法》、废除封建地主阶级封建剥削的土地所有制、保存富农经济 政策 《天朝田亩制度》 民生主义 《井冈山土地法》 《兴国土地法》 抗日战争时期 解放战争时期 新民主主义时期 耕者有其田 ✔ × × ✔ × ✔ ✔ 其他重要人物 林则徐：《四洲志》、睁眼看世界第一人 魏源：《海国图志》、“师夷长技以制夷” 郑观应：《盛世危言》、” 君民共主” 严复：《天演论》、“物竞天择”、《救亡决论》 章炳麟：《驳康有为革命书》、“启迪民智、陈旧布新” 邹容：《革命军》、“中华共和国” 陈天华：《警世钟》、《猛回头》 陈独秀：《青年杂志》 李大钊《庶民的胜利》、《我的马克思主义观》 邓小平：《解放思想，实事求是，团结一致向前看》 毛泽东： 《为抗日救国告全国同胞书》：团结起来、停止内战、一致抗日 《停战协议和一致抗日通电》：逼蒋抗日 易混淆词句第一 / 开端 / 起点 第一个不平等条约：《南京条约》 第一次大规模反侵略武装斗争：三元里抗英 第一个资本主义色 彩的方案：《资政新篇》 孙中山组织的第一个革命团体：兴中会 第一个领导资产阶级革命的全国性政党：同盟会 同盟会发动的第一次武装起义：萍浏醴起义 第一步具有资产阶级共和国宪法性质的法典：《中华民国临时约法》 共产主义小组领导的第一个工会：上海机器工会 第一次提出反帝反封建民主革命纲领：中共二大 第一个工人运动的高潮：香港海员罢工（起点）到京汉铁路工人罢工（顶点） 第一个农民协会：萧山县衙前村成立的农民协会 整风运动中第一重要的问题：学风问题 第一次提出新民主主义革命的科学概念与总路线：《中国革命与中国共地产党》 ​ （完整：《在晋绥干部会议上的讲话》） 科学技术是第一生产力 独立自主的和平外交政策第一位：国家主权和安全 推动发展的第一动力：创新 道德起源的第一个历史前提：劳动 中国共产党第一个开展自然科学教学与研究的专门机构：延安自然科学学院 全民族抗战后的第一次重大胜利：平型关大捷 政党第一位的属性：政治属性 无产阶级夺取政权的第一次伟大尝试：巴黎公社 对洋务事业第一次做出完整表述：冯桂芬 抗日战争的起点：1931 年九一八事变 探索社会主义的良好开端：《论十大关系》 核心 / 焦点 / 中心 / 首要 / 基本 / 根源 中国革命的首要问题：分清敌友 中国革命的首要对象：帝国主义 党建中摆在首位的：政治建设 人与自然相处时秉持的首要态度：尊重自然 人类社会赖以存在和发展的基础和一切活动的首要前提：物质活动及生产方式 整风运动中最主要的任务：反对主观主义 整风运动的重点：教条主义 抗日战争取得胜利的重要标志：台湾以及澎湖列岛由中国收回 中国特色社会主义的本质要求和重要保障：全面依法治国 抗日战争胜利的关键：中国共产党中流砥柱的作用 中国革命最基本的动力：无产阶级 中国革命的基本问题：农民问题 社会主义法律的基本属性、基本要求：平等 民主革命的基本内容：土地革命 集体主义的最高层次：无私奉献，一心为公 社会主义民主政治的本质和核心：人民当家作主 中国特色社会主义最本质的特征：党的领导 无产阶级领导权的中心问题：农民问题 中国革命的中心问题、新民主主义革命理论的核心问题：无产阶级的领导权 党思想路线的实质和核心：实事求是 习大大中国特色社会主义思想的核心要义：坚持和发展中特社会主义 政治上层建筑的核心：国家政权 社会再生产的核心：社会总产品的实现问题 加强党的作风建设的核心问题：保持党同人民群众的血肉联系 生态文明的核心：坚持人与自然和谐共生 合作共赢的新型国际关系的核心：维护联合国宪章的宗旨和原则 人类命运共同体的核心思想：建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界 人生观的核心：人生目的 社会主义道德建设的核心：为人民服务 资本主义社会失业现象产生的根源：资本积累 根本 反侵略战争失败的根本原因：社会制度腐败 辛亥革命失败的根本原因：资本主义的建国方案行不通 从根本上摧毁中国封建制度根基的社会大变革：土地制度改革 中国革命取得胜利 / 社会主义法制的根本保证：中国共产党的领导 社会发展的根本决定性因素：生产力 社会主义的根本任务：发展生产力 解决三农问题的根本途径：推动城乡发展一体化 发展的根本目的：增进民生福祉 国家富强、民族振兴根本出发点、落脚点：人民幸福 马克思主义政党的根本要求：旗帜鲜明讲政治 党的根本性建设：政治建设 人民军队区别于一切旧军队的根本优势：党对军队的绝对领导 个人和社会中最根本的关系：利益关系 中华传统美德的根本要求：公义胜私欲 物质的根本属性：运动 人类认识世界和改造世界的根本目标：认识必然，争取自由 马克思主义认识论的根本要求：一切从实际出发 社会发展的根本动力：社会基本矛盾 资本主义经济危机爆发的根本原因：社会基本矛盾 党的根本工作路线：群众路线 党区别于其他一切政党的根本标志：全心全意为人民服务 方针 农业改造的方针：积极领导、稳步前进、逐步过渡 抗日民族统一战线的方针：发展进步势力、争取中间势力、孤立顽固势力 中共八大经济建设方针：既反保守又反冒进，及在综合平衡中稳步前进 《论十大关系》基本方针：调动一切积极因素为社会主义服务 正确处理人民内部矛盾的总方针：用民主的方法 《关于正确处理人民内部的矛盾》： 政治思想领域和的民内部矛盾方针：团结 - 批评 - 团结 处理物质利益、分配方面的人民内部矛盾方针：统筹兼顾、适当安排 科学文化领域里的矛盾的方针：百花齐放、百鸟争鸣 处理共产党和民主党派的矛盾的方针：长期共存、互相监督 处理民族之间的方针：民族平等、团结互助 毛泽东三大外交方针：“另起炉灶”，“打扫干净物资再请客”，“一边倒” 原则 抗日民族统一战线原则：独立自主 同顽固派进行斗争的原则：有理有利有节 农业改造的原则：自愿互利、典型示范和国家帮助 人与自然相处的基本原则：顺应自然 处理民族问题的原则：维护祖国统一，反对民族分裂，坚持民族平等，民族团结，各民族共同繁荣 一带一路建设的原则：共商共建共享 社会主义道德建设的原则：集体主义 行政执法的基本原则：合法、合理、信赖保护、效率 宪法的基本原则：党的领导、人民主权、尊重和保障人权、社会主义法治、民主集中制 民法商法的原则：民事主体地位平等、自愿、公平、诚信、公序良俗、有利于节约资源和保护生态环境 行政法的原则：职权法定、程序法定、公正公开、有效监督 社会法的原则：公平和谐、国家适度干预 刑法的原则：罪行法定、法律面前人人平等、罪刑相适应 诉讼法的原则：当事人有平等的诉讼权利、根据自愿和合法的原则进行调解、公开审判、两审终审等民事诉讼的基本原则和制度 仲裁的原则：自愿、仲裁独立、一裁终局 现代法治的基本原则：法律权利与法律义务平等 易混淆核心词对应词 对应词 (唯物史观) 根本原因 / 根本动力 生产力 (马哲) 根本原因 矛盾、内因 出发点、落脚点、归宿、宗旨、目标 人 根本依据、最大的实际 国情 根本保证、领导核心 中国共产党 动力 改革、全面深化改革（第一动力是创新） 根本任务、第一要务 解放和发展生产力 根本立足点 独立自主、自力更生 前提 社会稳定 重要保障 依法治国 中国特色社会主义社会 中国特色社会主义 根本任务 解放和发展生产力 基本目标 共同富裕 根本原则 共同富裕 本质要求 共享 必由之路 改革开放 本质特征 党的领导 本质属性 社会和谐 根本目的 人民群众 中国革命 中国革命 首要问题 基本问题 中心问题 根本问题 分清敌友 农民问题 无产阶级的领导权 国家政权 中心问题 资产阶级民主革命 土地问题 国民革命 (大革命) 农民问题 新民主主义革命理论的核心问题 无产阶级的领导权问题 中国民主革命 中国民主革命 基本内容 主要形式 依托 土地革命 武装斗争 农村革命根据地建设 道路 时间 道路 -49 农村包围城市 49-56 互助合作 56- 中特道路 科学发展观 科学发展观 第一要义 核心立场 基本要求 根本方法 发展 以人为本 全面协调可持续 统筹兼顾 中国共产党的思想路线 中国共产党的思想路线 前提和基础 根本途径和方法 实质和核心 验证条件和目的 一切从实际出发 理论联系实际 实事求是 在实践中检验和发展真理 社会主义民主政治 社会主义民主政治 本质、核心 原则 根本保证 方向 人民当家作主 民主集中制 党的领导 社会主义道路 实现中华民族伟大复兴 实现中华民族伟大复兴 全面小康 战略目标、关键一步、引领性环节 全面深化改革 突破性、先导性、动力性环节 全面依法治国、从严治党 重要组成部分 民族区域自治制度 民族区域自治制度 核心 保障少数民族当家作主，管理本民族本地方事物的权利 原则 民族团结平等，各民族共同繁荣 培育践行核心价值观 培育和践行核心价值观 重要基础 重要途径 重要保障 重要氛围 教育引导 实践养成 健全制度 凝聚共识 社保体系 社保体系 基本要求 兜底线、织密网、建机制 奋斗目标 覆盖全民、城乡统筹、权责清晰、保障适度、可持续 基本方针 全覆盖、保基本、多层次、可持续 基本举措 坚持政府为主体，积极发挥市场作用 国家安全 国家安全 宗旨 根本 准则 人民安全 政治安全 国家利益至上 深化党和国家的机构改革 深化党和国家机构改革 统领 导向 着力点 加强党的全面领导 国家治理能力和治理体系现代化 推进党和国家机构职能优化 新发展理念 新发展理念 创新 协调 绿色 开放 共享 动力问题 不平衡问题 和谐问题 内外联动问题 社会公平正义 改革、发展、稳定 改革、发展、稳定的关系 强大动力 关键 前提 结合点 改革 发展 稳定 改善人民生活 党的建设 党的建设 主线 统领 根基 着力点 长期执政能力建设、先进性纯洁性 政治建设 鉴定的理想信念 全党积极性、主动性、创造性 生态文明 生态文明 首要态度 基本原则 重要责任 尊重自然 顺应自然 保护自然 民生 民生 最大的民生 民生之源 最基本的民生 就业 收入分配 公共安全 条约 名称 时间 国家 影响 《南京条约》 1842 中英 领土、领海、司法、关税 《虎门条约》 1843 中英 👆 《望厦条约》 1844 中美 👆 《黄埔条约》 1844 中法 👆 《马关条约》 1895 中日 租界港湾、瓜分狂潮、割让台澎 《辛丑条约》 1901 中 N 完全沦为半殖半封建 其他 英国占领香港 《南京条约》《北京条约》《展拓香港界址专条》 收回台澎 《开罗宣言》《波茨坦公告》《日本投降书》《中日联合声明》 杂 党最鲜明的品格：勇于自我革命，从严管党治党 思想路线的核心：实事求是 实体经济的核心：制造业 城镇化的核心：人 两岸关系的政治基础：” 九二共识 “（一个中国原则） 解决新常态的根本政策：创新 社会主义民主政治的本质与核心：人民当家作主 党建中的根本性建设：政治建设 党和人民取得的根本成就：中国特色社会主义 中国梦实现的根本指针：中国特色社会主义理论体系 中国梦实现的根本途径：中国特色社会主义道路 兴国之要：以经济建设为中心 立国之本：坚持四项基本原则 强国之路：改革开放 生命线幸福线：基本路线 决胜全面小康中放在首位的：防范化解重大风险 底线任务：精准脱贫 爱国主义的本质：坚持爱国爱党爱社会主义高度统一 中国社会主义民主政治的特有形式和独特优势：社会主义协商民主 生态文明的核心：人与自然和谐共生，理念是尊重顺应保护自然 文化强国的关键：增强全民族的文化创造活力 改革是社会主义发展的直接动力、阶级斗争是阶级社会发展的直接动力、社会主义革命是为了解放和发展生产力 社会主义民主政治的首要战略任务是：党的领导、人民当家作主、依法治国有机统一 和平共处五项原则：互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处 党的初心和使命：为中国人民谋幸福，为中华民族谋复兴 社会主义的根本原则：共同富裕、公有制为主体多种所有制经济共同发展 社会治理格局：共建共治共享 全球治理观、一带一路原则：共商共建共享 新型国际关系的内涵：合作共赢 全面开放是我国现代化建设不断取得成就的重要法宝，是实现国家繁荣富强的根本出路 持续发展的内在要求：协调 中国共产党的三大历史任务：现代化建设、祖国统一、世界和平共同发展 中国共产党的历史使命：四个伟大，小康，复兴 创新：引领发展的第一动力，牵动经济社会发展全局的牛鼻子 协调：持续健康发展的内在要求 绿色：永续发展的必要条件和人民对美好生活追求的重要体现 开放：国家繁荣富强的必由之路 总体国家安全观的根本：政治安全 背诵徐涛马原人与自然的关系两个前提，两个基础 适用：垃圾分类、北京世园会、沙漠治理、生态文明 1234自然界是人类社会存在的前提，是构成人类社会客观现实性的自然基础实践是使物质世界分化为自然界和人类社会的历史前提，是使自然界与人类社会统一起来的物质基础自然规律的存在限制着人类的物质活动，必须尊重自然，顺应自然，保护自然人可以在正确认识自然规律的基础之上，发挥主观能动性，合理的改造自然，同时改造自己，合理的调节 意识的能动性作用原理意识的能动作用：意识的能动作用是人所特有的认识和改造客观世界的能力 适用：结合人类改造客观世界的事例，谈谈意识的能动作用、只要是开动脑子去琢磨、思考、寻找、设计的情况都可以用 1234意识反应世界具有自觉性，意识活动具有目的性与计划性意识活动具有创造性，不仅反映事物的外部现象，而且可以反映事物的本质和规律意识具有指导实践改造客观世界的作用意识具有调控人的行为和生理活动的作用 对立统一规律对立统一规律：对立统一规律之所以是唯物辩证法的实质与核心，是因为其揭示了普遍联系的根本内容与变化发展的内在动力，从根本上回答了为什么会发展的问题 矛盾的同一性与斗争性的辩证关系原理 一分为二、求同存异、差异中谋求共识 1234矛盾是反映事物内部和事物之间对立统一关系的哲学范畴，对立和同一分别反映了矛盾的两种基本属性，对立性又称斗争性，统一性又称同一性矛盾的同一性：矛盾双方相互依存相互贯通的的性质和趋势矛盾的斗争性：矛盾的对立面之间相互排斥相互分离的性质和趋势矛盾的同一性与斗争性相互连结，相辅相成。 没有同一就没有斗争，没有斗争也没有同一 斗争性寓于同一性之中，同一性通过斗争性来体现 斗争性是无条件绝对的，同一性是有条件相对的 矛盾的同一性与斗争性在事物发展中的作用性原理 逆向思考、反向思维 同一性在事物发展中的作用 123第一，同一性是事物存在与发展的前提，由于矛盾双方相互依存，因此矛盾双方可以通过的对方的发展来使自己得到发展第二，矛盾双方可以相互吸收有利于自身的因素得到发展第三，矛盾的同一性规定了发展的趋势，因此矛盾双方彼此相通，矛盾双方可以通过朝着自己的对立面转化而得到发展 斗争性在事物发展中的作用 12第一，矛盾双方的斗争促进双方力量的变化，此消彼长，为事物的质变创造必要条件第二，矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过度的决定性力量 矛盾的普遍性与特殊性的辩证关系 具体问题具体分析、对症下药、举一反三、量体裁衣、马克思主义中国化、因材施教 123矛盾的普遍性：矛盾无时不有，无处不在矛盾的特殊性：矛盾及矛盾的每一个方面都各有其特点矛盾的普遍性即共性，矛盾的特殊性即个性 共性是无条件绝对的，个性是有条件相对的 共性寓于个性之中，没有离开共性的个性，也没有离开个性的共性 矛盾的不平衡发展原理 两点论与重点论相结合 1234主要矛盾是矛盾体系中处于支配地位，对事物性质起决定作用的矛盾次要矛盾是矛盾体系中处于从属地位，对事物性质起次要作用的矛盾在每一对矛盾中又分矛盾的主要方面与次要方面事物的性质是由主要矛盾的主要方面决定的 实践与认识的关系1234实践是认识的来源实践是认识发展的动力：实践的需要推动认识的发展，推动人类的科学发现和技术进步实践是认识的目的实践是检验认识真理性的唯一标准 感性认识与理性认识的辩证关系1234567891011感性认识的概念:感性认识是认识的初级阶段，是在实践的基础上，由人们感官所直接感受到的事物的表象，外部联系理性认识的概念:理性认识是认识的高级阶段，是人们借助抽象思维，在概括整理大量的感性认识材料的基础上，对事物的本质与内在联系的认识两者相互区别： 对象不同：感性认识是对事物外部联系的反映，理性认识是对事物内部联系的反映 形式不同：感性认识包括感觉、知觉和表象三种形式，理性认识包括概念、推理和判断三种形式 特点不同：感性认识是直接的、具体的，理性认识是间接的、抽象的两者相互联系： 感性认识有待发展为理性认识。理性认识依赖于感性认识。在实际的认识过程中，感性认识与理性认识是相互交织相互渗透的，感性中包含着理性的因素，理性中也有感性的因素。从感性认识到理性认识的飞跃，必须具备两个条件：一是勇于实践，深入调查，获取丰富的符合实际的感性材料。而是必须通过理性思考的作用，运用理性思维和科学抽象，将丰富的感性材料去粗取精，去伪存真，由表及里，由此及彼的加工制作 认识的规律1234567认识过程的反复性 认识过程的反复性，表现为人们对一个复杂事物的认知要经过感性认识到理性认识，理性认识到实践多次反复才能完成 从客观上表现为事物的各个侧面及其本质的暴露是一个过程 从主观上表现为人认识能力的提高认识过程的无限性 对于事物的发展过程来说，人的认识是永无止境的，其表现为"认识-实践-再认识-再实践"循环往复 形式上循环往复，本质上前进上升 真理与谬误的辩证关系1234567真理与谬误的概念 真理是人们对于客观事物及其发展规律的正确反映 谬误是人们对于客观事物及其发展规律的歪曲反映真理与谬误的辩证关系 区别：真理与谬误的区分在于认识是否如实的反映了客观事物 联系：真理和谬误又是统一的，他们可以相互转化。真理与谬误在一定的条件下是绝对对立的，超出了这个范围，谬误可以变成真理，真理也能变成谬误 万能模板适用：如何对待 / 理解 / 处理的启示类问题 1我们应该用联系的、发展的、全面的观点看待问题，学习和运用矛盾分析法，坚持两点论和重点论的统一，透过现象看本质，在把握事物规律性的基础上充分发挥人的主观能动性，不断创新，把握机遇，善于从偶然中发现必然。同时还要注重实践，坚持一切从实际出发，实事求是，在实践中坚持和发展真理。不断推动认识的深化发展，将改造主观世界与改造客观世界相结合，做到认识和实践历史的、具体的统一。 政经 &amp;&amp; 科社12345678使用价值是商品的自然属性，价值是商品的社会属性解决商品经济中所有的矛盾（使用价值与价值、个人劳动与私人劳动、商品与货币）的关键是交换政治经济学是用来揭示资本主义的剥削实质的，所以政治经济学中所有的概念都是人与人之间的关系（资本主义以前：人与人之间的经济关系，资本主义以后：人与人之间的剥削关系）资本主义生产过程是劳动过程和价值增值过程的统一剩余价值率m'=m/v=剩余劳动/必要劳动=剩余劳动时间/必要劳动时间社会再生产的核心问题是社会总产品的实现问题，即社会总产品的价值补偿和实物补偿问题平均利润是不同部门间资本家竞争的结果；而超额利润是同一部门内，不同企业之间竞争的结果。垄断价格 = 生产成本 + 平均利润 + 垄断利润 毛中特创新 为什么要创新 12发展动力决定发展速度、效能和可持续性坚持创新发展，是实现增强发展动力、应对发展环境变化、把握发展主动权的根本之策，是引领发展的第一动力 创新的要求 1坚持创新发展，就是要坚持把创新摆在国家发展全局的核心位置，不断推进理论创新、制度创新、科技创新、文化创新 创新的举措 123456科教兴国、人才强国、创新驱动发展战略瞄准世界科技前沿，加强基础研究、应用基础研究和战略科技力量加强国家创新体系建设，强化战略科技力量，推动科技创新和经济社会发展深度融合培养一系列具有国际水平的战略科技人才、科技领军人才、青年科技人才和高水平创新团队建立企业为主体、市场为导向，产学研深度融合的技术创新体系强化知识产权保护，提升大众创业、万众创新 建设现代化经济体系123456大力发展实体经济，实体经济是我国的立身之本，是现代化经济体系的坚实基础实施创新驱动发展战略，是现代化经济体系的战略支持，深入实施科教兴国人才强国，创新驱动发展战略乡村振兴战略，是现代化经济体系的的重要基础推动城乡区域协调发展，优化现代化经济体系的空间布局发展开放型经济，提高现代化经济体系的国际竞争力深化经济体制改革，完善现代化经济体系的制度保障 高质量发展必要性1234适应新经济发展新常态的主动选择贯彻新发展战略的根本体现社会主要矛盾变化的必然要求建设现代化经济体系的必由之路 措施12345把握整体推进和重点突破的关系 把握总体谋划和久久为功的关系 既要三大攻坚战，又要大力转变经济发展方式、优化经济结构把握破除旧动能和培育新动能的关系 发展动力决定..供给侧结构性改革把握生态保护和经济发展的关系 不是矛盾对立，而是辩证统一把握维护正义和讲求效率的关系 做大蛋糕和分好蛋糕 乡村振兴战略必要性12全面建成小康社会，最艰巨最繁重的任务在农村，最广泛和最深厚的基础在农村，最大的潜力和后劲也在农村实施乡村振兴战略，是解决我国社会主要矛盾、实现两个一百年计划、实现中华民族伟大复兴的必然要求 意义12345实施乡村振兴战略是建设现代化经济体系的重要基础实施乡村振兴战略是建设美丽中国的关键举措实施乡村振兴战略是传承中华传统文化的有效途径实施乡村振兴战略是健全现代治理格局的固本之策实施乡村振兴战略是实现全体人民共同富裕的必然要求 措施12345坚持走中国特色社会主义乡村振兴之路，巩固和完善农村经营制度，深化农村土地改革，完善承包地三权分置制度保持承包地关系长久不变，在第二轮土地承包到期后在延长三十年深化集体产权制度改革完善现代农业产业体系、生产体系、经营体系，完善农业社会化服务体系促进农村一二三产业融合，健全自治、法治和德治相结合的农村治理体系 政府和市场的关系作用123深化经济体制改革是全面深化改革的重点，其核心问题是处理好政府和市场的关系，使市场在资源配置中起决定性作用和更好的发挥政府的作用市场的作用：市场配置资源是最有效率的形式政府的作用：保持宏观经济稳定、保障公平竞争、规范市场行为、促进共同富裕、维护市场秩序、推动可持续发展，弥补市场失灵 举措12发挥市场在资源配置中的决定性作用，完善市场机制，打破行业垄断、进入壁垒、区域保护，增强企业对市场需求变化的反映和调整能力，提高企业资源要素配置的效率和竞争力发挥政府的调节作用，用改革激发市场活力，用政策引导市场预期，用规划明确投资方向，用法治规范市场行为 社会主义协商民主是什么1社会主义协商民主，是在中国共产党的领导下，人民内部各方面就改革发展稳定的重要问题和关系人民群众利益的实际问题，在决策前和决策进行中，进行民主协商，努力达成共识的民主形式 重要性12社会主义协商民主是中国特色社会主义民主政治的特有形式和独特优势，是实现党的领导的重要方式丰富了民主的形式，拓展了民主的渠道，丰富了民主的内涵 意义顺口溜：党联系公民来决策，促进和谐发挥优越性 123456有利于扩大公民的有序政治参与，更好的实现人民当家作主有利于科学民主决策，促进我国治理体系与能力现代化有利于化解矛盾冲突，促进社会和谐稳定有利于保持党和人民群众的血肉联系，巩固和扩大党的执政基础有利于发挥我国政治制度的优越性，加强中国特色社会主义道路道路自信、制度自信、文化自信、理论自信有利于进一步改善党的领导方式和工作作风 措施顺口溜：两人（人大、人民团体）拿三证（政府、政党、政协）去找基层 1发展社会主义协商民主，必须推进协商民主广泛、多层、制度化的发展，统筹推进政府协商、政协协商、人大协商、人民团体协商、基层协商、社会组织协商、政党协商。加强协商民主建设，形成完整的制度程序和参与实践，保障人民群众在日常政治生活中有广泛持续深入参与的权利。 对外开放重要性12对外开放是我国的基本国策，以开放促改革、促发展，是我国现代化建设不断取得新成就的重要法宝对外开放是我国实现繁荣富强的根本出路 措施顺口溜：公主面包双赢 123456主动开放双向开放，引进来和走出去相结合全面开放，推进陆海内外联动，东西双向互济的开放格局公平开放，构建公平竞争的内外资发展环境共赢开放，推动经济全球化朝着普惠共赢方向发展包容开放，推进求同存异、包容共生 文化自信123文化自信源自于中国优秀传统文化所蕴含的强大文化基因。中华民族有着深厚的文化传统，形成了富有特色的思想文化体系，体现了中国人民几千年来的知识智慧和理性思辨。这是中华民族特有的优势中华文化走出去，从踏上国际舞台、展现亮点，到初具规模，产生影响，体现了中华文化的独特视角。走出去的中华文化，有利于让世界认识和理解一个历史悠久、发展迅速的现代中国。坚持文化自信，才能彰显文化强国的感召力，才能不断的融入世界。只有对自己的文化有自信，才能获得坚守的从容，鼓起奋发进取的勇气，焕发创新创造的活力。文化立世，文化兴邦。大力推进中华文化走出去，才能为我国外交、经济和影响力的扩展提供更为安全的软保护，提供更为有利的软环境，为我们的强国自信提供更为基础更深沉更持久的力量。 全面脱贫是什么怎么做1234567我国总体上已基本实现了全面建设小康社会的目标，但还有一些短板，最大的短板就是脱贫攻坚。第一，强化责任落实，脱贫攻坚是全面建成小康社会必须完成的硬任务第二，攻克坚中之坚第三，认真整改问题第四，提高脱贫质量第五，稳定脱贫攻坚政策第六，切实改进作风 八个明确12345678明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族的伟大复兴明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分发展之间的矛盾明确中国特色社会主义事业的总体布局是五位一体，战略布局是四个全面明确全面深化改革的总目标完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化明确全面推进依法治国的总目标是建设中国特色社会主义法治体系明确当在新时代的强军目标是建设一支听党智慧、能打胜仗、作风优良的军队明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体明确中国特色社会主义最本质的特征是党的领导，中国特色社会主义制度的最大优势是党的领导 十四个坚持1234567891011121314党的领导：坚持党对一切工作的领导。人民：坚持以人民为中心改革：坚持全面深化改革新理念:坚持新发展理念政治：坚持人民当家作主法治：坚持全面依法治国文化：坚持社会主义核心价值体系社会：坚持在发展中保障和改善民生生态：坚持人与自然和谐共生安全：坚持总体国家安全观国防军队：坚持党对人民军队的绝对领导一国两制：坚持”一国两制“和推进祖国统一外交：坚持构建人类命运共同体党建：坚持全面从严治党 近代史五四运动的意义1234五四运动是一场以先进知识分子为先锋、广大人民群众参与的彻底的反帝反封建的伟大爱国运动；是一场中国人民为拯救民族危亡、捍卫民族尊严、凝聚民族力量而掀起的伟大社会革命运动，是一场传播新思想新文化的伟大思想启蒙运动和新文化运动第一，五四运动以全民族的力量高举爱国主义伟大旗帜。五四运动，孕育了爱国进步民主科学的伟大五四精神，其核心是爱国主义精神。爱国主义是民族精神的核心，是中华民族奋斗、自强不息的精神纽带第二，以全民族的行动激发了追求真理、追求进步的伟大觉醒第三，以全民族的搏击培育了永久奋斗的伟大传统 新中国成立的意义中华人民共和国的成立，宣告中国人民当家作主的时代已经到来，中国历史由此开辟了一个新纪元 12345帝国主义压迫中国、奴役中国人民的历史就此结束本国封建主义、官僚资本主义统治的历史就此结束军阀割据、战乱频仍、匪患不断的历史就此结束从根本上改变了中国社会发展的方向，为新民主主义社会向社会主义社会的过度创造了条件中国共产党成为全国范围内的政党 不忘初心，牢记使命123中国共产党人的初心和使命就是为中国人民谋幸福，为中华民族谋复兴中国共产党带领人民夺取了新民主主义革命的最终胜利、完成了社会主义改造，消灭了剥削，建设了社会主义制度、摸索出了自己的社会主义建设道路，实行了改革开放，并不断努力，推动中国特色社会主义进入了新时代中国共产党的领导是中国特色社会主义最本质的特征，是中国特色社会主义制度最大的优势。在未来的征途中，只有牢记初心使命，勇于推进自我革命，我们党才能成为中国人民和中华民族的主心骨，才能成为复兴征程上的坚强领导核心 党带领人民做的三件大事12我们党深刻认识到，实现中华民族的伟大复兴，必须推翻压在人民头顶的帝国主义、封建主义、官僚主义三座大山，实现民族独立，人民解放，国家统一，社会和谐。我们党团结带领人民摸索出了一条农村包围城市，武装夺取政权的正确革命道路，完成了新民主主义革命，建立了新中国，实现了中国从封建专制到人民民主的伟大飞跃 12我们党深刻认识到，实现中华民族的伟大复兴，必须建立符合我国实际的社会主义制度我们党团结带领人民完成社会主义革命，建立基本社会主义制度，推动社会主义制度建设，完成了了中华民族有史以来最为广泛而深刻的社会变革，为当代中国的进一步发展奠定了根本政治前提和制度保障，实现了中华民族由近代不断衰弱到根本扭转命运、持续走向繁荣的伟大飞跃。 12我们党深刻认识到，实现中华民族伟大复兴，必须合乎时代潮流，顺应人民意愿，坚持改革开放，保持党同人民群众的血肉联系我们党团结带领人民完成了改革开放的伟大革命，破除阻碍国家发展的一切思想和体制阻碍，开辟了中国特色社会主义道路，中国特色社会主义从此进入了一个新时代。改革开放是党和人民大踏步赶上时代的重要法宝，是坚持和发展中国特色社会主义的必由之路，是决定当代中国命运的关键一招，也是实现两个一百年奋斗目标、实现中华民族伟大复兴的关键一招 思修个人与社会的关系123个人**与社会**是辩证统一的，二者相辅相成。社会**是和个人**实现的基础和前提，同时社会**也保障着个人**的实现。社会**不是单个人个人**的简单相加，而是无数人个人**的凝练升华社会保护个人的正当诉求，但当个人**与社会**发生冲突时，个人**需服从于社会**。 五四精神1234五四运动，孕育了爱国进步民主科学的伟大五四精神，其核心是爱国主义精神以爱国主义为核心的民族精神，是中华民族团结奋斗自强不息的精神纽带新时代的中国青年要继续发扬五四精神，以实现中华民族的伟大复兴为己任树立远大理想、热爱伟大祖国、担当时代责任、勇于砥砺奋斗、练就过硬本领、锤炼品德修为 如何在新时代做一个忠诚的爱国者1234高举爱国主义伟大旗帜，把爱国之情、强国之志、报国之行结合起来，为国家和民族的做贡献爱国需要有情感基础，需要理性认识，更需要实际的行动把国家的安全、荣誉、利益放在高于一切的位置，始终做到爱国的深厚情感、理性认识和实际行动相统一，与祖国同呼吸共命运，才是真正的爱国者维护祖国统一和名族团结、增加国家安全意识 道德和法律的关系123456道德和法律都是调节人的思想行为、协调人际关系、维护社会秩序的重要手段，二者都是上层建筑的重要组成部分，并服务于一定的经济基础。法律以国家强制力为后盾，对违反法律的行为追究法律责任；道德对公民和社会组织进行道德教化，对违反道德的行为进行道德谴责。法制和道德相互促进强化道德对法治的支撑作用把道德要求贯彻到法制建设中去要运用发法律手段解决道德领域突出的问题，法律是道德的底线，也是道德的保障 当代中华文化的传播重要性12当今时代，文化在综合国力竞争中的地位日益重要，谁占据了文化制高点，谁就能更好的激烈的国际竞争中掌握主动权文化是一个国家、一个民族的灵魂，是人民的精神家园，也是政党的精神旗帜。文化兴则国运兴，文化强则国运强。没有高度的文化自信，没有文化的繁荣兴盛，就没有中华民族的伟大复兴 怎么做1我们要通过创新对外宣传方式方法，开展多渠道多形式多层次的文化交流，增强中华文化的感召力和影响力，增进国际社会对我国基本国情、价值观念、发展道路、内外政策的了解和认识，展示我国文明、民主、开放、进步的形象。 中国在国际社会上处理国际事物的基本态度12345中国的发展离不开世界，世界的发展更需要中国中国始终奉行独立自主的和平外交政策，坚持走和平发展道路。推动建设以合作共赢为核心的新型国际关系，打造人类命运共同体，坚持在和平共处五项原则的基础上与各国发展友好合作关系，尊重联合国宪章的宗旨和原则，维护世界和平与发展，推动建设持久和平、共同繁荣的和谐世界。第一，中国始终是世界和平的建设者，坚定走和平发展道路，无论国际形势如何变化，无论自身如何发展，中国永不称霸、永不扩张、永不谋求势力范围第二，中国始终是全球发展的贡献者，坚持走共同发展道路，继续奉行互利共赢的开放战略，将自身的发展经验和机遇同世界各国分享，欢迎各国搭乘中国发展的顺风车，一起来实现共同发展第三，中国始终做国际秩序的维护者，坚持走合作发展道路。继续维护以联合做宪章宗旨和原则为核心的国际秩序和国际体系，同广大发展中国家站在一起，坚定支持增加发展中国家在国际治理体系中的代表权和发言权 肖秀荣人与自然的关系、主观能动性与客观规律性* 人与自然的关系主观能动性和客观规律性的统一123尊重主观能动性是发挥客观规律性的前提。只有发挥主观能动性，才能正确认识客观规律。实践是客观规律性和主观能动性统一的基础 * 物质与意识的辩证关系矛盾以及事物的联系与发展* 矛盾的普遍性和特殊性* 矛盾的同一性和斗争性* 事物的普遍联系* 矛盾的分析方法认识世界和改造世界* 实践在认识活动中的决定作用* 实践与认识的辨证运动及其规律* 真理的绝对性和相对性* 真理和谬误科技及人民群众在社会历史发展中的作用正确把握科学技术的社会作用123科学技术是一把双刃剑，既可能促进经济社会发展造福人类，也可能在一定条件下产生一些消极的后果科学技术在运用于社会时所遇到的问题，往往是对于自然规律和人与自然的关系认识不够，或缺乏科技消极后果的强有力控制手段有合理的社会制度保障科学技术的正确运用，始终坚持使科学技术为人类的健康发展服务，让科技为人类造福 人民群众是历史的创造者12人民群众是物质财富的创造者，是社会精神财富的创造者，是社会变革的决定力量人民群众创造历史的活动受到一定社会历史条件的制约 坚持和发展中国特色社会主义坚持和发展中特的重要性1中国特色社会主义是改革开放以来党的全部理论和实践的主题，是党和人民历尽千辛万苦、付出巨大代价取得的根本成就。我们取得一切成绩和进步的根本原因，归结起来就是：开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系，确立了中国特色社会主义制度，发展了中国特色社会主义文化。 * 坚持和发展中国特色社会主义要一以贯之建设现代化经济体系，推动高质量发展* 推动高质量发展* 大力发展实体经济* 加快实施创新驱动发展战略* 实施乡村振兴战略* 积极推动城乡区域协调发展* 深化经济体制改革健全人民当家作主的制度体系人民代表大会制度1人民当家作主是社会主义民主政治的本质和核心。人民代表大会制度是中国社会主义民主政治最鲜明的特点，是人民当家作主的重要途径和最高实现形式，是社会主义政治文明的重要制度载体，是我国的根本政治制度。 社会主义协商民主坚持一国两制，推进祖国统一1一国是实行两制的基础，两制从属和派生于一国，并统一于一国之中 文化、社会、生态建设推动生态文明建设12345建设生态文明是中华民族永续发展的千年大计，关系人民福祉，关乎民族未来，功在当代、利在千秋。五位一体中的一位在新时代坚持和发展中国特色社会主义基本方略中坚持人与自然和谐共生是其中一条基本方略在新发展理念中，绿色是其中一大理念在三大攻坚战中，污染防治是其中一大攻坚战 * 文化自信决胜全面建成小康社会* 坚决打好三大攻坚战* 防范化解重大风险攻坚战* 精准脱贫攻坚战* 污染防治攻坚战全面深化改革改革开放的伟大意义1240年的实践充分证明，改革开放是党和人民大踏步赶上时代的重要法宝，是坚持和发展中国特色社会主义的必由之路，是决定当代中国命运的关键一招，也是实现两个一百年奋斗目标、实现中华民族伟大复兴的关键一招改革开放是正确之路、强国之路、富民之路 * 形成全面开放的新格局* 推进国家治理能力和治理体系现代化全面从严治党* 把党的政治建设放在首位* 全面从严治党永远在路上* 四个伟大中起决定作用的党的建设伟大工程新中国成立 70 周年* 中华人民共和国成立的伟大意义* 新中国最大的历史成就* 中国人民政治协商会议五四运动 100 周年* 五四运动的伟大意义* 五四运动的时代价值* 五四运动的历史特点不忘初心、牢记使命共产党人的初心和使命1为中国人民谋幸福，为中华民族谋复兴，是中国共产党人的初心和使命，是激励一代代中国共产党人前仆后继、英勇奋斗的根本动力 * 实现中华民族伟大复兴的历史使命* 跳出” 历史周期律 “、实现长期执政弘扬以爱国主义为核心的民族精神* 爱国主义* 发扬中国革命道德* 弘扬中国精神* 做社会主义核心价值观的积极践行者个人与社会* 科学高尚的人生追求* 人生价值* 个人理想与社会理想* 幸福都是奋斗出来的坚持依法治国和以德治国相结合* 法治和德治* 公共生活需要公共秩序* 网络生活中的道德要求* 培养法治思维尊重和维护法律权威1234第一，尊重和维护法律权威是社会主义法治观念和法治思维的核心要求，是建设社会主义法治国家的前提条件第二，尊重和维护法律权威对于推进国家治理体系和治理能力现代化、实现国家的长治久安尤为重要第三，尊重和维护法律权威是实现人民意志、维护人民利益、保障人民权利的基本途径第四，尊重和维护法律权威是维护个人合法利益的根本保障 当今世界的发展趋势* 经济全球化* 文化多样化* 社会信息化* 世界多极化中国特色大国外交中美关系中俄关系中非关系彰显联合国的权威和作用构建人类命运共同体与一带一路构建人类命运共同体一带一路和平发展道路中国理念、中国方案时政要点 当今世界正面临百年未有之大变局，和平与发展仍然是时代主题，同时不稳定性和不确定性更加突出，人类面临许多共同挑战 经济全球化是社会生产力发展的客观要求和科技进步的必然结果，是世界经济发展的重要趋势，不以人的意志转移 中国坚定维护多边主义，坚定维护以联合国为核心的国际体系，坚定维护以国际法为基础的国际秩序 中国走和平发展道路，坚定奉行独立自主的和平外交政策，秉持共商共建共享的全球治理观。中国外交的总目标是构建新型国际关系，构建人类命运共同体。 肖八助记框架马原第一套 从辨证法的角度分析为什么要打破惯性思维？ 123456原理-事物的变化发展世上一切事物都处在永不停息的运动、变化、发展之中发展是事物的一个过程不能从静止的角度去理解事物一切以时间、地点、条件为转移运动是物质的根本属性和存在方式 结论:惯性思维的问题就是在于用静止的眼光看问题，因此必须打破惯性思维 运用实践与认识的辨证运动规律，分析惯性思维的缺陷 1原理-这一规律的特性：这一认识运动规律决定了主观和客观、认识和实践的统一是具体的、历史的 认识的规律 结论：主观认识也应当是具体的、历史的。 上述材料对我们发展创新思维有什么启示？ 12创新的概念：创新就是破除与客观是不进程不相符的旧观念、旧理论、旧模式、旧做法在继承历史发展成果的基础上，运用新的联系和规律，更有效的认识和改造世界 第二套 为什么要具体问题具体分析 矛盾的普遍性与特殊性 为什么亲临现场… 实践与认识的关系 第三套 为什么技术创新要真正聚焦应用 实践是认识的目的 如何理解” 想象力比知识更为重要 “ 12理性因素与非理性因素的辩证关系非理性因素具有激活、驱动控制的作用 感性认识与理性认识的辩证关系 第四套 相互竞争、相互促进 矛盾的同一性和斗争性辩证关系原理 精神的作用 意识的能动性作用原理 第五套 人与自然的关系 人与自然的关系 主观能动性和客观规律性 主观能动性和客观规律性的辩证关系（肖秀荣） 第六套 算法可以用来计算，也能用来算计 123456结论：算法推荐和其他科学技术一样，是一把双刃剑。为什么一方面，科学技术的作用受到诸如社会制度、利益关系、人的观念和认识水平的影响另一方面，运用时的问题往往由于人们认识的不足和对科学技术消极后果强有的控制手段造成的怎么办大力发展生产力和科学技术，要有合理的制度保障，始终坚持科学技术为人类造福 避免陷入信息的” 茧房 123认识论第一，通过实践、调查，获取十分丰富的合乎实际的感性材料；在经过理性的思考，将丰富的感性材料加工制作，去粗取精、去伪存真，由此及彼，由表及里第二，由于认识和实践的具体性和历史性，要求主观认识要同一定时间、地点、条件下的客观实践相符合，要同特定历史发展阶段和客观实践相适应 第七套 质量互变 1234质：事物成为自身并区别于其他事物的规定性量：事物的规模程度速度等数量关系表示度：保持事物质的稳定的数量界限底线：事物发生质变的邻接点 内容和形式 1234相互统一内容决定形式，形式反作用于内容适合内容的形式，对内容起到积极的推动作用不适合内容的形式，对内容起到消极的阻碍作用 第八套 矛盾的普遍性与特殊性 矛盾的普遍性与特殊性 怎么办 近代史第一套 中华人民共和国成立的意义 70 年来我们取得了哪些经验 1234只有中国共产党能领导中国只有社会主义才能就中国只有改革开放才能发展中国、发展社会主义、发展马克思主义只有中国特色社会主义道路才能引领中国走向繁荣富强 第二套 五四运动的意义 五四精神 第三套 不忘初心，牢记使命 党带领人民所作的三件大事 第四套 人民政协在各个历史时期的作用 1234成立时：中国人民政治协商会议第一届全体会议，代行全国人民代表大会职权，为新中国的诞生做了全面的准备新中国成立后：恢复和发展国民经济、巩固新生任命证券、推进社会主义建设改革开放后：为改革开放做出了重要贡献新时代：积极投身实现两个一百年奋斗目标，实现中华民族伟大复兴的中国梦 为什么要坚持人民政协 1234强调了党的集中统一领导代表和实现了最广大人民的根本利益把各个政党和无党派认识紧密团结起来、推动决策科学化民主化有效i面其他国家政党制度的缺陷 社会主义协商民主的重要性 第五套 保持党的优良作风 12危机：现阶段，我们党面临的执政考验、改革开放考验、市场经济考验、外部环境考验具有长期性和复杂性；面临的精神懈怠危险、能力不足危险、消极腐败危险具有尖锐性和严峻性。使命：我们党还要团结带领人民全面建成小康社会，分两步走实现全面建成社会主义现代化强国、进而实现中华民族伟大复兴的历史使命 如何实现党的长期执政 12国家层面：第一，要大力发展社会主义民主，健全人民当家作主的制度体系。党的层面：第二，必须坚持党要管党、从严治党，推进党的建设新的伟大工程要一以贯之 第六套 (重点) 为什么新中国最大的成就是坚持和发展了中国特色社会主义 123456中国特色社会主义是几代中国共产党人持续奋斗的结果第一，以毛泽东为主要代表的中国共产党人，创立了毛泽东思想。新中国成立后，顺利的进行了社会主义改造，确立了社会主义基本制度，发展了社会主义的经济、政治和文化第二，十一届三中全会以来，以邓小平为主要代表的中国共产党人，回答了什么是社会主义，怎样建设社会主义的问题，创立了邓小平理论。第三，十三届四中全会以来，以江泽明为主要代表的中国共产党人，回答了建设什么样的党、怎样建设党的基本问题，形成了三个代表重要思想第四，十六大以来，以胡锦涛为主要代表的中国共产党人，回答了实现怎么样的发展、怎样发展等重大问题，形成了科学发展观第五，十八大以来，以习近平为主要代表的中国共产党人，回答了新时代坚持和发展怎么样的中国特色社会主义、怎样坚持和发展中国特色社会主义这个重大时代课题，创立了习近平新时代中国特色社会主义思想 怎样坚持和发展中国特色社会主义 12总结经验、展望未来：改革开放以来，我们取得的一切成绩和进步的根本原因，归结起来就是高举了中国特色社会主义伟大旗帜。我们完成两步走的发展目标，实现中华民族伟大复兴，必须坚持和发展中国特色社会主义。中国特色社会主义事业作为前无古人的开创性事业，前路漫漫且不可能一帆风顺。需要我们一代又一代人的接续奋斗，必须一以贯之的进行下去 第七套 为什么革命理想高于天 略 如何在新长征路上凝聚力量 1234知：我们要不忘初心、牢记使命深刻认识红色政权来之不易、新中国来之不易、中国特色社会主义来之不易行：依靠全党全国人民鉴定的理想信念和坚强的革命意志，不断进行自我革命，战胜来自国内外的各种重大风险挑战，夺取中国特色社会主义的新胜利 第八套 农村农名在中国革命、建设和改革的作用 1234567891011革命：新民主主义革命的实质：中国共产党领导下的农民革命中国武装斗争的实质：工人阶级领导的农民战争中国革命道路：农村包围城市、武装夺取政权建设时期地位：农村支持城市，农业支持工业改革时期地位：改革始于经济体制改革，经济体制改革突破于农村（家庭联产承包）乡镇企业异军突起倒逼城市改革 乡村振兴战略 毛中特第一套 为什么把污染防治作为三大攻坚战的任务之一 12全面小康，是五位一体全面进步的小康，要求覆盖的领域要全面。显然污染问题已经成为全面建成小康社会的明显短板。进入新时代，解决人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾对生态环境保护提出许多新的要求 脱贫攻坚是全面建成小康社会必须完成的硬任务 12全面小康的要求：全面小康，是惠及全体人民的小康。覆盖的区域要全面，是城乡区域共同发展的小康。没有农村地区，贫困人口的脱贫、致富，就没有全面建成小康社会 第二套 为什么一定要把实体经济搞上去 123实体经济是一国经济的立身之本、财富之源、是国家强盛的重要支柱实体经济是实现两个一百年奋斗目标和中华民族伟大复兴中国梦的坚实基础国家提高竞争力，更要靠实体经济 创新 第三套 为什么如此重视区域协调发展 123第一，这是新发展理念的要求。协调是持续健康发展的内在要求第二，这是建设现代化经济体系的需要第三，是解决当前我国发展中不平衡、不协调、不可持续的突出问题的重要途径 建设粤港澳大湾区的重要意义 123456总：这是新时代推动形成全面开放新格局的新尝试，也是推动一国两制世界发展的新实践四个有利于：有利于丰富一国两制的实践内涵，进一步密切内地与港澳交流合作有利于贯彻落实新发展理念，深入推进供给侧结构性改革有利于进一步深化改革、扩大开放有利于一带一路的建设 第四套 如何理解污染防治是一道重要关口 略 生态文明建设必须坚持怎样的原则 略 第五套 对外开放 同 1 略 第六套 为什么祖国必须统一也必然统一 1234567祖国统一是实现中华民族伟大复兴的必然要求人民：统一是中华民族的共同愿望。台湾自古以来就是中国不可分割的一部分。解决台湾问题，实现祖国完全统一，是包括台湾人民在内的中华民的共同愿望，是中华民族的根本利益所在。民族复兴：有利于中华民族振兴，是大势所趋，大义所在，民心所向党和政府：解决台湾问题、实现祖国完全统一是中国共产党和中国政府矢志不渝的奋斗目标，是中国政府的三大历史任务之一。 第七套 为什么如此重视垃圾分类 1234为了人民：我们党和国家始终把以人民为中心的发展思想落到实处、落在细处，带领人民不断创造着美好生活社会主要矛盾变化：作用：改善环境、促进资源回收、提高国民素质 怎样加强科学管理（模板 1234管理和制度：需要加强科学管理，形成长效机制四个坚持：坚持系统治理、依法治理、源头治理、综合治理重心下移：把社会治理的中心向基层下移，落到城乡社区社区是党和政府联系、服务居民群众的最后一公里 第八套 文化自信 建设社会主义文化强国 1234坚持文化自信推动中华优秀传统文化创造性转化、创新性发展大力发展文化事业和文化产业提高国家文化软实力 略 思修第一套 怎么爱国 第二套 当代青年怎么做 第三套腿姐冲刺时政技巧 关于同盟：中国不同盟，只谈伙伴 关于南北：不是地域，南是发展中国家和新兴国家，北是发达国家 关于双边、多边：这是好的，但是主权不能多边 关于美国：万恶之源、美国坏！ 关于一体化：对应于经济，但是政治文化需要多元 关于军事、军事合作： 猜答案能力 一个三选一个四选（慎用） 新闻联播式语言 “中国之治” 的制度 “密码”（重点！！）（ 一 ） 第 一 次 擘 画 了 社 会 主 义 制 度 的 图 谱统领 ： 坚持和完善党的领导制度体系 （ 国 家 根 零 领 导 制 度 ） 一 一 新提法 ：要 建 立 不 忘 心 、 牢 记 使 命 的 制 度 坚 持 和 完 善 人 民 当 家 作 主 制 度 体 系 ， 发 展 社 会 主 义 民 主 政 治 坚 持 和 完 善 中 国 特 色 社 会 主 义 法 治 体 系 （ 时 政 小 妖 词 ： 建 设 中 国 特 色 社 会 主 义 法 治 体 系 、 建 设 社 会 主 义 法 治 国 家 是 坚 持 和 发 展 中 国 特 色 社 会 主 义 的 内 在 要 求 ） 坚 持 和 完 善 中 国 特 色 社 会 主 义 行 政 体 制 ， 构 建 职 责 明 确 、 依 法 行 政 的 政 府 治 理 体 系 坚 持 和 完 善 社 会 主 义 基 本 经 济 制 度 ， 推 动 经 济 高 质 量 发 展 （ 创 新 点 ： 把 按 劳 分 配 为 体 ． 多 种 分 配 方 式 并 存 ， 社 会 主 义 市 场 经 济 体 制 上 升 为 基 本 经 济 制 度 ） 坚 持 和 完 善 繁 荣 发 展 社 会 主 义 先 进 文 化 的 制 度 ， 巩 固 全 体 人 民 团 结 奋 斗 的 共 同 思 想 基 础 （ 时 政 小 妖 词 ： 发 展 社 会 主 义 先 进 文 化 、 广 泛 凝 聚 人 民 精 神 力 量 ， 是 国 家 治 理 体 系 和 治 理 能 力 现 代 化 的 深 厚 支 撑 ） 坚 持 和 完 善 统 筹 城 乡 的 民 生 保 障 制 度 ， 满 足 人 民 日 益 增 长 的 美 好 生 活 需 要 。 （ 时 政 小 妖 词 ： 增 进 人 民 福 祉 、 促 进 人 的 全 而 发 展 是 我 们 党 立 党 为 公 、 执 政 为 民 的 本 质 求 ） 坚 持 和 完 善 共 建 共 治 共 享 的 社 会 治 理 制 度 ， 保 持 社 会 稳 定 、 维 护 国 家 安 全 。 坚 持 和 完 善 生 态 文 明 制 度 体 系 ， 促 进 人 与 自 然 和 谐 共 生 。 坚 持 和 完 善 党 对 人 民 军 队 的 绝 对 领 导 制 度 ， 确 保 人 民 军 队 忠 实 履 行 新 时 代 使 命 任 务 。（ 时 政 小 妖 词 ： 党 对 人 民 军 队 的 绝 对 领 导 是 人 民 军 队 的 建 军 之 本 、 强 军 之 魂 ） 坚 持 和 完 善 “一 国 两 制 “ 制 度 体 系 ， 推 进 祖 国 和 平 统 一 一 国 两 制 “ 是 党 领 导 人 民 现 祖 国 和 平 统 一 的 一 项 重要 制 度 ， 是 中 国 特 色 社 会 主 义 的 一 个 伟 大 创 举 ， （ 新 定 位 ： 把 坚 持 一 国 两 制 保 持 香 港 、 澳 门 长 期 繁 荣 稳 定 ， 促 进 祖 国 和 平 统 一 列 为 中 国 特 色 社 会 主 义 制 度 的 显 著 优 势 之 一 ）・提 出 完 善 “ 一国两制” 制 度 体 系 五 大 任 务 要 求 ， 一 是 坚 持 依 法 治 港 治 澳 ， ，包 括 维 护 宪 法 和 基 本 法 确 定 的 特 别 行 政 区 宪 制 秩 序 ， 完 善 特 别 行 政 区 同 宪 法 和 基 本 法 实 施 相 关 的 制 度 机 制 ， 坚 持 以 爱 国 者 为 主 体 的 “ 港 人 治 港 ～ 澳 人 治 澳 ， 等 ； 二 是 完 善 中 央 对 特 别 行 政 区 行 政 长 官 和 主 要 官 员 的 任 免 制 度 和 机 制 、 全 国 人 大 常 委 会 对 基 本 法 的 解 释 制 度 等 ； 三 是 建 立 健 全 特 别 行 政 区 维 护 国 家 安 全 的 法 律 制 度 和 执 行 机 制 ， 支 持 特 别 行 政 区 强 化 执 法 力 量 ； 四 是 完 善 香 港 、 澳 门 融 入 国 家 发 展 大 局 、 同 内 地 优 勢 互 补 、 协 同 发 展 机 制 ， 推 进 粤 澳 大 湾 区 建 设 等 ； 五 是 加 强 对 香 、 澳 门 社 会 特 别 是 公 职 人 员 和 青 少 年 的 宪 法 和 基 本 法 教 育 、 国 情 教 育 、 中 国 历 史 和 中 平 文 化 教 育 等・（ 注 意 与 香 间 题 的 结 合 ） 全 会 提 出 ， 坚 持 和 完 善 独 立 自 主 的 和 平 外 交 政 策 ， 推 动 构 建 人 类 命 运 共 同 体 坚 持 和 完 善 党 和 国 家 监 督 体 系 ， 强 化 对 权 力 运 行 的 制 约 和 监 督 。 （ 时 政 小 妖 词 ： 党 和 国 家 监 督 体 系 是 党 在 长 期 执 政 条 件 下 实 现 自 我 净 化 、 自 我 完 善 、 自 我 革 新 、 自 我 提 高 的 重 制 度 保 障） （ 二 ） 国 家 治 理 体 系 的 内 涵 与 意 义 （ 背 ！ ！ ）​ 中 国 特 色 社 会 主 义 制 度 是 党 和 人 民 在 期 实 践 探 索 中 形 成 的 科 学 制 度 体 系 ， 我 国 国 家 治 理 一 切 工 作 和 活 动 都 依 照 中 国 特 色 社 会 主 义 制 度 展 开 ， 我 国 国 家 治 理 体 系 和 治 理 能 力 是 中 国 特 色 社 会 义 制 度 及 其 执 行 能 力 的 集 中 体 现 。 ​ 新 中 国 70 年 取 得 的 历 史 性 成 就 充 分 证 明 ， 中 国 特 色 社 会 主 义 制 度 是 当 代 中 国 发 展 进 步 的 根 本 保 障 。 中 国 特 色 社 会 主 义 制 度 和 国 家 治 理 体 系 是 以 马 克 思 主 义 为 指 导 、 植 根 中 国 大 地 、 具 有 深 厚 中 华 文 化 根 基 、 深 得 人 民 拥 护 的 制 度 和 治 理 体 系 ， 是 具 有 强 大 生 命 力 和 巨 大 优 越 性 的 制 度 和 治 理 体 系 ， 是 能 够 持 续 推 动 拥 有 近 十 四 亿 人 日 大 国 进 步 和 发 展 、 确 保 拥 有 五 千 多 年 文 明 史 的 中 华 民 族 实 现 “ 两 个 一 百 年 ， 奋 斗 目 标 进 而 实 现 伟 大 复 兴 的 制 度 和 治 理 体系 。 实 践 充 分 表 明 ， 我 国 国 家 制 度 和 国 家 治 理 体 系 具 有 多 方 而 的 显 著 优 势 ， 这 些 显 著 优 势 ， 是 我 们 坚 定 中 国 特 色 社 会 主 义 道 路 自 信 、 理 论 自 信 、 制 度 自 信 、 文 化 自 信 的 基 本 依 据 。 （ 三 ） 如 何 发 挥 社 会 主 义 制 度 和 治 理 体 系 的 优 势 与 效 能 ？（ 制 度 优 勢 与 治 理 效 能 ， 背 ！ ）​ 中 国 特 色 社 会 主 义 制 度 是 具 有 显 著 优 越 性 和 强 大 生 命 力 的 制 度 。 把 我 国 国 家 制 度 和 国 家 治 理 体 系 的 显 著 优 势 更 加 充 分 地 发 挥 出 来 ， 是 新 时 代 坚 持 和 完 善 中 国 特 色 社 会 主 义 制 度 、 推 进 国 家 治 理 体 系 和 治 理 能 力 现 代 化 的 努 力 方 向 ， ​ 要 毫 不 动 摇 坚 持 和 巩 固 中 国 特 色 社 会 主 义 制 度 ： 与 时 俱 进 完 善 和 发 展 中 国 特 色 社 会 主 义 制 度 和 国 家 治 理 体 系 ， 严 格 遵 守 和 执 行 制 度 。 党 的 领 导 是 中 国 特 色 社 会 主 义 最 本 质 的 特 征 和 最 大 的 制 度 优 势 ， 也 是 坚 持 和 完 善 中 国 特 色 社 会 主 义 制 度 、 推 进 国 家 治 理 体 系 和 治 理 能 力 现 代 化 最 根 本 的 政 治 保 证 。 ​ 只 要 朝 着 坚 持 和 完 善 中 国 特 色 社 会 主 义 制 度 、 推 进 国 家 治 理 体 系 和 治 理 能 力 现 代 化 的 总 体 目 标 努 力 ， 坚 定 信 心 ， 保 持 定 力 ， 锐 意 进 取 ， 开 拓 创 新 ， 我 们 就 一 定 能 制 度 更 加 成 熟 更 加 定 型 ， 让 发 展 更 有 质 量 ， 让 治 理 更 有 水 平 ， 让 人 民 更 有 获 得 感 。 为 实 现 “两 个 一 百 年” 奋 斗 目 标 、 实 现 中 华 民 族 伟 大 复 兴 的 中 国 梦 提 供 有 力 保 证 。 不忘初心、牢记使命党的初心和使命是 + 徐涛当带领人民所做的三件大事 + 中 国 特 色 社 会 主 义 进 入 新 时 代 ， 我 们 比 历 史 上 任 何 时 期 都 更 接 近 、 更 有 信 心 和 能 力 实 现 中 华 民 族 伟 大 复 兴 。 我 们 取 得 的 成 就 举 世 瞩 目 ， 这 值 得 我 们 自 豪 ， 但 决 不 能 因 此 而 自 满 。 新 时 代 做 到 不 忘 初 心 、 牢 记 使 命 ， 必 须 有 强 烈 的 自 我 革 命 精 神 。 在 新 的 征 程 上 ， 我 们 要 把 党 建 设 成 为 始 终 走 在 时 代 前 列 、 人 民 衷 心 拥 护 、 勇 于 自 我 革 命 、 经 得 起 各 种 风 浪 考 验 、 朝 气 蓬 勃 的 马 克 思 主 义 执 政 党 ， 就 必 须 牢 记 初 心 和 使 命 ， 在 新 时 代 把 党 的 自 我 革 命 推 向 深 入 人民政协、协商民主、政协制度1) 政 协 制 度 与 人 民 政 的 重 要 性 ：中 国 共 产 党 领导 的 多 党 合 作 和 政 治 协 商 制 度 是 我 国 的 一 项 基 本 政 治 制 度 ， 是 从 中 国 土壤 中 生 长 出 来 的 新 型 政 党 制 度 。 人 民 政 协 作 为 统 一 战 线 的 组 织 、 多 党 合 作 和 政 治 协 商 的 机 构 、 人 民 民 主 的 重 要 实 现 形 式 ， 是 社会主义协商民主 的 要 渠 道 和 专 门 协 商 机 构 ， 是 国 家 治 理 体 系 的 重 要 组 成 部 分 ， 是 具 有 中 国 特 色 的 制 度 安 排 ， 人民 政 协 要 坚 持 性 质 定 位 ， 坚 定 不 移 走 中 国 特 色 社 会 主 义 政 治 发 展 道 路 。 2 ） 如 何 发 扬 人 民 政 协 的 作 用 ： 中 国 共 产 党 的 领 导 是 人 民 政 协 事 业 发 展 进 步 的 根 本 保 证 ， 要 把 坚 持 党 的 导 贯 穿 到 政 协 全 工 作 之 中 。 人 民 政 协 要 为 民 主 党 派 和 无 党 派 人 士 在 政 协 更 好 发 打 作 用 创 造 条 件 ， 要 发 挥 统 一 战 线 组 织 功 能 ， 坚 持 大团 结 大 联 合 ， 坚 持 一 致 性 和 多 样 性 统 一 ， 不 断 巩 固 共 同 思 想 政 治 基 础 ， 加 强 思 想 政 治 引领 ， 广 泛 凝 聚 共 识 ， 努 力 寻 求 最 大 公 约 數 、 画 出 最 大 同 心 圆 ， 汇 聚 起 实 现 民 族 复 兴 的 磅 礴 力量 。 3 ） 协 商 民 主 的 重 要 性 与 如 何 发 扬 ：协商 民 主 是 实 党 的 领 导 的 要 方 式 ， 是 我 国 社 会 主 义 民 主 政治 的 特 有 形 式 和 独 特 优 势 。 政 协 商 是 我 国 独 有 的 协商 民 主 形 式 ， 中 国 共 产 党 领 导 的 多 党 合 作 和 政 治 商 制 度 是 独 具 特 色 的 政 党 制 度 ， 基 层 协 商 是 中 国 特 色 社 会 主 义 民 主 政 治 的 要 内 容 。 实 现 民 主 的 形 式 是 丰 富 多 彩 的 ， 不 能 拘 泥 于 刻 板 模 式 ， 世 界 上 没 有 一 种 放 之 四 海 而 皆 准 的 评 判 标 准 ， 哪 一 种 民 主 是 合适 的 ． 应 当 以 它 在 一 国 治 理 中 的 实 际 效 果 来 衡 量 。 我 国 社 会 主 义 协 商 民 主 作 为 人 民 民 主 的 重 要 形 式 ， 展 现 出 独 特 优 势 ， 彰 显 出 巨 大 优 越 性 ， 协 商 民 主 让 广 大 人 民 享 有 实 实 在 在 的 民 主 权 利。协 商 民 主 是 一 种 有 效 的 国 家 治 理 方 式 。 协 商 民 主 在 化 解 矛 盾 冲 突 、 促 进 社 会 和 谐 稳 定 方面 具 有 独 特 优 势 ， 五四运动的意义结合徐涛背诵计划 五 四 运 动 ， 以 彻 底 反 帝 反 封 建 的 革 命 性 、 追 求 救 国 强 国 真 理 的 进 步 性 、 各 族 各 界 群 众 积 极 参 与 的 广 泛 性 ， 推 动 了 中 国 社 会 进 步 ` 促 进 了 马 克 思 主 义 在 中 国 的 传 播 ， 促 进 了 马 克 思 主 义 同 中 国 工 人 运 动 的 结 合 ， 为 中 国 共 产 党 成 立 做 了 思 想 上 干 部 上 的 准 备 ， 为 新 的 革 命 力 量 、 革 命 文 化 、 革 命 斗 争 登 上 历 史 舞 台 创 造 了 条 件 ， 是 中 国 旧 民 主 主 义 革 命 走 向 新 民 主 主 义 革 命 的 转 折 点 ， 在 近 代 以 来 中 华 民 族 追 求 民 族 独 立 和 发 展 进 步 的 历 史 进 程 中 具 有 里 程 碑 意 义 。 一带一路的意义与中国的态度共 建 “一 带 一 路 “ 顺 应 了 全 球 治 理 体 系 变 革 的 内 在 要 求 ， 彰 显 了 同 舟 共 济 、 权 责 共 担 的 命 运 共 同 体 意 识 ， 为 完 善 全 球 治 理 体 系 变 革 提 供 了 新 思 路 新 方 案 。 共 建 “ 一 带 一 路 。 为 世 界 经 济 增 长 开 辟 了 新 空 间 ， 为 国 际 贸 易 和 投 资 搭 建 了 新 平 台 ， 为 完 善 全 球 经 济 治 理 拓 展 了 新 实 践 ， 为 增 进 各 国 民 生 福 祉 作 出 了 新 贡 献 ， 成 为 共 同 的 机 遇 之 路 、 繁 荣 之 路 。 中 国 愿 同 各方一道，以绘制 “工笔画” 精神共同推动共建” 一带一路 “合作走深走实、行稳致远、高质量发展，开创更加美好的未来。 当代精华语句世界经济形势国际金融危机发生 10 年以后，世界经济再次来到十字路口。保护主义、单边主义持续蔓延，世界经济运行风险和不确定性显著上升。经济全球化遇到一些曲折困难，但经济全球化潮流不可逆转，各国利益日益交融、命运更加休戚与共是大势所趋，不断创造更加美好的生活是各国人民的共同期待。 ​ 世界经济发展面临的难题，没有哪一个国家能独自解决。各国应该坚持人类优先的理念，而不应该把一己之利凌驾于人类利益至上。中国将坚定不移的走和平发展道路，奉行互利共赢开放战略，继续为开放型世界经济发展增添动力。同世界各国人民一道，推动经济全球化朝着更加开放、包容、普惠、平衡、共赢的方向发展，让经济全球化更好造福世界各国人民。 真实的中国徐涛的当代模板 + 中国部 “输入” 外国模式，也不输出” 中国模式 “，不会要求别国” 复制 “中国的做法。 人类命运共同体构 建 人 类 命 运 共 同 体 思 想 是 全 球 化 时 代 条 件 下 的 中 国 国 际 关 系 理 论 ， 开 创 了 中 国 外 交 实 践 新 局 面 ， 也 是 国 际 治 理 的 中 国 方 案 ， 增 强 了 中 国 特 色 社 会 主 义 的 国 际 影 响 力 。 要 树 立 人 类 命 运 共 同 体 的 意 识 ， 建 设 一 个 共 赢 共 享 的 世 界 ， 建 设 一 个 持 久 和 平 、 普 遍 安 全 、 共 同 繁 荣 、 交 流 互 鉴 、 清 洁 美 丽 的 世 界 。 新型国际关系 \ 合作共赢新 型 国 际 关 系 以 合 作 共 赢 为 核 心 ， 其 基 本 理 念 和 应 遵 循 的 原 则 就 是 相 互 尊 重 、 公 平 正 义 、 合 作 共 赢 。 新 型 国 际 关 系 新 就 “ 新 “ 在 合 作 共 赢 。 强 调 的 是 奉 行 双 赢 、 多 赢 、 共 赢 的 新 理 念 ， 扔 掉 我 赢 你 输 、 赢 者 通 吃 的 旧 思 维 。 世 界 各 国 在 谋 求 自 身 发 展 的 同 时 ， 要 积 极 促 进 其 他 各 国 共 同 发 展 ， 让 各 国 和 各 国 人 民 共 同 享 受 发 展 成 果 开放合作中 国 的 发 展 离 不 开 世 界 ， 世 界 的 发 展 也 离 不 开 中 国 。 中 国 的 发 展 是 世 界 的 机 遇 ， 中 国 是 经 济 全 球 化 的 受 益 者 ， 更 是 贡 献 者 。 中 国 不 断 扩 大 对 外 开 放 ， 不 仅 发 展 了 自 己 ， 也 造 福 了 世 界 ， 开 放 已 经 成 为 当 代 中 国 的 鲜 明 标 识 。 回 顾 历 史 ， 开 放 合 作 是 增 强 国 际 经 贸 活 力 的 重 要 动 力 。 立 足 当 今 ， 开 放 合 作 是 推 动 世 界 经 济 稳 定 复 苏 的 现 实 要 求 。 放 眼 未 来 ， 开 放 合 作 是 促 进 人 类 社 会 不 断 进 步 的 时 代 要 求 。 （ 原 因 ） 中 国 开 放 的 大 门 不 会 关 闭 ， 只 会 越 开 越 大 。 中 国 将 始 终 是 全 球 共 同 开 放 的 重 要 推 动 者 、 世 界 经 济 增 长 的 稳 定 动 力 源 、 各 国 拓 展 商 机 的 活 力 大 市 场 、 全 球 治 理 改 节 的 积 极 贡 献 者 ， 这 是 中 国 作 为 负 责 任 大 国 的 责 任 和 担 当 。 持 续 推 动 全 球 共 同 开 放 ， 以 开 放 带 来 合 作 ， 以 合 作 促 进 发 展 。 中 国 将 坚 定 不 移 奉 行 互 利 共 赢 的 开 放 战 略 ， 愿 同 国 际 社 会 一 道 ， 在 开 放 中 合 作 、 以 合 作 求 共 赢 ， 共 同 维 护 自 由 贸 易 和 多 边 贸 易 体 制 ， 共 建 创 新 包 容 的 开 放 型 世 界 经 济 ， 向 着 构 建 人 类 命 运 共 同 体 目 标 不 懈 奋 进 ， 开 创 人 类 更 加 美 好 的 未 来 。 （ 措 施 ） 开放型世界经济中 国 的 发 展 是 世 界 的 机 遇 ， 面 向 未 来 ， 中 国 扩 大 对 外 开 放 的 决 心 没 有 变 。 我 们 要 促 进 贸 易 和 投 资 化 自 由 便 利 化 ， 旗 帜 鲜 明 反 对 保 护 主 义 、 单 边 主 义 ， 提 升 多 边 和 双 边 开 放 水 平 ， 推 动 经 济 全 球 化 朝 着 更 加 开 放 、 包 容 、 普 惠 、 平 衡 、 共 赢 的 方 向 发 展 。 推 动 各 国 经 济 联 动 融 通 ， 共 同 建 设 开 放 型 世 界 经 济 。 中国方案中 国 作 为 联 合 国 常 任 理 事 国 ， 承 担 着 重 要 的 大 国 责 任 与 担 当 。 中 国 将 继 续 做 世 界 和 平 的 建 设 者，全 球 发 展 的 贡 献 者， 国 际 秩 序 的 维 护 者 ， 推 动 构 建 新 型 国 际 关 系 和 人 类 命 运 共 同 体。我 们 将 坚 定 走 和 平 发 展 道 路 ， 决 不 损 人 利 己 、 以 邻 为 壑 。 中 方 将 继 续 在 和 平 共 处 五 项 原 则 基 础 上 深 化 同 各 国 的 友 好 合 作 ， 通 过 和 平 方 式 处 理 同 有 关 国 家 的 领 土 主 权 和 海 洋 权 益 争 端 ， 支 持 对 话 协 商 解 决 地 区 热 点 问 题 。 （ 政 治 ） 中 国 将 坚 持 开 放 共 赢 ， 同 各 国 分 享 发 展 机 遇 。 坚 定 践 行 多 边 主 义 ， 维 护 以 国 际 法 为 基 础 的 国 际 秩 序 。 中 方 愿 同 各 国 一 道 ， 秉 持 共 商 共 建 共 享 的 全 球 治 理 观 ， 坚 定 维 护 以 联 合 国 为 核 心 的 国 际 体 系 ， 坚 定 维 护 以 世 界 贸 易 组 织 为 核 心 的 多 边 贸 易 体 制 。 （ 经 济 ） 美国坏坏XX 体 现 了 以 美 国 为 首 的 西 方 大 国 对 “ 中 国 崛 起 “ 的 险 恶 揣 测 及 用 心 。 以 美 国 为 的 西 方 大 国 宣 扬 “ 国 强 必 霸 “ 的 逻 辑 ， 站 在 “ 美 国 优 先 “ 的 立 场 上 ， 希 望 遏 制 “ 中 国 崛 起 ‘ ， 无 视 经 济 全 球 化 的 历 史 趋 势 与 规 律 ， 悍 然 实 行 单 边 主 义 、 贸 易 保 护 主 义 ， 以 保 持 和 扩 大 自 己 的 资 源 版 图 和 地 区 利 益 ， 建 立 以 美 国 为 主 导 的 世 界 经 济 政 治 秩 序 ， 谋 求 世 界 霸 主 地 位 。 所 谓 的 X X 理 论 是 霸 权 主 义 、 强 权 政 治 的 衣 现 ， 是 毫 无 根 据 ， 且 别 有 用 心 的 ， 有 着 不 可 告 人 的 政 治 目 的 ； 其 意 在 维 护 “ 美 国 优 先 “ 的 立 场 和 利 益 ， 是 对 世 界 和 平 的 严 重 威 胁 。 X X 破 坏 了 多 边 贸 易 规 则 和 国 际 经 济 秩 序 ， 美 国 这 种 无 视 大 国 责 任 ， 实 行 单 边 主 义 、 贸 易 霸 凌 主 义 的 结 果 ， 既 伤 害 了 包 括 中 美 经 贸 在 内 的 全 球 经 贸 关 系 ， 也 成 为 全 球 经 济 复 苏 的 最 大 不 确 定 因 素 和 风 险 源 ， 阻 碍 国 际 贸 易 和 全 球 经 济 复 苏 腿姐预测马原同一性和斗争性12矛盾的同一性：矛盾双方相互依存相互贯通的的性质和趋势矛盾的斗争性：矛盾的对立面之间相互排斥相互分离的性质和趋势 123没有同一就没有斗争，没有斗争也没有同一 斗争性寓于同一性之中，同一性通过斗争性来体现 斗争性是无条件绝对的，同一性是有条件相对的 123456第一，矛盾双方相互依存，因此矛盾双方可以通过的对方的发展来使自己得到发展第二，矛盾双方相互包含，因此矛盾双方可以相互吸收有利于自身的因素得到发展第三，矛盾双方彼此相通，因此矛盾双方可以通过朝自己的对立面转化而得到发展第一，矛盾双方的斗争促进双方力量的变化，此消彼长，造成事物的两遍，为事物的质变创造必要条件第二，矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过度的决定性力量 1方法论：从对立中把握同一，从同一中把握对立。 斗争性和同一性的解释👆。斗争性是无条件绝对的，同一性有条件相对的。没有同一就没有斗争，没有斗争也没有同一。斗争性寓于同一性之中，同一性通过斗争性来体现。方法论：从对立中把握同一，从同一中把握对立。 普遍性和特殊性123矛盾的普遍性是指万事万物都有矛盾，矛盾无时不有，无处不在矛盾的特殊性：具体事物所包含的矛盾及矛盾的每一个方面都各有其特点具体表现为：不同事物矛盾不同、同一事物的矛盾在不同发展阶段不同，同一事物的不同矛盾和矛盾的不同方面不同 123矛盾的普遍性即共性，矛盾的特殊性即个性 共性是无条件绝对的，个性是有条件相对的 共性寓于个性之中，没有离开共性的个性，也没有离开个性的共性 1方法论:坚持事物共性与个性的统一，从个别中把握一般，举一反三，具体问题具体分析。 必然和偶然必然性和偶然性是对立统一的。偶然性中有必然，任何偶然的东西都必须受必然性制约。必然性中有偶然，偶然性是必然性的表现，为必然性开辟道路，在一定条件下两者可以相互转化。方法论：既要重视事物发展的必然性，把握事物发展的总趋势，又要善于从偶然中发现必然。 理性因素和非理性因素理性因素是指人的理性直观、理性思维。非理性因素是指人的情感和意志。理性因素具有指导解释和遇见作用，非理性因素具有激活驱动和控制作用。 现象和本质本质是事物的根本性质，是相对稳定的，藏于事物内部。现象是事物的外部联系和表面特征，是个别的具体的多变易逝的。两者相互区别，人们通过感官感知现象，而本质需要人的理性认识才能把握。本质决定现象，但本质也要通过现象表现。方法论：透过现象看本质。 人民群众人的本质是一切社会关系的总和。在社会历史发展过程中，人民群众起着决定性的作用。人民群众是社会历史实践的主体，是历史的创造者。具体来说，人民群众是物质财富的创造者，是精神财富的创造者，是社会变革的决定性力量。 人与自然自然界是人类社会存在的前提，是人类社会发展的自然基础。实践是使物质世界分化为自然界和人类社会的前提，也是两者统一的基础。客观规律制约着人们的实践活动。人能够发挥意识的能动作用，在尊重客观规律的基础上，合理的改造自然。 科学技术科学技术是推动社会发展的动力之一，但同时也是一把双刃剑。科学技术的作用受到一定客观条件的制约，所以一定要发挥主观能动性，推动科学技术对社会发展的正面推动作用。 联系的观点联系是是事物固有的，客观的，是不以人的意志为转移的，世界上的一切物质都处于普遍联系之中，事物的联系是通过中介来说实现的。所以我们要用联系的观点看问题，把握事物固有的联系。 发展的观点发展的实质是新事物的产生和旧事物的灭亡，所以我们要用发展的眼光看问题，将食物看作一个不断变化的过程 实践与认识实践是认识的来源，是认识发展的动力，是认识的目的，也是检验认识真理性的唯一标准。 感性认识与理性认识感性认识是认识的初级阶段，通过感觉知觉表象认识事物的外部联系。理性认识是认识的高级阶段，通过概念推理判断认识事物的内部联系。感性认识是直接的具体的，理性认识是间接的抽象的。 感性认识有待发展为理性认识。理性认识依赖于感性认识。在实际的认识过程中，感性认识与理性认识是相互交织相互渗透的，感性中包含着理性的因素，理性中也有感性的因素。 从感性认识到理性认识的飞跃，必须具备两个条件：一是勇于实践，深入调查，获取丰富的符合实际的感性材料。而是必须通过理性思考的作用，运用理性思维和科学抽象，将丰富的感性材料去粗取精，去伪存真，由表及里，由此及彼的加工制作。 意识的能动作用意识反应世界具有自觉性，意识活动具有目的性与计划性意识活动具有创造性，不仅反映事物的外部现象，而且可以反映事物的本质和规律意识具有指导实践改造客观世界的作用意识具有调控人的行为和生理活动的作用 真理与谬误1234567真理与谬误的概念 真理是人们对于客观事物及其发展规律的正确反映 谬误是人们对于客观事物及其发展规律的歪曲反映真理与谬误的辩证关系 区别：真理与谬误的区分在于认识是否如实的反映了客观事物 联系：真理和谬误又是统一的，他们可以相互转化。真理与谬误在一定的条件下是绝对对立的，超出了这个范围，谬误可以变成真理，真理也能变成谬误 毛中特中国之治坚持党的领导发挥中国之治的优势社会治理坚持和完善共建共治共享的适合治理制度是完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化的重要内容，是适应社会主要矛盾变化和建设人人有责，人人尽责、人人享有的社会治理共同体的必然要求，是防范化解风险、建设更高水平的平安中国的迫切需要。 社会主义协商民主的意义怎么发挥人民政协的作用污染防治的重要性（这个有点不一样）创新和实体经济史纲跳出历史周期律不忘初心牢记使命为啥子要伟大斗争、工程、事业（这个没背）站在新的历史起点上，为实现伟大梦想，必须进行伟大斗争。回顾我们党的历史，建立中国共产党，成立中华人民共和国，实行改革开放，推进新时代中国特色社会主义事业，都是在斗争中诞生、在斗争中发展、在斗争中壮大的。站在新的历史起点上，为实现伟大梦想，必须建设伟大工程。这个伟大工程，就是我们党正在深入推进党的建设伟大工程。站在新的历史起点上，实现伟大梦想，必须推进伟大事业。中国特色社会主义社会，是当代中国发展进步的旗帜，是改革开放以来党的全部理论和实践的追，是党和人民历尽千辛万苦、付出巨大代价取得的根本成就。 党三段论五四运动的意义思修人生价值爱国主义奋斗观新时代中国青年？网络生活（公共生活）法律权威社会公德和个人品德（没背）个人品德在社会道德建设中起着基础性作用，对道德和法律作用的发挥有着重要的推动作用，也是个体人格完善的重要标志，还是经济社会发展进程中重要的主体精神力量。 社会主义核心价值观（没背）社会主义核心价值观把涉及国家、社会、公民的价值要求融为一体，是对我们要建设什么样的国家、社会和公民等问题的深刻回答。弘扬社会主义核心价值观是坚持和发展中国特色社会主义的价值遵循，是提高国家文化软实力的迫切要求，也是增进社会团结的最大公约数。社会主义核心价值观不仅为新时代中国社会发展指明了前进方向和进步趋向，也为个人的人生问题提供了根本解答，为每个人的人生发展提供了基本遵循。 当代美国坏坏世界经济形势开放合作中国方案经济全球化为什么不可逆转（就当世界经济形式吧)新型国际关系文明交流（没背）不同文明是平等的，要尊重文明的差异性、独立性和多样性。文明因多样而交流，因交流而互鉴，因互鉴而发展。各种文明应该交流互鉴、取长补短、美美与共。我们要加强世界上不同国家、不同民族、不同文化的交流互鉴，夯实共建亚洲命运共同体、人类命运共同体的人文基础。第一，坚持相互尊重、平等相待。第二，坚持美人之美，美美与共。第三，坚持开放包容、互学互鉴。第四，坚持与时俱进、创新发展。 肖四助记毛中特中国特色社会主义制度 制度的重要性 制度是关系党和国家事业发展的根本性、全局性、稳定性、长期性问题。中国特色社会主义制度是我国的根本制度 中国特色社会主义的制度优势 坚持把根本政治制度、基本政治制度同法律体系、基本经济制度和各方面体制机制有机结合起来 坚持把国家层面民主制度同基层民主制度有机结合起来 坚持把党的领导、人民当家作主、依法治国有机结合起来 既坚持了社会主义的根本性质，又借鉴了古今中外制度建设的有益成果 实践证明 我们党领导人民创造了经济快速发展和社会长期稳定两个奇迹，中华民族迎来了从站起来富起来到强起来的伟大飞跃。中国特色社会主义制度为政治稳定、经济发展、文化繁荣、民族团结、人民幸福、社会安宁、国家统一提供了有力保障 党的领导重要性 党的领导制度的地位 党的领导制度是我国的根本领导制度。 健全党的领导制度，事关坚持和完善中特制度、推进国家治理体系和治理能力现代化的根本方向和根本保证 党的领导是最高政治领导力量。在国家治理体系中，党纵然全局、协调各方的领导制度体系居于统领地位 坚持和完善党的领导制度的原因 党的领导是中国特色社会主义最本质的特征，是中国特色社会主义制度最大的优势。 党是中国特色社会主义制度的创建者；党的领导是充分发挥中国特色社会主义值得的根本保障；党的自身优势是中国特色社会主义制度优势的主要来源 健全党的全面领导制度，是马克思主义建党学说和国家学说揭示的科学真理，也是新时代统揽 “四个伟大” 战胜各种风险挑战的必然要求 我国国家制度和治理体系的显著优势中最主要的是坚持党的集中统一领导 党的领导地位是历史和人民的选择，也是实现中华民族伟大复兴的必然要求 怎么发挥中国之治的优势 要坚持中国共产党领导这个最大优势毫不动摇，把党的领导落实到国家治理各领域个方面各环节。 巩固和发展已经取得的制度优势，补齐制度短板 提升制度执行能力。制度的生命力在于执行。 怎么打好三大攻坚战 打好三大攻坚战是为了顺利进行全面小康社会的建设，推动经济社会持续健康发展 坚决打好防范化解重大风险攻坚战。全面建成小康社会的前进道路诸多矛盾叠加、风险隐患很多，如果应对不好，就会延误甚至中断全面建设小康社会的进程 坚决打好精准脱贫攻坚战。全面小康，覆盖人口要全面，是惠及全体人民的小康；覆盖区域要全面，史称相聚于共同发展的小康。虽然全面小康不是人人同样的小康，但没有农村地区贫困人口的脱贫、致富，就没有全面建成小康社会。 坚决打好污染防治攻坚战。全面小康，是五位一体全面进步的小康，要求覆盖的领域要全面。污染问题已经成为全面小康社会的明显短板。环境问题是全面建成小康社会能否得到人民认可的一个关键。 实施乡村振兴战略的原因 原因：全面小康和建设社会主义现代化强国，最艰巨最繁重的任务在农村，最广泛最深刻的基础在农村，最大的潜力和后劲也在农村 重要性：1. 做好三农工作的总抓手 2. 社会主要矛盾变化的必然要求 3. 实现两个一百年奋斗目标的必然要求 4.. 着眼于实现党的使命 5. 着眼于为全球解决乡村问题贡献中国智慧和中国方案 污染防治是重要关口的原因 错误的发展思路：我国经济有高速增长阶段转向高质量发展阶段的过程中，经济发展会遇到一些困难，很容易出现以牺牲环境换取经济增长的念头。 正确的发展思路：从根本上说，保护生态环境和发展经济是有机统一、相辅相成的。纵观人类文明发展史，生态兴则文明兴，生态衰则文明衰，顺应自然、保护生态的绿色发展昭示着未来。绿水青山就是金山银山。 结论：所以，必须保持加强生态环境保护建设的定理，跨越污染防治和环境治理这一重要的关口，探索高质量发展的路子。 实体经济 实体经济是一国经济的立身之本、财富之源，是国家强盛的重要支柱，是现代化经济体系的坚实基础。 制造业是实体经济的基础。抓实体经济一定要抓好制造业，制造业高质量发展是我国经济高质量发展的重中之重。 一个国家要提高国际竞争力，归根到底要看实体经济。我国是个大国，必须发展实体经济，不断推进工业现代化、提高制造业水平。 创新 一个国家和民族的创新能力，从根本上影响甚至决定国家和民族的前途命运。国际竞争新优势也越来越体现在创新能力上，谁在创新上先行一步，谁就能拥有引领发展的主动权。 我国经济总量跃居世界第二，但大而不强的问题相当突出，主要体现在创新能力不强，总体来看，我国关键核心技术受制于人的局面尚未根本改变。要把我国的制造业和实体经济搞上去，就必须坚持创新驱动发展战略。把创新作为发展的核心，是分析近代以来世界发展历程特别是我国改革开放成功实践得出的结论。 坚持创新发展是我们应对发展环境变化、增强发展动力、把我发展主动权、更好引领发展新常态的根本之策。 区域协调 这是新发展理念的要求。协调是持续健康发展的内在要求 建设现代化经济体系的需要 解决当前我国发展中不平衡、不协调、不可持续的突出问题的重要途径 对外开放 对外开放是我国的基本国策，以开放促改革促发展是我国现代化建设不断取得新成就的重要法宝。全面开放是实现国家繁荣富强的根本出路。开放是新发展理念的重要内容，是国家繁荣富强的必由之路。 着力发展开放性经济，是建设现代化经济体系、提高国际竞争力的要求。扩大对外开放是中国主动参与和推动经济全球化进程，推动构建开放性世界经济的需要。 是中国改革发展客观需要做出的自主选择，有利于推动经济高质量发展，有利于满足人民对美好生活的向往，有利于世界和平、稳定、发展。 改革、发展、稳定的论证两大奇迹 中国国家制度和国家治理体系，是我们党领导人民创造经济快速发展和社会长期稳定的 “两大奇迹 “根本保障所在 改革发展稳定是我国社会主义现代化建设的三个重要支点。改革是经济社会发展的强大动力，发展史解决一切经济社会问题的关键，稳定是改革发展的前提。 坚持把改革的力度、发展的速度和社会可承受的程度统一起来，把改善人民生活作为正确处理改革、发展、稳定关系的结合点，在保持社会稳定中推进改革发展，通过改革发展促进社会稳定。 如何加强和创新社会治理 管理和制度：完善社会治理体系，创新社会治理体制 加强建设：加强社会心理服务体系建设 四个坚持：坚持系统治理，依法治理，源头治理，综合治理 重心下移：要把社会治理的中心向基层下移，落到城乡社区 社区是党和政府联系、服务居民群众的” 最后一公里 “，社区服务和管理能力越强，社会治理的基础就越实。 史纲新中国成立的意义中华民族伟大复兴的原因 / 必然性 顺应人民的需要：我们在历史前进的逻辑中前进。这个逻辑，就是人心向背的逻辑。前进征程上，顺应人民群众对美好生活的向往，始终与人民心心相映、同甘共苦 顺应和平发展的时代的需要：我们在时代发展的潮流中发展。顺应和平、发展、合作共赢的时代潮流，始终站在人类真理和道义的制高点。 民族复兴的需要：中华民族是历经磨难、不屈不挠的伟大民族，中国人民是勤劳勇敢、自强不息的伟大人民，中国共产党是勇于斗争、敢于胜利的伟大政党。 新时期创造中华民族伟大复兴的措施（腿姐） 坚持中国共产党的领导，党的领导是我们过去取得伟大成就，未来再创辉煌的根本保证。坚持人民主体地位，人民主体地位是我们不断创造新的历史伟业的根本所在。坚持中国特色社会主义道路。 五四运动的意义五四运动对中华民族伟大复兴三大里程碑的影响 五四运动是我国近现代史上具有里程碑意义的重大事件。建立中国共产党、成立中华人民共和国，推进改革开放和社会主义伟大事业，是五四运动以来我国发生的三大历史性实践，是近代中华民族伟大复兴的三大里程碑。 腿姐 + 实现了自鸦片战争以来第一次全面觉醒。在中国共产党的领导下，中国人民进行了艰苦卓绝的斗争，取得了新民主主义革命的胜利，成立了中华人民共和国，建立了社会主义制度。推进改革开放和中国特色社会主义事业。 五四精神五四运动孕育了爱国进步民主科学的伟大爱国主义精神。五四运动以全民族的行动激发了追求真理、追求进步的伟大觉醒。以全民族的搏击培育了永久奋斗的伟大传统。体现了中国人民和中华民族近代以来追求的先进价值观，深深积淀在中华民族的民族精神和时代精神中，成为中国共产党领导革命、建设、改革的精神动力。 不忘初心，牢记使命（这个再看下答案）如何跳出” 历史周期律 “，实现长期执政（腿姐）进入中国特色社会主义新时代，面临复杂的国内外环境和世情、国情、党情的深刻变化，中国共产党作为执政党，肩负着国家和民族兴旺发达的历史重任。因此，必须更加坚持党要管党，从严治党，不断在自我革命中保持为人民谋幸福、为民族谋复兴的初心和使命。只有坚持全面从严治党，确保党始终成为中国特色社会主义事业的领导核心，最终跳出历史周期律，实现中华民族的伟大复兴。 第一届全国政协会议的内容及意义，人民选择党的建国方案的原因 中国人民政治协商会议第一届全体会议，代行全国人民代表大会职权，为新中国诞生做了全面准备。会议通过了具有临时宪法性质的《中国人民政治协商会议共同纲领》等文件，确立人民民主专政为新中国国体，人民代表大会制度为新中国整体。这说明中国共产党的建国方案最终成为中国人民的共同选择。 地主阶级和买办性的大资产阶级由于违背了中国人民的根本利益，受到了广大中国人民的唾弃。民族资产阶级的建国方案由于脱离中国实际，也没有得到广大人民群众的拥护。只有中国共产党提出了关于建立人民共和国的方案，逐步获得了工人、农民、城市小资产阶级乃至民族资产阶级及其政治代表的拥护。 人民政协制度的优势人民政协制度的创造历程（看答案） 优势：这一制度强调中国共产党的领导，强调发扬社会主义民主，产生于近代以来中国人民革命的伟大斗争，植根于中国丰厚的历史文化，不仅符合当代中国实际，二七符合中华民族一贯倡导的天下为公、兼容并蓄、求同存异等优秀文化传统，是政治制度上的伟大创造。 社会主义协商民主的内容及地位全过程的民主是相对于形式主义民主而言的。（徐涛协商民主内容 + 重要性）全过程民主体现的是有事多商量，遇事多商量，做事多商量，这正是人民民主的真谛。 思修家国情怀中国人自古以来就具有家国情怀。在家尽孝、为国尽忠是中华民族的优良传统，也体现了家国情怀” 爱家 “和” 爱国 “的一致性。家是国的基础，国是家的延伸。国是第一位的，没有国就没有家，没有国家的统一强盛，就没有家庭的美满和个人的幸福。只有千家万户都好，国家才能好，民族才能好。我们要在全社会大力弘扬家国情怀，提倡爱国和爱家相统一。 爱国为什么是本分、职责爱国主义是调节个人与祖国之间关系的道德要求、政治原则和法律规范，是中华民族精神的核心。爱国是每个人都应当自觉履行的责任和义务。（个人）爱国主义体现了人们对自己祖国的深厚感情，揭示了个人对祖国的依存关系，是人们对自己家园以及民族和文化的归属感、认同感、尊严感与荣誉感的统一，是中华儿女最自然，最朴素的情感。（民族）爱国主义是中华民的民族心、民族魂，是中华民族团结奋斗、自强不息的精神纽带和最重要的精神财富，是中国人民和中华民族维护民族独立和民族尊严的强大精神动力。 做新时代的爱国者只有坚持爱国、爱党和爱社会主义相统一，爱国主义才是鲜活的、真实的，这是当代中国爱国主义的本质，也是当代中国爱国主义精神最重要的体现。必须坚持个人奋斗目标与国家、民族的奋斗目标相统一，把个人理想融入社会理想中。必须把国家的安全、荣誉、利益放在高于一切的位置，始终做到爱国的深厚情感、理性认识和实际行动相统一，与祖国同呼吸共命运，才是真正的爱国者。 科学高尚的人生追求… 体现了人生自我价值与社会价值的统一。人生自我价值与社会价值，二者既相互区别，又密切联系。自我价值的实现是个体为社会创造更大价值的前提，社会价值的实现是个体自我完善、全面发展的保障。人生价值的评价尺度要看一个人的实践活动是否符合社会发展的客观规律，是否促进了历史的进步。在今天，衡量人生价值的标准，就是要看一个人是否为国家和社会真诚奉献，为人民群众真心服务。 如何弘扬奉献精神“服务人民、奉献社会” 是科学高尚的人生追求。要在自己的工作岗位上，兢兢业业的为社会和他人做贡献，奉献社会，这是社会主义职业道德的最高层次要求。要无私奉献、一心为公，这是集体主义的最高层次要求。要想英雄模范学习，弘扬他们身上忠诚、执着、朴实的鲜明品格。 奋斗的青春是最亮丽的底色（腿姐）奋斗本身也是一种幸福，只有奋斗的人生才称得上幸福的人生，只有在为社会做贡献、为他人服务的过程中，才能实现个人幸福与社会进步的相互促进。中国社会发展，中华民族振兴，中国人民幸福，必须依靠自己的英勇奋斗来实现。 服务人民，奉献社会确立服务人民，奉献社会的人生追求 有利于清楚的把握人的生命历程和奋斗目标，深刻理解了为什么而活，应走什么样的人生之路等道理。有利于以正确的人生态度对待人生、解决实际生活中的各种问题。有利于掌握正确的人生价值标准，懂得人生的价值首先在于奉献。 如何走好新时代的长征路红色基因的重要性：井冈山精神等红色精神中蕴含的革命力量，都是中国共产党领导全体人民实现民族独立、人民解放的精神支撑和思想武器，对于我们走好新时代长征路和实现中华民族的伟大复兴有着重要的现实意义。 从红色基因中汲取力量的做法：要从红色基因中汲取 1. 坚持社会主义、共产主义理想和信念的不屈不挠的精神 2. 全心全意为人民服务的力量 3. 把革命利益放在首位的力量 4. 修身自律，保持节操的力量 5. 设立社会新风，建立新型人际关系的力量。 扣好人生第一粒扣子人的成长和全面发展，离不开正确价值观的引领。而青少年时价值观形成和确立的关键时期。这就像穿衣服扣扣子一样。。。正确的价值观能够引导青年把人生价值追求融入国家和民族事业，始终站在人民大众立场，同人民一道拼搏、同祖国一道前进，服务人民，奉献社会，努力成为中国特色社会主义事业的合格建设者和可靠接班人。 维护公共秩序重要性：1. 公共生活需要公共秩序。2. 有序的公共生活，不仅是社会生产活动的重要基础与提高社会成员生活质量的基本保障，而且是社会文明的重要标志。3. 社会公德作为社会公共生活应当遵守的行为准则，在维护公共秩序方面有着重要的作用。 要求：每一个社会成员都应遵守文明礼貌、助人为乐、爱护公物、保护环境、遵纪守法为主要内容的社会公德，实行垃圾分类，是保护环境遵纪守法的要求，也是每个社会成员都应当遵守的。 道德和法律法律发挥作用以国家强制力为后盾，主要依靠法律的预测作用，惩罚作用，威慑作用和预防作用对公民和社会组织的行为进行约束，并对违反法律的行为追究法律责任。道德发挥作用通过人们的内心信念、传统习俗、社会舆论，对公民和社会组织进行道德教化，并对违反道德的行为进行道德谴责。 如何做：国家、政府、个人 法律权威法律权威时指法律在社会生活中的作用力、影响力和公信力，是法律应有的尊严和声明。法治思维的首要内容是法律至上，即哎国家或社会的所有规范中，法律是地位最高、效力最广、强制力最大的规范。 尊重和维护法律权威，是社会主义法制观念的核心要求和建设社会主义法治国家的前提条件。是实现人民意志，维护人民利益，保障人民权利的基本途径，是维护个人合法权益的根本保障。全体社会成员尊重社会主义法律权威，不仅是保证法律发挥作用的基本前提要求，也是保障个人平安幸福的底线红线。尊重和维护法律权威，对全面依法治国至关重要。 做个小整合“中国之治” 的制度 “密码”（制度优势）制度是关系党和国家事业发展的根本性、全局性、稳定性、长期性问题。中国特色社会主义制度是我国的根本制度，是党和人民在长期实践探索中形成的科学制度体系，我国国家治理一切工作和活动都依照中国特色社会主义制度展开，我国国家治理体系和治理能力是中国特色社会义制度及其执行能力的集中体现。 中国特色社会主义制度和国家治理体系是以马克思主义为指导、植根中国大地、具有深厚中华文化根基、深得人民拥护的制度和治理体系，是具有强大生命力和巨大优越性的制度和治理体系，是能够确保拥中华民族实现两个一百年奋斗目标进而实现伟大复兴的制度和治理体系。中国特色社会主义制度和国家治理体系，是两大奇迹的根本保障所在，是中国之治的制度密码所在，也是坚定四个自信的基本依据所在。中华民族迎来了从站起来富起来到强起来的伟大飞跃，为中国的政治稳定、经济繁荣、民族团结、人民幸福、社会稳定、国家统一提供了有力保障。 如何将制度优势转化为治理效能要毫不动摇坚持和巩固中国特色社会主义制度，与时俱进完善和发展中国特色社会主义制度和国家治理体系。党的领导是中国特色社会主义最本质的特征和最大的制度优势，也是坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化最根本的政治保证。其次，要提高制度的执行能力，制度的生命力在于执行；要巩固和发展已经取得的优势，补齐制度短板。坚持党的领导、人民当家作主和依法治国有机统一，坚持根本政治制度、基本政治制度、基本经济制度、法律体系的等重要制度有机统一。 只要朝着坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化的总体目标努力，我们就一定能制度更加成熟更加定型，让发展更有质量，让治理更有水平，让人民更有获得感。为实现 “两个一百年” 奋斗目标、实现中华民族伟大复兴的中国梦提供有力保证。 坚持党的集中统一领导党的领导制度是我国的根本领导制度。是中国特色社会主义最本质的特征和最大的制度优势。健全党的领导制度是马克思主义建党学说和国家学说揭示的科学真理，也是新时代统揽 “四个伟大”、战胜各种风险挑战的必然要求，是坚持和完善中国特色社会主制度、推进国家治理体系和治理能力现代化的根本方向和根本保证。我国国家制度和治理体系有着显著优势，其中最主要的是坚持党的集中统一领导。党的领导地位是历史和人民的选择，也是实现中华民族伟大复兴的必然要求。 社会治理共同体社会治理是国家治理的重要领域，社会治理现代化是国家治理体系和治理能力现代化的题中应有之义。必须创新社会治理理念和社会治理体制，打造共建共治共享的社会治理格局，建设人人有责、人人尽责、人人享有的社会治理共同体。坚持系统治理，依法治理，源头治理，综合治理。不断推进社会治理的中心向基层下移，落到城乡社区。（社区是党和政府联系、服务居民群众的” 最后一公里 “）。坚持和完善共建共治共享的社会治理制度是完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化的重要内容，是适应社会主要矛盾变化的必然要求，是防范化解风险、建设更高水平的平安中国的迫切需要。 打好三大攻坚战（全面小康）坚决打好防范化解重大风险攻坚战。全面小康前进的道路上，风险阻碍很多，如果处理不好就会延误甚至终端全面小康的进程。必须增强忧患意识和底线思维，积极采取有效措施。坚决打好精准脱贫攻坚战。全面小康，覆盖的人口要全面，是惠及全体人民的小康；全面小康，覆盖的区域要全面，是城乡区域共同发展的小康。虽然全面小康不是人人同样的小康，但只有农村地区贫困人口的脱贫致富，才有全面建成小康社会。坚决打好污染防治攻坚战。全面小康，覆盖的领域要全面，是五位一体全面进步的小康。污染问题已经成为全面小康的明显短板，环境问题是全面小康能否得到人民认可的一个关键。 污染防治（生态保护）我国经济由高速增长阶段转向高质量发展阶段转变的过程中，经济发展会遇到一些困难，很容易出现以牺牲环境换取经济增长的念头。解决好环境治理问题，是加强生态文明建设的当务之急和改善环境民生的迫切需要。生态兴则文明兴，生态衰则文明衰。保护生态环境和发展经济是有机统一、相辅相成的。顺应自然、保护生态的绿色发展是走向未来的必由之路（绿水青山就是金山银山）。生态环境是关系党的使命宗旨的重大政治问题，也是关系民生的重大社会问题。生态文明建设是事关中华民族永续发展的千年大计，关系人民福祉，关乎人民未来，功在当代，利在千秋。必须树立和践行绿水青山就是金山银山的理念，坚持节约资源保护环境的基本国策，形成人与自然和谐发展新格局。 文化自信文化自信源自于中国优秀传统文化所蕴含的强大文化基因。中华民族有着深厚的文化传统，形成了富有特色的思想文化体系，体现了中国人民几千年来的知识智慧和理性思辨。这是中华民族特有的优势。中华文化走出去，从踏上国际舞台、展现亮点，到初具规模，产生影响，体现了中华文化的独特视角。走出去的中华文化，有利于让世界认识和理解一个历史悠久、发展迅速的现代中国。坚持文化自信，才能彰显文化强国的感召力，才能不断的融入世界。只有对自己的文化有自信，才能获得坚守的从容，鼓起奋发进取的勇气，焕发创新创造的活力。文化立世，文化兴邦。大力推进中华文化走出去，才能为我国外交、经济和影响力的扩展提供更为安全的软保护，提供更为有利的软环境，为我们的强国自信提供更为基础更深沉更持久的力量。 文化是一个国家、一个民族的灵魂，是人民的精神家园，也是政党的精神旗帜，文化兴国运兴，文化强国运强。文化自信是一个国家、一个民族发展中更基本、更深沉、更持久的力量。没有高度的文化自信，就没有文化的繁荣兴盛，就没有中华民族的伟大复兴。坚定文化自信，是事关国运兴衰、事关文化安全、使馆民族精神独立性的大问题。当今时代，文化在综合国力竞争中的地位日益重要，谁占据了文化发展的制高点，谁就能更好的在激烈的国际竞争中掌握主动权。 政府和市场的关系市场的作用：市场配置资源是最有效率的形式；政府的作用：保持宏观经济稳定、保障公平竞争、规范市场行为、促进共同富裕、维护市场秩序、推动可持续发展，弥补市场失灵。 发挥市场在资源配置中的决定性作用，完善市场机制，打破行业垄断、进入壁垒、区域保护，增强企业对市场需求变化的反映和调整能力，提高企业资源要素配置的效率和竞争力；发挥政府的调节作用，用改革激发市场活力，用政策引导市场预期，用规划明确投资方向，用法治规范市场行为 新中国成立 70 周年的意义中华人民共和国的成立，使得中国人民从此站起来，彻底改变了近代中国积贫积弱、受人欺凌的悲惨命运，实现了中国从几千年封建专制政治像人民民主的伟大飞跃，中国历史由此开辟了一个新纪元。帝国主义压迫中国、奴役中国人民的历史就此结束；本国封建主义、官僚资本主义统治的历史就此结束；军阀割据、战乱频仍、匪患不断的历史就此结束；从根本上改变了中国社会发展的方向，为新民主主义社会向社会主义社会的过度创造了条件；中国共产党成为全国范围内的政党。这是马克思主义同中国具体实际相结合的伟大胜利。 新时代的中国青年怎么做新时代有新使命和新担当，作为新时代的青年，要在新时代改革开放的广阔天地的实践中树立服务人民、奉献社会的理想和价值观，将社会主义核心价值观融入日常生活中，积极参与社会实践，在服务人民、奉献社会的事件中创造有意义的人生，创造无悔的青春。 乡村振兴三农问题是关系国计民生的重要问题。全面建成小康社会，最艰巨最繁重的任务在农村，最广泛和最深厚的基础在农村，最大的潜力和后劲也在农村。实施乡村振兴战略，是解决我国社会主要矛盾、实现两个一百年计划、实现中华民族伟大复兴的必然要求。 实施乡村振兴战略，是做好三农工作的总抓手，是建设现代化经济体系的重要基础，是建设美丽中国的关键举措，是传承中华传统文化的有效途径，是健全现代治理格局的固本之策，是实现全体人民共同富裕的必然要求。 必须坚持走中国特色社会主义乡村振兴之路，巩固和完善农村经营制度，深化农村土地改革，完善承包地三权分置制度，保持承包地关系长久不变，在第二轮土地承包到期后在延长三十年，深化集体产权制度改革。完善现代农业产业体系、生产体系、经营体系，完善农业社会化服务体系。促进农村一二三产业融合，健全自治、法治和德治相结合的农村治理体系。 不忘初心、牢记使命（跳出历史周期律）（跳出历史周期律）中国特色社会主义进入新时代，面临复杂的国内外环境和世情、国情党情的深刻变化，我们党肩负着实现中华民族伟大复兴的历史重任。在新时代，我们党必须以党的自我革命来推动党领导人民进行的伟大社会革命。 （不忘初心、牢记使命）中国特色社会主义进入新时代，我们比历史上任何时期都更接近、更有信心和能力实现中华民族伟大复兴。我们取得的成就举世瞩目，这值得我们自豪，但决不能因此而自满。 （总）新时代做到不忘初心、牢记使命，关键是要有正视问题的自觉和刀刃向内的勇气，必须坚持自我净化、自我完善、自我革命、自我提高，坚持党要管党，从严治党，不断在自我革命中保持为人民谋幸福、为民族谋复兴的初心和使命。只有坚持全面从严治党，确保党始终成为中国特色社会主义事业的领导核心，把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起风浪考验的马克思主义政党，才能跳出历史周期律，实现中华民族的伟大复兴。 五四运动（五四精神）五四运动是我国近现代史上具有里程碑意义的重大事件。五四运动是一场以先进知识分子为先锋、广大人民群众参与的彻底的反帝反封建的伟大爱国运动；是一场中国人民为拯救民族危亡、捍卫民族尊严、凝聚民族力量而掀起的伟大社会革命运动，是一场传播新思想新文化的伟大思想启蒙运动和新文化运动。五四运动促进了马克思主义同中国工人运动的结合，为中国共产党的成立做了思想上干部上的准备，为新的革命力量，革命文化、革命斗争登上历史舞台创造了条件。实现了中国人民和中华民族自鸦片战争以来的第一次全面觉醒。五四运动后，在中国共产党的领导下人民取得了新民主主义革命的胜利，成立中华人民共和国，建立了社会主义制度，推进改革开放和中国社会主义伟大事业，是五四运动以来我国发生的三大历史性事件，是近代中华民族伟大复兴的三大里程碑。 五四运动孕育了爱国进步民主科学的伟大爱国主义精神，其核心是爱国主义精神。五四运动以全民族的行动激发了追求真理、追求进步的伟大觉醒。以全民族的搏击培育了永久奋斗的伟大传统。以爱国主义为核心的民族精神，是中华民族团结奋斗自强不息的精神纽带，是中国共产党领导革命、建设、改革的精神动力。 开放合作中国的发展离不开世界，世界的发展也离不开中国。中国的发展是世界的机遇，中国是经济全球化的受益者，更是贡献者。中国不断扩大对外开放，不仅发展了自己，也造福了世界，开放已经成为当代中国的鲜明标识。回顾历史，开放合作是增强国际经贸活力的重要动力。立足当今，开放合作是推动世界经济稳定复苏的现实要求。面向未来，中国扩大对外开放的决心没有变，中国开放的大门不会关闭，只会越开越大。中国将始终促进贸易和投资自由化便利化，旗帜鲜明反对保护主义、单边主义，提升多边和双边开放水平，推动经济全球化朝着更加开放、包容、普惠、平衡、共赢的方向发展。建设开放型世界经济，构建人类命运共同体。 一带一路“一带一路” 秉持共商共建共享的原则，以丝绸之路精神为指引，推动构建了人类命运共同体的实践平台。共建 “一带一路” 顺应了全球治理体系变革的内在要求，彰显了同舟共济、权责共担的命运共同体意识，为完善全球治理体系变革提供了新思路新方案。共建 “一带一路。为世界经济增长开辟了新空间，为国际贸易和投资搭建了新平台，为完善全球经济治理拓展了新实践，为增进各国民生福祉作出了新贡献，成为共同的机遇之路、繁荣之路。中国愿同各方一道，以绘制 “工笔画” 精神共同推动共建” 一带一路 “合作走深走实、行稳致远、高质量发展，开创更加美好的未来。 服务人民、奉献社会确立服务人民，奉献社会的人生追求，有利于清楚的把握人的生命历程和奋斗目标，深刻理解人为什么而活，应走什么样的人生之路等道理；有利于以正确的人生态度对待人生、解决实际生活中的各种问题；有利于掌握正确的人生价值标准，懂得人生的价值首先在于奉献。“服务人民、奉献社会” 是科学高尚的人生追求。要在自己的工作岗位上，兢兢业业的为社会和他人做贡献，奉献社会，这是社会主义职业道德的最高层次要求。要无私奉献、一心为公，这是集体主义的最高层次要求。要向英雄模范学习，弘扬他们身上忠诚、执着、朴实的鲜明品格。 革命道德、社会公德、个人品德红色基因中蕴含的革命道德，是党领导人民实现民族独立人民解放的精神支撑和思想武器。有利于加强和巩固社会主义和共产主义的理想与信念，有利于培育和践行社会主义核心价值观，有利于引导人们树立正确的道德观、培育良好的社会道德风尚。 个人品德在社会道德建设中起着基础性作用，对道德和法律作用的发挥有着重要的推动作用，也是个体人格完善的重要标志，还是经济社会发展进程中重要的主体精神力量。 1. 公共生活需要公共秩序 2. 有序的公共生活是社会生产活动的重要基础，是提高社会成员生活质量的基本保障，更是社会文明的重要标志。3. 社会公德是每一个社会成员都应当遵守的行为准则，在维护公共秩序方面有着重要的作用。 回答怎么做：道德和法律、国家社会公民 史纲万能结尾实践证明，新中国成立以来，我们党把马克思主义基本原理同中国具体实际结合起来，在古老的东方大国建立起保证亿万人民当家作主的新型国家制度，使中国特色社会主义制度成为具有显著优越性和强大生命力的制度，保障我国创造出经济快速发展、社会长期稳定的奇迹，也为发展中国家走向现代化提供了全新选择，为人类探索建设更好社会制度贡献了中国智慧和中国方案。 马原启示万能模板我们应该用联系的、发展的、全面的观点看待问题，学习和运用矛盾分析法，坚持两点论和重点论的统一，透过现象看本质，在把握事物规律性的基础上充分发挥人的主观能动性，不断创新，把握机遇，善于从偶然中发现必然。同时还要注重实践，坚持一切从实际出发，实事求是，在实践中坚持和发展真理。不断推动认识的深化发展，将改造主观世界与改造客观世界相结合，做到认识和实践历史的、具体的统一。 真的是最后补充怎么衡量制度和治理优势“衡量一个社会制度是否科学、是否先进，主要看是否符合国情、是否有效管用、是否得到人民拥护。“一个国家选择什么样的治理体系，是由这个国家的历史传承、文化传统、经济社会发展水平决定的，是由这个国家的人民决定的。我国今天的国家治理体系，是在我国历史传承、文化传统、经济社会发展的基础上长期发展、渐进改进、内生性演化的结果。” 理想信念的作用理想信念是精神之钙。理想信念昭示奋斗目标、提供前进动力、提高精神境界。 为什么要坚持中国特色社会主义道路第一，中国特色社会主义道路是党和人民历尽千辛万苦、付出巨大代价开辟出来的，是一条符合中国国情、顺应时代潮流、得到人民群众拥护支持的正确道路。 第二，中国特色社会主义道路，既坚持以经济建设为中心，又全面推进经济、政治、文化、社会、生态文明建设以及其他各方面建设；既坚持四项基本原则，又坚持改革开放；既不断解放和发展社会生产力，又逐步实现全体人民共同富裕、促进人的全面发展。 第三，新中国成立 70 年来取得了 “当惊世界殊” 的伟大发展成就。中国特色社会主义道路是中国能够不断发展稳定的最根本原因。实践证明，中国特色社会主义道路是一条既符合中国国情，又适合时代发展要求并取得巨大成功的唯一正确道路。 百年未有之大变局信仰法律和正确行使法律权利所谓法律 “是铭刻在公民们的内心里”，是指法律的权威源自人民的内心拥护和真诚信仰。要相信法律、信奉法律，树立崇尚法律、信仰法律的牢固观念，增强对法律的信任感、认同感。法律要发生作用，全社会都要信仰法法律，否则不可能建成法治社会 第一，法律权利与法律义务不可分割，相互依存。第二，法律权利与法律义务一律平等。第三，法律权利与法律义务互利互赢。正确刑事法律权利要求公民行使权利时应严格依据法律进行，以法律的相关规定为界限，超出这个边界就有可能侵犯到他人的权利或损害到国家、社会的利益。 文明冲突论文明冲突论会破坏世界文明沟通的桥梁，甚至威胁世界和平与发展的前景。不同文明是平等的，要尊重文明的差异性、独立性和多样性。文明因多样而交流，因交流而互鉴，因互鉴而发展。各种文明应该交流互鉴、取长补短、美美与共。我们要加强世界上不同国家、不同民族、不同文化的交流互鉴，夯实共建亚洲命运共同体、人类命运共同体的人文基础。第一，坚持相互尊重、平等相待。第二，坚持美人之美，美美与共。第三，坚持开放包容、互学互鉴。第四，坚持与时俱进、创新发展。 百年未有之大变局世界百年未有之大变局是习近平总书记站在人类历史进程的高度，以大国领袖的担当，对世界发展大势作出的重大战判断，在当前复杂变化的时代具有举旗定向的要意义。大变局尤为需要大国责任与担当，需要中，智慧与中国方案。中作为联合国常任理事国，承担着童要的大国责任与担当。中国将继续做世界和平的建设者、全球发展的贡献者、国际秩序的维护者，将继续高举推动构建人类命运共同体的旗帜，坚持开放共贏，同各国分享机遇，坚定贱行多边主义，秉持共商共建共享的全球治理观，稳步推进 “一带一路” 建设，在继续深化与各国互利合作之时不断彰显中国外交的道义精神，不断贡献中国智和力量。（中责任与担当） 背诵汇总马原同一性和斗争性12矛盾的同一性：矛盾双方相互依存相互贯通的的性质和趋势矛盾的斗争性：矛盾的对立面之间相互排斥相互分离的性质和趋势 123没有同一就没有斗争，没有斗争也没有同一斗争性寓于同一性之中，同一性通过斗争性来体现斗争性是无条件绝对的，同一性是有条件相对的 123456第一，矛盾双方相互依存，因此矛盾双方可以通过的对方的发展来使自己得到发展第二，矛盾双方相互包含，因此矛盾双方可以相互吸收有利于自身的因素得到发展第三，矛盾双方彼此相通，因此矛盾双方可以通过朝自己的对立面转化而得到发展第一，矛盾双方的斗争促进双方力量的变化，此消彼长，造成事物的两遍，为事物的质变创造必要条件第二，矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过度的决定性力量 1方法论：从对立中把握同一，从同一中把握对立。 普遍性和特殊性123矛盾的普遍性是指万事万物都有矛盾，矛盾无时不有，无处不在矛盾的特殊性：具体事物所包含的矛盾及矛盾的每一个方面都各有其特点具体表现为：不同事物矛盾不同、同一事物的矛盾在不同发展阶段不同，同一事物的不同矛盾和矛盾的不同方面不同 123矛盾的普遍性即共性，矛盾的特殊性即个性共性是无条件绝对的，个性是有条件相对的共性寓于个性之中，没有离开共性的个性，也没有离开个性的共性 1方法论:坚持事物共性与个性的统一，从个别中把握一般，举一反三，具体问题具体分析。 必然和偶然必然性和偶然性是对立统一的。偶然性中有必然，任何偶然的东西都必须受必然性制约。必然性中有偶然，偶然性是必然性的表现，为必然性开辟道路，在一定条件下两者可以相互转化。方法论：既要重视事物发展的必然性，把握事物发展的总趋势，又要善于从偶然中发现必然。 理性因素和非理性因素理性因素是指人的理性直观、理性思维。非理性因素是指人的情感和意志。理性因素具有指导解释和遇见作用，非理性因素具有激活驱动和控制作用。 现象和本质本质是事物的根本性质，是相对稳定的，藏于事物内部。现象是事物的外部联系和表面特征，是个别的具体的多变易逝的。两者相互区别，人们通过感官感知现象，而本质需要人的理性认识才能把握。本质决定现象，但本质也要通过现象表现。方法论：透过现象看本质。 人民群众人的本质是一切社会关系的总和。在社会历史发展过程中，人民群众起着决定性的作用。人民群众是社会历史实践的主体，是历史的创造者。具体来说，人民群众是物质财富的创造者，是精神财富的创造者，是社会变革的决定性力量。 人与自然自然界是人类社会存在的前提，是人类社会发展的自然基础。实践是使物质世界分化为自然界和人类社会的前提，也是两者统一的基础。客观规律制约着人们的实践活动。人能够发挥意识的能动作用，在尊重客观规律的基础上，合理的改造自然。 科学技术科学技术是推动社会发展的动力之一，但同时也是一把双刃剑。科学技术的作用受到一定客观条件的制约，所以一定要发挥主观能动性，推动科学技术对社会发展的正面推动作用。 联系的观点联系是是事物固有的，客观的，是不以人的意志为转移的，世界上的一切物质都处于普遍联系之中，事物的联系是通过中介来说实现的。所以我们要用联系的观点看问题，把握事物固有的联系。 发展的观点发展的实质是新事物的产生和旧事物的灭亡，所以我们要用发展的眼光看问题，将食物看作一个不断变化的过程 实践与认识实践是认识的来源，是认识发展的动力，是认识的目的，也是检验认识真理性的唯一标准。 感性认识与理性认识感性认识是认识的初级阶段，通过感觉知觉表象认识事物的外部联系。理性认识是认识的高级阶段，通过概念推理判断认识事物的内部联系。感性认识是直接的具体的，理性认识是间接的抽象的。 感性认识有待发展为理性认识。理性认识依赖于感性认识。在实际的认识过程中，感性认识与理性认识是相互交织相互渗透的，感性中包含着理性的因素，理性中也有感性的因素。 从感性认识到理性认识的飞跃，必须具备两个条件：一是勇于实践，深入调查，获取丰富的符合实际的感性材料。而是必须通过理性思考的作用，运用理性思维和科学抽象，将丰富的感性材料去粗取精，去伪存真，由表及里，由此及彼的加工制作。 意识的能动作用意识反应世界具有自觉性，意识活动具有目的性与计划性意识活动具有创造性，不仅反映事物的外部现象，而且可以反映事物的本质和规律意识具有指导实践改造客观世界的作用意识具有调控人的行为和生理活动的作用 真理与谬误12345真理是人们对于客观事物及其发展规律的正确反映谬误是人们对于客观事物及其发展规律的歪曲反映区别：真理与谬误的区分在于认识是否如实的反映了客观事物联系：真理和谬误又是统一的，他们可以相互转化。真理与谬误在一定的条件下是绝对对立的，超出了这个范围，谬误可以变成真理，真理也能变成谬误 毛中特中国之治 (制度优势、内涵意义、怎么发挥中国之治的优势)坚持党的领导创新、实体经济、对外开放、乡村振兴、区域协调人民政协、政协制度、协商民主（重要性、发挥人民政协的作用、协商民主的重要性和意义）社会治理（肖 +👇）坚持和完善共建共治共享的适合治理制度是完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化的重要内容，是适应社会主要矛盾变化和建设人人有责，人人尽责、人人享有的社会治理共同体的必然要求，是防范化解风险、建设更高水平的平安中国的迫切需要。 污染防治的重要性（肖 +👇）生态环境是关系党的使命宗旨的重大政治问题，也是关系民生的重大社会问题。生态文明建设是事关中华民族永续发展的千年大计，关系人民福祉，关乎人民未来，功在当代，利在千秋。必须树立和践行绿水青山就是金山银山的历年，坚持节约资源保护环境的基本国策，形成人与自然和谐发展新格局。 怎么打好三大攻坚战、改革发展稳定 史纲跳出历史周期律不忘初心牢记使命五四运动的意义、五四精神史纲三段论、中华民族伟大复兴的历史必然性为什么要进行伟大斗争、建设伟大工程、推进伟大事业站在新的历史起点上，为实现伟大梦想，必须进行伟大斗争。回顾我们党的历史，建立中国共产党，成立中华人民共和国，实行改革开放，推进新时代中国特色社会主义事业，都是在斗争中诞生、在斗争中发展、在斗争中壮大的。站在新的历史起点上，为实现伟大梦想，必须建设伟大工程。这个伟大工程，就是我们党正在深入推进党的建设伟大工程。站在新的历史起点上，实现伟大梦想，必须推进伟大事业。中国特色社会主义社会，是当代中国发展进步的旗帜，是改革开放以来党的全部理论和实践的追，是党和人民历尽千辛万苦、付出巨大代价取得的根本成就。 新中国成立的意义中国智慧和中国方案 思修人生价值、奋斗观、价值观爱国主义、做新时代的爱国者、家国情怀奉献精神（怎么做、意义）网络生活（公共生活、社会公德与个人品德👇）个人品德在社会道德建设中起着基础性作用，对道德和法律作用的发挥有着重要的推动作用，也是个体人格完善的重要标志，还是经济社会发展进程中重要的主体精神力量。 法律权威、道德和法律社会主义核心价值观社会主义核心价值观把涉及国家、社会、公民的价值要求融为一体，是对我们要建设什么样的国家、社会和公民等问题的深刻回答。弘扬社会主义核心价值观是坚持和发展中国特色社会主义的价值遵循，是提高国家文化软实力的迫切要求，也是增进社会团结的最大公约数。社会主义核心价值观不仅为新时代中国社会发展指明了前进方向和进步趋向，也为个人的人生问题提供了根本解答，为每个人的人生发展提供了基本遵循。 当代世界经济形势（经济全球化）、美国坏坏开放合作、一带一路、新型国际关系、人类命运共同体中国方案（时政模板）社会信息化的影响文明交流不同文明是平等的，要尊重文明的差异性、独立性和多样性。文明因多样而交流，因交流而互鉴，因互鉴而发展。各种文明应该交流互鉴、取长补短、美美与共。我们要加强世界上不同国家、不同民族、不同文化的交流互鉴，夯实共建亚洲命运共同体、人类命运共同体的人文基础。第一，坚持相互尊重、平等相待。第二，坚持美人之美，美美与共。第三，坚持开放包容、互学互鉴。第四，坚持与时俱进、创新发展。]]></content>
      <categories>
        <category>Postgraduate</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>政治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法总结（纯代码版）]]></title>
    <url>%2Fposts%2F42768.html</url>
    <content type="text"><![CDATA[线性表顺序表定义12345678#include &lt;iostream&gt;using namespace std;typedef int Elemtype_S;//顺序表struct SeqList{ Elemtype_S *data; int len;} 逆置123456789//逆置void Reverse(SeqList &amp;L){ Elemtype_S temp; for(int i=0;i&lt;L.len/2;i++){ temp = L.data[i]; L.data[i] = L.data[L.len-i-1]; L.data[L.len-i-1] = temp; }} 删除1234567891011121314//删除所有介于s和t之间的结点bool Delete_s_t(SeqList &amp;L,Elemtype_S s,Elemtype_S t){ if(L.len==0||s&gt;=t) return false; int count = 0; for(int i=0;i&lt;L.len;i++){ if(L.data[i]&gt;s&amp;&amp;L.data[i]&lt;t) count++; else L.data[i-count] = L.data[i]; } L.len -= count; return true;} 逆置的应用123456789101112131415//将a1,a2...am,b1,b2...bn交换为序列b1,b2..bn,a1,a2...amvoid Reverse(SeqList &amp;L,int left,int right){ if(left&gt;=right||right&gt;L.len) return; int mid = (left+right)/2; for(int i=0;i&lt;mid-left;i++){ Elemtype_S temp = L.data[i+left]; L.data[left+i] = L.data[right-i]; L.data[right-i] = temp; }}void Exchange(Seqlist &amp;L,int m,int n){ Reverse(L,0,m+n-1); Reverse(L,0,n-1); Reverse(L,n,m+n-1);} 链表定义12345678910111213141516171819#include &lt;iostream&gt;using namespace std;typedef int Elemtype_L;//链表struct LinkNode{ Elemtype_L data; //数据域 LinkNode *next;};struct LinkList{ //带头节点以及头尾指针的单链表 LinkNode *head; LinkNode *tail; int len;};//静态链表typedef struct Node{ Elemtype_L data; int next;}LinkNode[size]; 初始化123456//创造一个空的线性表void InitList(LinkList &amp;L){ L.len = 0; L.head = L.tail = new LinkNode; //(LinkNode*)malloc(sizeof(LinkNode)) L.head-&gt;next = NULL;} 查找12345678910111213//从第一个位置起查找与e匹配的数据元素，若存在则返回该数据元素的位置int LocateElem(LinkList &amp;L,Elemtype_L &amp;e, bool(*compare)(Elemtype_L &amp;a,Elemtype_L &amp;b)){ //函数指针 int i = 1; LinkNode *p = L.head-&gt;next; while(p&amp;&amp;!compare(p-&gt;data,e)){ i++; p = p-&gt;next; } if(i) return i; return 0;} 插入1234567891011121314151617//在单链表的第i个数据元素之前插入新的数据元素bool ListInsert(LinkList &amp;L,int i,Elemtype_L &amp;e){ if(i&lt;1||i&gt;L.len) return false; int k = 1; LinkNode *p=L.head,*q; q = new LinkNode; q-&gt;data = e; while(k&lt;i){ p = p-&gt;next; k++; } //p从头节点开始，因此指向第i-1个结点 q-&gt;next = p-&gt;next; p-&gt;next = q; L.len++; return true;} 删除1234567891011121314151617181920//在单链表中删除第i个数据元素并用数据变量e返回其值bool ListDelete(LinkList &amp;L,int i,Elemtype_L &amp;e){ //删除节点数据也可以通过函数返回值返回 if(i&lt;1||i&gt;L.len) return false; LinkNode *p=L.head,*q; int k = 1; while(k&lt;i){ p = p-&gt;next; k++; } q = p-&gt;next; p-&gt;next = q-&gt;next; if(q==L.tail) //如果删除是尾结点需要更改尾指针 L.tail = p; e = q-&gt;data; delete q; //delete释放指针指向的内存而不是指针本身占有的内存 q = NULL; //在delete后要习惯加上此操作防止出现野指针 L.len--; //注意头节点带长度信息，需要更新 return true;} 栈和队列栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;typedef int Elemtype_s;//顺序栈struct SqStack{ Elemtype_s *base; int top; int size;};//初始化void InitStack(SqStack &amp;s,int m){ s.top = 0; //有些教材设置成-1，注意区分 s.base = new Elemtype_s[m]; s.size = 0;}//销毁栈void DestroyStack(SqStack &amp;s){ delete[] s.base; s.top = 0; s.size = 0;}//判空bool StackEmpty(SqStack &amp;s){ return s.top==0;}//返回栈中元素个数int StackLength(SqStack &amp;s){ return s.top;}//获取栈顶元素bool GetTop(SqStack &amp;s,Elemtype_s &amp;e){ if(StackEmpty(s)) return false; e = s.base[s.top-1]; return true;}//入栈void PushStack(SqStack &amp;s,Elemtype_s e){ if(s.top&gt;=s.size){ //栈满的情况，需要额外的申请空间 Elemtype_s *newbase; newbase = new Elemtype_s[s.size+10]; for(int j=0;j&lt;s.top;j++) newbase[j] = s.base[j]; delete[] s.base; s.base = newbase; s.size = s.size+10; } s.base[s.top++] = e;}//出栈bool PopStack(SqStack &amp;s,Elemtype_s &amp;e){ if(StackEmpty(s)) return false; e = s.base[--s.top]; return true;} 队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;using namespace std;typedef int Elemtype_q;//队列的链式表示struct LinkNode{ Elemtype_q data; LinkNode *next;};struct LinkQueue{ LinkNode *front; LinkNode *rear; //就是一个带头尾指针的单链表};//初始化void InitQueue(LinkQueue &amp;Q){ Q.front = Q.rear = new LinkNode; Q.front = NULL;}//清空队列void ClrarQueue(LinkQueue &amp;Q){ LinkNode *p; while(Q.front-&gt;next!=NULL){ p = Q.front-&gt;next; Q.front-&gt;next = p-&gt;next; delete p; //这里保留了队列的头节点，和后面的销毁队列不同 } Q.rear = Q.front;}//销毁队列void DestroyQueue(LinkQueue &amp;Q){ ClrarQueue(Q); delete Q.front; Q.front = Q.rear = NULL; //防止野指针}//队列判空bool EmptyQueue(LinkQueue &amp;Q){ return Q.front==Q.rear;}//队列中元素个数int LengthQueue(LinkQueue &amp;Q){ LinkNode *p=Q.front-&gt;next; int i=1; while(p!=NULL){ i++; p=p-&gt;next; } if(i) return i; return 0;}//取队头元素的值Elemtype_q GetHead(LinkQueue &amp;Q){ return Q.front-&gt;next-&gt;data;}//取队尾元素的值Elemtype_q GetLast(LinkQueue &amp;Q){ return Q.rear-&gt;data;}//入队void EnQueue(LinkQueue &amp;Q,Elemtype_q e){ LinkNode *p; p = new LinkNode; p-&gt;data = e; Q.rear-&gt;next = p; p-&gt;next = NULL; Q.rear = p;}//出队bool DeQueue(LinkQueue &amp;Q,Elemtype_q &amp;e){ if(EmptyQueue(Q)) return false; LinkNode *p = Q.front-&gt;next; e = p-&gt;data; Q.front-&gt;next = p-&gt;next; if(p == Q.rear) Q.rear = Q.front; delete p; return true;} stack&amp;queue 头文件1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;//stack &lt;typename&gt; name//queue &lt;typename&gt; nameint main(){ stack &lt;int&gt; s; queue &lt;int&gt; q; for(int i=0;i&lt;5;i++){ s.push(i); //入栈 q.push(i); //入队 } s.pop();q.pop(); //注意pop操作没有返回值,s弹出4，q弹出0 cout&lt;&lt;"top s:"&lt;&lt;s.top()&lt;&lt;endl; //输出3 cout&lt;&lt;"front q:"&lt;&lt;q.front()&lt;&lt;endl; //输出1 cout&lt;&lt;"back q:"&lt;&lt;q.back()&lt;&lt;endl; //输出4 //此外两者都有empty()和size()操作 //比较难受的是不能取第i个位置的值} 树二叉链表定义12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;#define Maxsize 100typedef char Elemtype_t;struct BTNode{ Elemtype_t data; BTNode *lchild; BTNode *rchild; //int height; //height主要是为了后面的AVL树服务};//二叉链表初始化void InitBinaryTree(BTNode* &amp;T){ T = NULL;}//销毁二叉树void DestroyBinaryTree(BTNode* &amp;T){ if(T){ DestroyBinaryTree(T-&gt;lchild); DestroyBinaryTree(T-&gt;rchild); delete T; } T = NULL;} 遍历先序遍历1234567891011121314151617181920212223242526//先序遍历二叉树(递归)void PreorderTraverse(BTNode* T,void(*visit)(Elemtype_t &amp;e)){ if(T){ visit(T-&gt;data); PreorderTraverse(T-&gt;lchild,visit); PreorderTraverse(T-&gt;rchild,visit); }}//先序遍历二叉树(非递归)#include &lt;stack&gt;void PreorderTraverse2(BTNode* T,void(*visit)(Elemtype_t &amp;e)){ stack &lt;BTNode *&gt; s; BTNode *p=T; while(p||!s.empty()){ while(p){ visit(p-&gt;data); s.push(p); p=p-&gt;lchild; } if(!s.empty()){ p = s.top(); s.pop(); p=p-&gt;rchild //此处无需判断p是否有右孩子，若无则有置空p指针继续出栈的效果 } } } 中序遍历12345678910111213141516171819202122232425//中序遍历二叉树(递归)void MidorderTraverse(BTNode* T,void(*visit)(Elemtype_t &amp;e)){ if(T){ PreorderTraverse(T-&gt;lchild,visit); visit(T-&gt;data); PreorderTraverse(T-&gt;rchild,visit); }}//中序遍历二叉树(非递归)void MidorderTraverse2(BTNode* T,void(*visit)(Elemtype_t &amp;e)){ stack&lt;BTNode*&gt; s; BTNode *p = T; while(p||!s.empty()){ while(p){ s.push(p); p = p-&gt;lchild; } if(!s.empty()){ p = s.top(); s.pop(); visit(p-&gt;data); p = p-&gt;rchild; } }} 后序遍历12345678910111213141516171819202122232425262728293031323334//后序遍历二叉树(递归)void PostorderTraverse(BTNode* T,void(*visit)(Elemtype_t &amp;e)){ if(T){ PreorderTraverse(T-&gt;lchild,visit); PreorderTraverse(T-&gt;rchild,visit); visit(T-&gt;data); }}//后序遍历二叉树(非递归)//不同于先序和中序，后续的非递归要设置一个pre指针来指示是否已经访问过右子树void PostorderTraverse2(BTNode* T,void(*visit)(Elemtype_t &amp;e)){ stack&lt;BTNode*&gt; s; BTNode *p=T,*pre=NULL; while(p||s.empty()){ while(p){ s.push(p); p = p-&gt;lchild; } if(!s.empty()){ p = s.top(); if(p-&gt;rchild!=pre){ p = p-&gt;rchild; // s.push(p); //这两步加不加都一样，但有助于理解 // p = p-&gt;lchild; } else{ visit(p-&gt;data); pre = p; s.pop(); p = NULL; //将p置空，不能漏！ } } }} 层序遍历123456789101112131415//层序遍历void LevelOrder(BTNode* T,void(*visit)(Elemtype_t &amp;e)){ queue &lt;BTNode*&gt; q; BTNode *p; q.push(T); while(!q.empty()){ p = q.front(); q.pop(); visit(p-&gt;data); if(p-&gt;lchild!=NULL) q.push(p-&gt;lchild); if(p-&gt;rchild!=NULL) q.push(p-&gt;rchild); }} 深度123456789101112131415161718192021222324252627282930313233//求二叉树的深度（递归）int BinaryTreeDepth(BTNode* &amp;T){ if(T==NULL) return 0; int h1,h2; h1=BinaryTreeDepth(T-&gt;lchild); h2=BinaryTreeDepth(T-&gt;rchild); return h1&gt;h2?h1+1:h2+1;}//求二叉树的深度(非递归)//rear始终指向队列中的最后一个结点//front指向当前访问结点，last指向当前访问结点所在层的最后一个结点int BinaryTreeDepth2(BTNode* T){ int front,rear; front=rear=-1; int last,level; last=level=0; BTNode *Q[Maxsize],*p; Q[++rear]=T; while(front&lt;rear){ p = Q[++front]; if(p-&gt;lchild!=NULL) Q[++rear]=p-&gt;lchild; if(p-&gt;rchild!=NULL) Q[++rear]=p-&gt;rchild; if(front==last){ //front和last相等，即当前层所有结点已全部入队，last指向下一层最后一个结点 last = rear; level++; } } return level;}//同理，此方法也可用于解决二叉树的宽度问题 构建二叉树先序 + 中序123456789101112131415161718192021222324252627282930313233//按先序和中序次序建立二叉树//前提是二叉树中节点的数据不重复void CreateBinaryTree2(BTNode* &amp;T,Elemtype_t ch1[],Elemtype_t ch2[], int low,int high,int &amp;k){ int i; if(low&gt;high) T = NULL; else{ T = new BTNode; T -&gt;data = ch1[k]; for(i=low;i&lt;=high&amp;&amp;ch2[i]!=ch1[k];i++); if(ch2[i] == ch1[k]) { k++; //这个k没有为题，注意下面两行的递归k值实际是不一样的 CreateBinaryTree2(T-&gt;lchild,ch1,ch2,low,i-1,k); CreateBinaryTree2(T-&gt;rchild,ch1,ch2,i+1,high,k); } }}//另解//一般都会给出两个序列，下标搞不清楚的时候画一画//推荐这种写法，容易记BTNode* CreateBinaryTree3(Elemtype_t ch1[],Elemtype_t ch2[],int preL,int preR, int inL,int inR){ if(preL&gt;preR) return NULL; BTNode* T = new BTNode; T-&gt;data = ch1[preL]; for(int i=inL;i&lt;inR&amp;&amp;ch2[i]!=ch1[preL];i++); int num_left = i-inL; T-&gt;lchild = CreateBinaryTree3(ch1,ch2,preL+1,preL+num_left,inR,i-1); T-&gt;rchild = CreateBinaryTree3(ch1,ch2,preL+num+left+1,preL,i+1,inR); return T;} 中序 + 后序1234567891011BTNode* CreateBinaryTree4(Elemtype_t ch1[],Elemtype_t ch2[],int postL,int postR, int inL,int inR){ if(postL&gt;postR) return NULL; BTNode* T = new BTNode; T-&gt;data = ch1[postR]; for(int i=inL;i&lt;inR&amp;&amp;ch2[i]!=ch1[postR];i++); int num_left = i-inL; T-&gt;lchild = CreateBinaryTree4(ch1,ch2,postL,postL+num_left-1,inL,i-1); T-&gt;rchild = CreateBinaryTree4(ch1,ch2,postL+num_left,postR-1,i+1,inR); return T;} 中序 + 层序123456789101112131415161718192021222324252627282930313233//中序+层序Node* Create(int Layer[],int num,int inL,int inR){if(num==0){ return NULL;//子树数量为0时直接返回}Node* root=(Node*)malloc(sizeof(Node));//新建一个新的结点，用来存放当前二叉树的根节点int Left[1000]={0};int Right[1000]={0};//存放左右子树的层序遍历序列int Lnum=0,Rnum=0,k;//存放左右子树的层序遍历元素数量int i,j,isLeft;root-&gt;data=Layer[0];//新结点的数据域为根结点的值for(k=inL;k&lt;inR&amp;&amp;in[k]!=layer[0];k++)for(i=1;i&lt;num;i++){ isLeft=0; for(j=inL;j&lt;k;j++){ if(Layer[i]==in[j]){ isLeft=1; break; } } if(isLeft){ Left[Lnum++]=Layer[i]; }else{ Right[Rnum++]=Layer[i]; }}//区分层序遍历中的左右子树//返回左子树的根节点地址，赋值给root的左指针root-&gt;lchild=Create(Left,Lnum,inL,k-1);//返回右子树的根节点地址，赋值给root的右指针root-&gt;rchild=Create(Right,Rnum,k+1,inR);return root;} 打印 x 的祖先12345678910111213141516171819202122232425262728293031//打印结点值为x的所有祖先节点//采用后序遍历的方法，当访问到x时栈中元素即为x的祖先节点//此方法可以拓展到找p和q最近的公共祖先节点void Search_ancestor(BTNode* T,Elemtype_t &amp;x,void(*visit)(Elemtype_t &amp;e)){ BTNode *p=T,*pre=NULL; stack &lt;BTNode*&gt; S; while(p||!S.empty()){ if(p){ if(p-&gt;data!=x){ S.push(p); p = p-&gt;lchild;} else { while(!S.empty()){ p = S.top(); visit(p-&gt;data); S.pop();} return;} } else{ p=S.top(); if(p-&gt;rchild&amp;&amp;p-&gt;rchild!=pre) p = p-&gt;rchild; else{ S.pop(); pre = p; p=NULL;} } } return;} 查找指定结点12345678910111213141516171819202122232425//返回二叉树中元素值为e的结点指针BTNode* Locate(BTNode* &amp;T,Elemtype_t &amp;e){ if(T==NULL||T-&gt;data==e) return T; BTNode *q; q = Locate(T-&gt;lchild,e); if(q) return q; //点睛之笔，减少了不必要的递归操作 q = Locate(T-&gt;rchild,e); return q;}//返回节点p的双亲结点BTNode* Parent(BTNode* &amp;T,BTNode* &amp;p){ if(T==NULL||T==p) return NULL; if(T-&gt;lchild==p||T-&gt;rchild==p) return T; BTNode *q; q = Parent(T-&gt;lchild,p); if(q) return q; q = Parent(T-&gt;rchild,p); return q;} 其他操作交换二叉树的左右节点1234567891011//交换二叉树的左右节点BTNode* BinaryTreeSwap(BTNode* &amp;T){ if(T){ BinaryTreeSwap(T-&gt;lchild); BinaryTreeSwap(T-&gt;rchild); BTNode *temp; temp = T-&gt;lchild; T-&gt;lchild = T-&gt;rchild; T-&gt;rchild = temp; }} 判断完全二叉树123456789101112131415161718192021222324//判断二叉树是否是完全二叉树//利用层次遍历，如果在非空结点之前有空结点，则二叉树不满bool Iscomplete(BTNode* T){ if(T==NULL) return 1; queue&lt;BTNode*&gt; q; BTNode *p; q.push(T); while(!q.empty()){ p = q.front(); q.pop(); if(p){ q.push(p-&gt;lchild); q.push(p-&gt;rchild); } else{ while(!q.empty()){ p = q.front(); if(!p) return 0; q.pop(); } } } return 1;} 复制一颗二叉树1234567891011//复制一颗二叉树BTNode* CopyBinaryTree(BTNode* &amp;T){ if(T==NULL) return NULL; BTNode *p; p = new BTNode; p-&gt;data = T-&gt;data; p-&gt;lchild = CopyBinaryTree(T-&gt;lchild); p-&gt;rchild = CopyBinaryTree(T-&gt;rchild); return p;} 统计叶结点个数123456789//统计树的叶结点个数int CountLeaf(BTNode* &amp;T,int &amp;n){ if(T){ CountLeaf(T-&gt;lchild,n); CountLeaf(T-&gt;rchild,n); if(!T-&gt;lchild&amp;&amp;!T-&gt;rchild) n++; }} 二叉搜索树 (BST)查找1234567891011121314151617181920212223242526//二叉搜索树动态查找BSTNode* BST_Find2(BSTNode *T,Elemtype_t x){ while(T){ if(x&gt;T-&gt;data) T = T-&gt;rchild; if(x&lt;T-&gt;data) T = T-&gt;lchild; else break; } return T;}//查找最小元素BSTNode* BST_FindMin(BSTNode *T){ if(T) while(T-&gt;lchild) T=T-&gt;lchild; return T;}//查找最大元素BSTNode* BST_FindMax(BSTNode *T){ if(T) while(T-&gt;rchild) T=T-&gt;rchild; return T;} 删除12345678910111213141516171819202122232425262728//删除//如果左子树和右子树均存在，取右子树中最小的结点替换，否则取左（右）子树第一个节点替换BSTNode* Delete_BSTNode_x(BSTNode* &amp;T,Elemtype_t x){ BSTNode *tmp; if(!T) cout&lt;&lt;"要删除的元素未找到！"&lt;&lt;endl; else{ if(x&lt;T-&gt;data) T-&gt;lchild=Delete_BSTNode_x(T-&gt;lchild,x); else if(x&gt;T-&gt;data) T-&gt;rchild=Delete_BSTNode_x(T-&gt;rchild,x); else{ if(T-&gt;lchild&amp;&amp;T-&gt;rchild){ tmp = BST_FindMin(T-&gt;rchild); T-&gt;data=tmp-&gt;data; T-&gt;rchild=Delete_BSTNode_x(T-&gt;rchild,T-&gt;data); } else{ tmp = T; if(!T-&gt;lchild) //只有右孩子或孩子结点 T = T-&gt;rchild; else T = T-&gt;lchild; //只有左孩子 delete tmp; } } } return T;} 平衡二叉树 (AVL)平衡二叉树的插入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include "BTree.h"using namespace std;typedef BTNode AVLNode;#define max(a,b) a&gt;b?a:bAVLNode* SingleLeftRotation(AVLNode* &amp;T);AVLNode* DoubleLeftRightRotation(AVLNode* &amp;T);AVLNode* SingleRightRotation(AVLNode* &amp;T);AVLNode* DoubleRightLeftRotation(AVLNode* &amp;T);int GetHeight(AVLNode *T){ if(T==NULL) return 0; else return T-&gt;height;}//平衡二叉树的插入AVLNode* AVL_Insert(AVLNode* &amp;T,Elemtype_t e){ if(!T){ T = new AVLNode; T-&gt;data = e; T-&gt;height = 1; T-&gt;lchild = T-&gt;rchild =NULL; } else if(e&lt;T-&gt;data){ T-&gt;lchild = AVL_Insert(T-&gt;lchild,e); //如果需要左旋 if(GetHeight(T-&gt;lchild)-GetHeight(T-&gt;rchild) == 2){ if(e&lt;T-&gt;lchild-&gt;data) T=SingleLeftRotation(T); //左单旋 else T=DoubleLeftRightRotation(T); //左右双旋 } } else if(e&gt;T-&gt;data){ T-&gt;rchild = AVL_Insert(T-&gt;rchild,e); //如果需要右旋 if(GetHeight(T-&gt;lchild)-GetHeight(T-&gt;rchild) == -2){ if(e&gt;T-&gt;rchild-&gt;data) T=SingleRightRotation(T); //右单旋 else T=DoubleRightLeftRotation(T); //右左双旋 } } //更新树高 T-&gt;height = max(GetHeight(T-&gt;lchild),GetHeight(T-&gt;rchild))+1; return T;}AVLNode* SingleLeftRotation(AVLNode* &amp;T){ BTNode* tmp; tmp = T-&gt;lchild; T-&gt;lchild = tmp-&gt;rchild; tmp-&gt;rchild = T; T-&gt;height = max(GetHeight(T-&gt;lchild),GetHeight(T-&gt;rchild))+1; tmp-&gt;height = max(GetHeight(tmp-&gt;lchild),GetHeight(tmp-&gt;rchild))+1; return tmp;}AVLNode* SingleRightRotation(AVLNode* &amp;T){ BTNode* tmp; tmp = T-&gt;rchild; T-&gt;rchild = tmp-&gt;lchild; tmp-&gt;lchild = T; T-&gt;height = max(GetHeight(T-&gt;lchild),GetHeight(T-&gt;rchild))+1; tmp-&gt;height = max(GetHeight(tmp-&gt;lchild),GetHeight(tmp-&gt;rchild))+1; return tmp;}AVLNode* DoubleLeftRightRotation(AVLNode* &amp;T){ T-&gt;lchild = SingleRightRotation(T-&gt;lchild); T = SingleLeftRotation(T); return T;}AVLNode* DoubleRightLeftRotation(AVLNode* &amp;T){ T-&gt;rchild = SingleLeftRotation(T-&gt;rchild); T = SingleRightRotation(T); return T;} 其他操作判断是否为平衡二叉树12345678910111213141516171819//暴力解法是对每个结点计算左右子树高度求平衡因子//在后续遍历时保存在左右子树的信息，可以边遍历边判断bool IsBalanced(BTNode* T,int* depth){ if(T==NULL){ *depth = 0; return true; } int nLeftDepth, nRightDepth; bool bleft = IsBalanced(T-&gt;lchild,&amp;nLeftDepth); bool bright = IsBalanced(T-&gt;rchild,&amp;nRightDepth); if(bleft&amp;&amp;bright){ int diff = nLeftDepth - nRightDepth; if(diff&lt;1&amp;&amp;diff&gt;-1){ *depth = 1 + (nLeftDepth &gt; nRightDepth ? nLeftDepth : nRightDepth); return true; } } return false;} 堆 (优先队列)大根堆的初始化123456789101112131415struct HNode{ Elemtype_h *data; int size; int capacity;};typedef Heap MaxHeap;typedef Heap MinHeap;MaxHeap InitHeap(int maxsize){ MaxHeap H = new HNode; H-&gt;size = 0; H-&gt;capacity = maxsize; H-&gt;data[0] = MAXDATA; return H;} 大根堆的插入1234567891011121314//大根堆的插入//从下往上寻找合适的位置，对路径上的结点做下移bool IsFull(MaxHeap H){ return H-&gt;size==H-&gt;capacity;}bool Insert(MaxHeap &amp;H,Elemtype_h e){ if(IsFull(H)) return 0; int i=++H-&gt;size; for(;H-&gt;data[i/2]&lt;e;i/=2){ H-&gt;data[i]=H-&gt;data[i/2]; } H-&gt;data[i]=e; return 1;} 大根堆删除最大值1234567891011121314151617181920//大根堆删除最大值//将最后一个元素从上往下寻找合适的位置，对路径上的结点做上移bool IsEmpty(MaxHeap &amp;H){ return H-&gt;size==0;}Elemtype_h Delete_Max(MaxHeap &amp;H){ if(IsEmpty(H)) return ERROR; int parent,child; H-&gt;data[0]=H-&gt;data[1]; Elemtype_h x=H-&gt;data[H-&gt;size--]; for(parent=1;parent*2&lt;=H-&gt;size;parent=child){ child=parent*2; if(child+1&lt;H-&gt;size&amp;&amp;H-&gt;data[child]&lt;H-&gt;data[child+1]) child++; if(x&gt;H-&gt;data[child]) break; else H-&gt;data[parent]=H-&gt;data[child]; } H-&gt;data[parent] = x; return H-&gt;data[0];} 二叉树调整为最大堆1234567891011121314151617//二叉树调整为最大堆void PreDown(MaxHeap &amp;H,int p){ Elemtype_h x=H-&gt;data[p]; int parent,child; for(parent=p;parent*2 &lt;= H-&gt;size;parent=child){ child=parent*2; if(child+1&lt;H-&gt;size&amp;&amp;H-&gt;data[child]&lt;H-&gt;data[child+1]) child++; if(x&gt;H-&gt;data[child]) break; else H-&gt;data[parent]=H-&gt;data[child]; } H-&gt;data[parent]=x;}MaxHeap BuildMaxHeap(MaxHeap &amp;H){ for(int i=H-&gt;size/2;i&gt;0;i--) PreDown(H,i);} 哈夫曼树123456789101112131415161718typedef struct HTNode *HuffmanTree;struct HTNode{ int weight; HuffmanTree lchild; HuffmanTree rchild;}HuffmanTree Huffman(MinHeap H){ HuffmanTree T; BuildHeap(H); for(int i=1;i&lt;H-&gt;size;i++){ T=new HTNode; T-&gt;lchild=Delete_Min(H); T-&gt;rchild=Delete_Min(H); T-&gt;weight = T-&gt;left-&gt;weight+T-&gt;right-&gt;weight; Insert(H,T-&gt;weight); } return Delete_MIN(H);} 图图的存储邻接矩阵1234567#define MAXV 1000 //邻接矩阵占用内存过大，一般要求顶点数不超过1000typedef int EdgeType;typedef struct{ VetrexType Vex[MAXV]; EdgeType Edge[MAXV][MAXV]; int v,a //当前边数和顶点数} 邻接表12345678910111213141516//通用版基础定义方法//顶点表（顶点域、边表头指针）、边表（邻接点域、指针域）#define MAXV 1000struct ArcNode{ int adjvex; //邻接点下标 WeightType weight; //顶点和这个点之间边的权重 ArcNode *next;}struct VNode{ VertexType data; ArcNode *first;}struct ALGraph{ VNode *vertices; int v,a;} 1234567//利用vector快速构建struct Node{ int v,w; Node(int _v,int _w):v(_v),w(_w){}}vector&lt;Node&gt; Adj[N]Adj[1].push_back(Node(3,4)) //构造一条从节点1指向节点3的有向边,权重为4 十字链表12345678910111213#define MAXV 100struct ArcNode{ int tailvex,headvex; ArcNode *hlink,*tlink;} struct VNode{ VertexType data; ArcNode *firstin,*firstout;}struct GLGraph{ VNode xlist[MAXV]; int v,a;} * 邻接多重表图的遍历12const int MAXV=1000;const int INF=1000000000; DFS 伪代码描述 123456void DFS(int u){ //u为起点 标记u已被访问； for(u所能达到的所有未被访问的节点v){ DFS(v); }} 邻接矩阵 12345678int n,G[MAXV][MAXV]{INF}; //n为当前图的顶点总数bool vis[MAXV]{false};void DFS(int u,int depth){ vis[u]=true; for(int v=0;v&lt;n;v++) if(vis[v]==false&amp;&amp;G[u][v]!=INF) DFS(v,depth+1);} 邻接表 1234567891011vector &lt;int&gt; Adj[MAXV]; //和定义中不一样的是，这里压入的数表示其相邻的结点int n; bool vis[MAXV]{false};void DFS(int u,int depth){ vis[u]=true; for(int i=0;i&lt;Adj[u].size();i++){ //两者的区别就在于找邻接点不一样 int v=Adh[u][i]; if(vis[v]==false) DFS(u,depth+1); }} 遍历函数 12345void BFSTrave(){ //这个函数是必要的，因为图不一定是连通的，所以一定要判断所有的顶点 for(int u=0;u&lt;n;u++) if(vis[u]==false) DFS(u,1);} BFS 伪代码描述 123456789void BFS(int u){ //u为起点 将u入队并标记； while(队列不为空){ 取出队首元素p(当前节点)； for(当前节点p所能到达的所有未被标记的顶点v){ 将v入队并标记； } }} 邻接矩阵 123456789101112131415161718int n,G[MAXV][MAXV];bool inque[MAXV];void BFS(int u){ queue &lt;int&gt; q; q.push(u); inque[u]=true; while(!q.empty()){ int p = q.front(); q.pop(); for(int v=0;v&lt;n;v++){ if(inque[v]==false&amp;&amp;G[p][v]!=INF){ q.push(v); inque[v]=true; } } }} 邻接表 1234567891011121314151617vector &lt;int&gt; G[MAXV];bool inque[MAXV];void BFS(int u){ queue &lt;int&gt; q; q.push(u); inque[u]=true; while(!q.empty()){ int p = q.front(); q.pop(); for(int i=0;i&lt;G[p].size();i++) if(inque[i]==false){ q.push(i); inque[i]=true; } }} 遍历函数 12345void BFSTrave(){ for(int u=0;u&lt;n;u++) if(inque[u]==false) BFS(q);} 最短路径12const int MAXV 1000; //最大顶点数const int INF 100000000; //设置一个很大的值用于表示邻接矩阵中两个节点不连通 Dijkstra 伪代码描述 1234567891011Dijkstra(G,d[],s){ //G为图，d为源点，s为起点 初始化 for(循环n次){ u = d[u]中最小且未被访问过的点； 将u标记为已经被访问； for(从u出发能到达的所有顶点v){ if(v未被访问并且以u为中介使d[v]更优) 更新d[v] } }} 邻接矩阵 123456789101112131415161718192021int n,G[MAXV][MAXV];int d[MAXV];bool vis[MAXV]={false};void dijkstra(int s){ fill(d,d+MAXV,INF); d[s]=0; for(int i=0;i&lt;n;i++){ int u=-1,MIN=INF; for(int j=0;j&lt;n;j++) if(vis[j]==false&amp;&amp;d[j]&lt;MIN){ u=j; MIN=d[j]; } if(u==-1) return; //这里是不连通的情况 vis[u]=true; for(int v=0;v&lt;n;v++) if(vis[v]==flase&amp;&amp;G[u][v]!=INF&amp;&amp;d[u]+G[u][v]&lt;d[v]) d[v]=d[u]+G[u][v] }} 邻接表 12345678910111213141516171819202122232425struct Node { int v,dis;}vector &lt;Node&gt; G[MAXV];int d[MAXV];int vis[MAXV]{false};void dijkstra(int s){ fill[d,d+MAXV,INF]; d[s]=0; for(int i=0;i&lt;n;i++){ int u=-1,MIN=INF; if(vis[i]d==false&amp;&amp;[i]&lt;MIN){ u=i; MIN=d[u]; } if(u==-1) return; vis[u]=true; for(int j=0;j&lt;G[u].size();j++){ int v=G[u][j].v; if(vis[v]d==false&amp;&amp;[u]+G[u][j].dis&lt;d[v]) d[v]=d[u]+G[u][j].dis; } }} 一些改进 保存每个节点最短路径的前驱节点并用递归的方法输出最短路径 123456789101112131415161718//在更新每个节点的最短距离（d[i]）时记录前驱//临界矩阵的部分调整pre[MAXV] //保存每个节点的前驱节点for(int v=0;v&lt;n;v++){ if(vis[v]==flase&amp;&amp;G[u][v]!=INF&amp;&amp;d[u]+G[u][v]&lt;d[v]){ d[v]=d[u]+G[u][v]; pre[v]=u; }}//此时可以递归的输出最短路径void DFS(int s,int v){ //s为起点，v为当前节点 if(s==v){ printf("%d\n",s); return; } DFS(s,pre[v]); printf("%d\n",v);} 多条最短路径问题 同上只需在更新节点最短路径的时候略作调整进行相应的判断 可以新增一个数组来表示边权、点权和最短路径条数 给每条边在增加一条边权（二维数组 cost 记录边权，c [] 记录最小花费） 123456789101112for(int v=0;v&lt;n;v++){ if(vis[v]==false&amp;&amp;G[u][v]!=INF){ if(d[u]+G[u][v]&lt;d[v]){ d[v]=d[u]+G[u][v]; c[v]=c[u]+cost[u][v]; pre[v]=u; }else if(d[u]+G[u][v]==d[v]&amp;&amp;c[u]+cost[u][v]&lt;c[v]){ c[v]=c[u]+cost[u][v]; pre[v]=u; } }} 给每个顶点增加一个点权（weight [] 记录点权，w [] 为路径上的最大点权和） 123456789101112for(int v=0;v&lt;n;v++){ if(vis[v]==false&amp;&amp;G[u][v]!=INF){ if(d[u]+G[u][v]&lt;d[v]){ d[v]=d[u]+G[u][v]; w[v]=w[u]+weight[v]; pre[u]=v; }else if(d[u]+G[u][v]==d[v]&amp;&amp;w[u]+weight[v]&gt;w[v]){ w[v]=w[u]+weight[v]; pre[v]=u; } }} 到达每个顶点的最短路径条数（用 num [] 保存) 12345678910for(int v=0;v&lt;n;v++){ if(vis[v]==false&amp;&amp;G[u][v]!=INF){ if(d[u]+G[u][v]&lt;d[v]){ d[v]=d[u]+G[u][v]; num[v]=num[u]; }else if(d[u]+G[u][v]==d[v]){ num[v]+=num[u]; } }} Bellman-Ford 伪代码描述 123456789101112for(i=0;i&lt;n-1;i++){ //进n-1轮操作，其中n为顶点数 for(u的所有邻接边u-&gt;v){ if(d[u]+length[u-&gt;v]&lt;d[v]) d[v]=d[u]+length[u-&gt;v] }}//如果图中有负环，则d还能进行更新，返回falsefor(u的所有邻接边u-&gt;v){ if(d[u]+length[u-&gt;v]&lt;d[v]) return false; return true;} 邻接表 12345678910111213141516171819202122232425262728struct Node{ int v,dis;}vector &lt;Node&gt; G[MAXV]int n;int d[MAXV];bool Bellman(int s){ fill(d,d+MAXV,INF); d[s]=0; for(int i=0;i&lt;n-1;i++){ for(int u=0;u&lt;n;u++) for(int j=0;j&lt;G[u].size();j++){ int v=G[u][j].v; int dis=G[u][j].dis; if(d[u]+dis&lt;d[v]){ d[v]=d[u]+dis; } } } for(int u=0;u&lt;n;u++) for(int j=0;j&lt;G[u].size();j++){ int v=G[u][j].v; int dis=G[u][j].dis; if(d[u]+dis&lt;d[v]) return false; }} SPFA 伪代码描述 12345678910111213141516171819202122bool SPFA(G,d[],s){ int Queue[maxn]; int front=rear=0; int inq[maxn]; 初始化inq、num、d; 源点s入队; while(队列非空){ 取出队首元素u; for(u的所有邻接边u-&gt;v){ if(d[u]+dis&lt;d[v]){ d[v]=d[u]+dis; if(v当前不在队列){ v入队； if(v入队次数大于n-1){ return;//有可达负环 } } } } } return;//达到最优} 邻接表 12345678910111213141516171819202122232425262728293031323334vector &lt;Node&gt; Adj[MAXN];int n,num[MAXN],d[MAXN];bool inq[MAXN];bool SPFA(int s){ fill(d,d+MAXN,INF); fill(inq,inq+MAXN,false); fill(num,num+MAXN,0); queue &lt;int&gt; Q; Q.push(s); inq[s] = true; num[s]++; d[s] = 0; while(!Q.empty()){ int u = Q.front(); Q.pop(); inq[u] = false; for(int i=0;i&lt;Adj[u].size();i++){ int v = Adj[u][i].v; int dis = Adj[u][i].dis; if(d[u]+dis&lt;d[v]){ d[v] = d[u]+dis; if(!inq[v]){ Q.push(v); inq[v] = true; num[v]++; if(num[v]&gt;n-1) return false; //进入队列n次，说明有负环 } } } } return true;} Floyd 外代码描述 1234枚举所有顶点k 枚举所有以k为中介点的顶底对i和j if(dis[i][k]+dis[k][j]&lt;dis[i][j]) 更新dis[i][j] 邻接矩阵 1234567891011//Floyd解决全源最短路径问题int n,m;int dis[MAXV][MAXV]void Floyd(){ for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(dis[i][k]!=INF&amp;&amp;dis[k][j]!=INF&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j]) dis[i][j]=dis[i][k]+dis[k][j];} 最小生成树Prim 伪代码描述 123456789101112Dijkstra(G,d[],s){ //G为图，d为源点，s为起点 初始化 for(循环n次){ u = d[u]中最小且未被访问过的点; 将u标记为已经被访问; 将d[u]加入最小边权和; for(从u出发能到达的所有顶点v){ if(v未被访问并且以u为中介使d[v]更优) 更新d[v] //这里的更新与最优与Dijkstra中是不一样的，但整个算法是一致的 } }} 邻接矩阵 1234567891011121314151617181920212223int n,G[MAXV][MAXV];int d[MAXV];bool vis[MAXV]={false};int dijkstra(int s){ int ans; fill(d,d+MAXV,INF); d[s]=0; for(int i=0;i&lt;n;i++){ int u=-1,MIN=INF; for(int j=0;j&lt;n;j++) if(vis[j]==false&amp;&amp;d[j]&lt;MIN){ u=j; MIN=d[j]; } if(u==-1) return; //这里是不连通的情况 vis[u]=true; ans += d[u]; for(int v=0;v&lt;n;v++) if(vis[v]==flase&amp;&amp;G[u][v]!=INF&amp;&amp;G[u][v]&lt;d[v]) d[v]=G[u][v] //这就是前面说的不一样的地方 }} Kruskal 伪代码描述 12345678910int Kruskal(){ for(从小到大枚举所有的边){ if(当前测试边的顶点在不同的两个连接块中){ 将该测试边加入最小生成树; ans+=此边权值; 最小生成树的边数加1; 当边数为n-1是结束循环； } }} 并查集实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct Edge{ int u,v;//边的两个端点编号 int cost;//边权}E[maxn];int father[maxn];//并查集数组int FindFather(int x){ int z,a=x; while(x!=father[x]){ x=father[x]; } //路径压缩 while(a!=father[a]){ z=a; a=father[a]; father[z]=x; } return x;}int Kruskal(int n,int m){//参数n为顶点个数，m为图的边数，函数返回边权之和 int ans=0,NumEdge=0;//ans为所求边权之和，NumEdge为当前生成树的边数 int i; int faU,faV; //查并集初始化 for(i=1;i&lt;=n;i++){ father[i]=i; } //按边权大小排序 for(i=0;i&lt;m;i++){ faU=findFather(E[i].u); faV=findFather(E[i].v);//查询测试边的两个端点所在集合的根节点 if(faU!=faV){//如果不在一个集合内 father[faU]=faV;//合并集合，把测试边加入最小生成树中 ans+=E[i].cost;//边权之和计算 NumEdge++;//当前生成树的边数加一 if(NumEdge==n-1){ break;//边数等于顶点数减一时结束算法 } } } if(NumEdge!=n-1){ return -1;//无法连通时返回-1 }else{ return ans;//返回最小生成树的边权之和 }} 拓扑排序 邻接表 1234567891011121314151617181920212223242526vector&lt;int&gt; G[MAXN];int n,m,inDegree[MAXN];bool topologicalSort(){ int num = 0; queue&lt;int&gt; q; for(int i=0;i&lt;n;i++){ if(inDegree[i] == 0){ q.push(i); } } while(!q.empty()){ int u = q.front(); q.pop(); for(int i=0;i&lt;G[u].size();i++){ int v = G[u][i]; inDereee[v]--; if(inDegree[v] == 0){ q.push(v); } } G[u].clear(); num++; } if(num == n) return true; else return false;} * 关键路径查找顺序查找123456int SeqSearch(SeqList L,Elemtype key){ int i = L.length; L.data[0] = key; //哨兵 for(;L.data[i]!=key;i--) return i;} 折半查找12345678910int BinarySearch(SeqList L,Elemtype key){ int low=1,high=L.length; while(low&lt;high){ //注意和快排找位置的区别 int mid=(low+high)/2; if(key==L.data[mid]) return mid; else if(key&gt;L.data[mid]) low=mid+1; else high=mid-1; } return 0;} 排序插入排序直接插入排序123456789void InsertSort(Elemtype A[],int n){ for(int i=2;i&lt;=n;i++) if(A[i]&lt;A[i-1]){ A[0]=A[i]; for(int j=i-1;A[j]&gt;A[0];j--) A[j+1]=A[j]; A[j+1]=A[0]; }} 折半插入排序1234567891011121314151617//折半插入排序void Binary_InsertSort(Elemtype A[],int n){ for(int i=2;i&lt;n;i++) if(A[i]&lt;A[i-1]){ A[0]=A[i]; int low=1,high=i-1; //注意此处为寻找有序表中第一个大于A[0]元素的位置，当low=high找到 while(low&lt;high){ int mid=(low+high)/2; if(A[mid]&gt;x) high=mid; else low=mid+1 } for(j=i-1;j&gt;=high;--j) A[j+1]=A[j]; A[high]=A[0]; }} 希尔排序1234567891011//希尔插入排序void ShellSort(Elemtype A[],int n){ for(int dk=n/2;dk&gt;=1;dk/=2) for(int i=dk+1;i&lt;=n;++i) if(A[i]&lt;A[i-dk]){ A[0]=A[i]; for(int j=i-dk;A[j]&gt;A[0];j-=dk) A[j+dk] = A[j]; A[j+dk] = A[0]; }} 交换排序冒泡排序12345678910111213//冒泡排序//注意此处tow point的思想void BubbleSort(Elemtype A[],int n){ for(int i=0;i&lt;n-1;i++){ bool flag=false; for(int j=n-1;j&gt;i;j--) if(A[j-1]&gt;A[j]){ swap(A[j-1],A[j]); flag = true; } if(!flag) break; }} 快速排序12345678910111213141516171819//快速排序int Partition(Elemtype A[],int low,int high){ Elemtype pivot=A[low]; while(low&lt;high){ while(low&lt;high&amp;&amp;A[high]&gt;=pivot) --high; A[low] = A[high]; while(low&lt;high&amp;&amp;A[low]&lt;=pivot) ++low; A[high] = A[low]; } A[low] = pivot; return low;}void QucikSort(Elemtype A[],int low,int high){ if(low&lt;high){ int pos=Partition(A,low,high); QuickSort(A,low,pos-1); QuickSort(A,pos+1,high); }} 选择排序简单选择排序1234567891011//简单选择排序void SelectSort(Elemtype A[],int n){ for(int i=0;i&lt;n-1;i++){ int min=i; for(j=i+1;j&lt;n;j++) if(A[j]&lt;A[min]) min=j; if(min!=i) swap(A[i],A[min]); }} 堆排序12345678910111213141516171819202122232425//堆排序void AdjustDown(Elemtype A[],int k,int len){ A[0]=a[k]; for(int i=2*k;i&lt;=len;i*=2){ if(i&lt;len&amp;&amp;A[i+1]&gt;A[i]) i++; if(A[0]&gt;A[i]) break; else{ A[k]=a[i]; k=i; } } A[k]=A[0];}void BuildMaxHeap(Elemtype A[],int len){ for(int i=len/2,i&gt;0;i--) AdjustDown(A,i,len);}void HeapSort(Elemtype A[],int len){ BuildMaxHeap(A,len); for(int i=len;i&gt;1;i--){ Swap(A[i],A[1]); AdjustDown(A,1,i-1); }} 归并排序二路归并排序12345678910111213141516171819202122//归并排序int *C = new Elemtype;void Merge(Elemtype A[],int low,int mid,int high){ for(int k=low;k&lt;=high;k++) B[k]=A[k]; for(int i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++){ if(B[i]&lt;=B[j]) A[k]=B[i++]; else A[k]=B[j++]; } while(i&lt;=mid) A[k++]=B[i++]; while(j&lt;=high) A[k++]=B[j++];}void MergeSort(Elemtype A[],int low.int high){ if(low&lt;high){ int mid=(low+high)/2; MergeSort(A,low,mid); MergeSort(A,mid+1,high); Merge(A,low,mid,high); }} * 基数排序]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
</search>
